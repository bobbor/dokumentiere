<!DOCTYPE html><html><head><meta charset="utf-8"><title>src\templates\public\js\libs\require-jquery.js Dokumentation (Source)</title><link rel="stylesheet" href="css/jquery.jscrollpane.css" media="all"><link rel="stylesheet" href="css/style.css" media="all"><link rel="stylesheet" href="css/font-awesome.css" media="all"><link rel="stylesheet" href="css/sh.min.css" media="all"><script src="js/sh_main.min.js"></script><script src="js/sh_javascript.min.js"></script><script data-main="js/main.js" src="js/libs/require-jquery.js"></script><script>$(function() {
 if(location.hash) {
  var name = location.hash.substring(1, location.hash.length);
  $('a[name="'+name+'"]').addClass('highlight');
 }
})</script></head><body id="source" onload="sh_highlightDocument();"><div id="wrapper"><div id="main"><aside class="items"><header><h1><a href="index.html"><em>Aperto</em><span><b>JS</b>Docs</span></a></h1></header><div id="filter"><form><div class="col col-3"><input type="search" placeholder="Suche" name="filter"><button><span>Los</span></button></div><div class="col col-9"><ul class="props"><li><input id="node-module" type="checkbox" name="node-module" checked><label for="node-module">node-module</label></li></ul></div></form></div><section data-type="node-module" data-name="doku" class="col col-3"><h1><a href="node.doku.html">doku</a></h1><h2>node-module (node)</h2><p>starts documentation on the files</p></section><section data-type="node-module" data-name="foldercopy" class="col col-3"><h1><a href="node.foldercopy.html">foldercopy</a></h1><h2>node-module (node)</h2><p>copies the specified folder</p></section><section data-type="node-module" data-name="tags" class="col col-3"><h1><a href="node.tags.html">tags</a></h1><h2>node-module (node)</h2><p>this parses the &quot;tags&quot;</p></section><section data-type="node-module" data-name="tmpl" class="col col-3"><h1><a href="node.tmpl.html">tmpl</a></h1><h2>node-module (node)</h2><p>gets the parsed comments and generates the html</p></section></aside><div id="content"><h1> <span>Source View</span>src\templates\public\js\libs\require-jquery.js</h1><pre class="sh_javascript"><a name="line-1" data-line="1">/** vim: et:ts=4:sw=4:sts=4
</a><a name="line-2" data-line="2"> * @license RequireJS 2.0.4 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
</a><a name="line-3" data-line="3"> * Available via the MIT or new BSD license.
</a><a name="line-4" data-line="4"> * see: http://github.com/jrburke/requirejs for details
</a><a name="line-5" data-line="5"> */
</a><a name="line-6" data-line="6">/*jslint regexp: true, nomen: true */
</a><a name="line-7" data-line="7">/*global window, navigator, document, importScripts, jQuery, setTimeout, opera */
</a><a name="line-8" data-line="8">
</a><a name="line-9" data-line="9">var requirejs, require, define;
</a><a name="line-10" data-line="10">(function (global) {
</a><a name="line-11" data-line="11">    'use strict';
</a><a name="line-12" data-line="12">
</a><a name="line-13" data-line="13">    var version = '2.0.4',
</a><a name="line-14" data-line="14">        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
</a><a name="line-15" data-line="15">        cjsRequireRegExp = /[^.]\s*require\s*\(\s*[&quot;']([^'&quot;\s]+)[&quot;']\s*\)/g,
</a><a name="line-16" data-line="16">        jsSuffixRegExp = /\.js$/,
</a><a name="line-17" data-line="17">        currDirRegExp = /^\.\//,
</a><a name="line-18" data-line="18">        ostring = Object.prototype.toString,
</a><a name="line-19" data-line="19">        ap = Array.prototype,
</a><a name="line-20" data-line="20">        aps = ap.slice,
</a><a name="line-21" data-line="21">        apsp = ap.splice,
</a><a name="line-22" data-line="22">        isBrowser = !!(typeof window !== 'undefined' &amp;&amp; navigator &amp;&amp; document),
</a><a name="line-23" data-line="23">        isWebWorker = !isBrowser &amp;&amp; typeof importScripts !== 'undefined',
</a><a name="line-24" data-line="24">        //PS3 indicates loaded and complete, but need to wait for complete
</a><a name="line-25" data-line="25">        //specifically. Sequence is 'loading', 'loaded', execution,
</a><a name="line-26" data-line="26">        // then 'complete'. The UA check is unfortunate, but not sure how
</a><a name="line-27" data-line="27">        //to feature test w/o causing perf issues.
</a><a name="line-28" data-line="28">        readyRegExp = isBrowser &amp;&amp; navigator.platform === 'PLAYSTATION 3' ?
</a><a name="line-29" data-line="29">                      /^complete$/ : /^(complete|loaded)$/,
</a><a name="line-30" data-line="30">        defContextName = '_',
</a><a name="line-31" data-line="31">        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
</a><a name="line-32" data-line="32">        isOpera = typeof opera !== 'undefined' &amp;&amp; opera.toString() === '[object Opera]',
</a><a name="line-33" data-line="33">        contexts = {},
</a><a name="line-34" data-line="34">        cfg = {},
</a><a name="line-35" data-line="35">        globalDefQueue = [],
</a><a name="line-36" data-line="36">        useInteractive = false,
</a><a name="line-37" data-line="37">        req, s, head, baseElement, dataMain, src,
</a><a name="line-38" data-line="38">        interactiveScript, currentlyAddingScript, mainScript, subPath;
</a><a name="line-39" data-line="39">
</a><a name="line-40" data-line="40">    function isFunction(it) {
</a><a name="line-41" data-line="41">        return ostring.call(it) === '[object Function]';
</a><a name="line-42" data-line="42">    }
</a><a name="line-43" data-line="43">
</a><a name="line-44" data-line="44">    function isArray(it) {
</a><a name="line-45" data-line="45">        return ostring.call(it) === '[object Array]';
</a><a name="line-46" data-line="46">    }
</a><a name="line-47" data-line="47">
</a><a name="line-48" data-line="48">    /**
</a><a name="line-49" data-line="49">     * Helper function for iterating over an array. If the func returns
</a><a name="line-50" data-line="50">     * a true value, it will break out of the loop.
</a><a name="line-51" data-line="51">     */
</a><a name="line-52" data-line="52">    function each(ary, func) {
</a><a name="line-53" data-line="53">        if (ary) {
</a><a name="line-54" data-line="54">            var i;
</a><a name="line-55" data-line="55">            for (i = 0; i &lt; ary.length; i += 1) {
</a><a name="line-56" data-line="56">                if (ary[i] &amp;&amp; func(ary[i], i, ary)) {
</a><a name="line-57" data-line="57">                    break;
</a><a name="line-58" data-line="58">                }
</a><a name="line-59" data-line="59">            }
</a><a name="line-60" data-line="60">        }
</a><a name="line-61" data-line="61">    }
</a><a name="line-62" data-line="62">
</a><a name="line-63" data-line="63">    /**
</a><a name="line-64" data-line="64">     * Helper function for iterating over an array backwards. If the func
</a><a name="line-65" data-line="65">     * returns a true value, it will break out of the loop.
</a><a name="line-66" data-line="66">     */
</a><a name="line-67" data-line="67">    function eachReverse(ary, func) {
</a><a name="line-68" data-line="68">        if (ary) {
</a><a name="line-69" data-line="69">            var i;
</a><a name="line-70" data-line="70">            for (i = ary.length - 1; i &gt; -1; i -= 1) {
</a><a name="line-71" data-line="71">                if (ary[i] &amp;&amp; func(ary[i], i, ary)) {
</a><a name="line-72" data-line="72">                    break;
</a><a name="line-73" data-line="73">                }
</a><a name="line-74" data-line="74">            }
</a><a name="line-75" data-line="75">        }
</a><a name="line-76" data-line="76">    }
</a><a name="line-77" data-line="77">
</a><a name="line-78" data-line="78">    function hasProp(obj, prop) {
</a><a name="line-79" data-line="79">        return obj.hasOwnProperty(prop);
</a><a name="line-80" data-line="80">    }
</a><a name="line-81" data-line="81">
</a><a name="line-82" data-line="82">    /**
</a><a name="line-83" data-line="83">     * Cycles over properties in an object and calls a function for each
</a><a name="line-84" data-line="84">     * property value. If the function returns a truthy value, then the
</a><a name="line-85" data-line="85">     * iteration is stopped.
</a><a name="line-86" data-line="86">     */
</a><a name="line-87" data-line="87">    function eachProp(obj, func) {
</a><a name="line-88" data-line="88">        var prop;
</a><a name="line-89" data-line="89">        for (prop in obj) {
</a><a name="line-90" data-line="90">            if (obj.hasOwnProperty(prop)) {
</a><a name="line-91" data-line="91">                if (func(obj[prop], prop)) {
</a><a name="line-92" data-line="92">                    break;
</a><a name="line-93" data-line="93">                }
</a><a name="line-94" data-line="94">            }
</a><a name="line-95" data-line="95">        }
</a><a name="line-96" data-line="96">    }
</a><a name="line-97" data-line="97">
</a><a name="line-98" data-line="98">    /**
</a><a name="line-99" data-line="99">     * Simple function to mix in properties from source into target,
</a><a name="line-100" data-line="100">     * but only if target does not already have a property of the same name.
</a><a name="line-101" data-line="101">     * This is not robust in IE for transferring methods that match
</a><a name="line-102" data-line="102">     * Object.prototype names, but the uses of mixin here seem unlikely to
</a><a name="line-103" data-line="103">     * trigger a problem related to that.
</a><a name="line-104" data-line="104">     */
</a><a name="line-105" data-line="105">    function mixin(target, source, force, deepStringMixin) {
</a><a name="line-106" data-line="106">        if (source) {
</a><a name="line-107" data-line="107">            eachProp(source, function (value, prop) {
</a><a name="line-108" data-line="108">                if (force || !hasProp(target, prop)) {
</a><a name="line-109" data-line="109">                    if (deepStringMixin &amp;&amp; typeof value !== 'string') {
</a><a name="line-110" data-line="110">                        if (!target[prop]) {
</a><a name="line-111" data-line="111">                            target[prop] = {};
</a><a name="line-112" data-line="112">                        }
</a><a name="line-113" data-line="113">                        mixin(target[prop], value, force, deepStringMixin);
</a><a name="line-114" data-line="114">                    } else {
</a><a name="line-115" data-line="115">                        target[prop] = value;
</a><a name="line-116" data-line="116">                    }
</a><a name="line-117" data-line="117">                }
</a><a name="line-118" data-line="118">            });
</a><a name="line-119" data-line="119">        }
</a><a name="line-120" data-line="120">        return target;
</a><a name="line-121" data-line="121">    }
</a><a name="line-122" data-line="122">
</a><a name="line-123" data-line="123">    //Similar to Function.prototype.bind, but the 'this' object is specified
</a><a name="line-124" data-line="124">    //first, since it is easier to read/figure out what 'this' will be.
</a><a name="line-125" data-line="125">    function bind(obj, fn) {
</a><a name="line-126" data-line="126">        return function () {
</a><a name="line-127" data-line="127">            return fn.apply(obj, arguments);
</a><a name="line-128" data-line="128">        };
</a><a name="line-129" data-line="129">    }
</a><a name="line-130" data-line="130">
</a><a name="line-131" data-line="131">    function scripts() {
</a><a name="line-132" data-line="132">        return document.getElementsByTagName('script');
</a><a name="line-133" data-line="133">    }
</a><a name="line-134" data-line="134">
</a><a name="line-135" data-line="135">    //Allow getting a global that expressed in
</a><a name="line-136" data-line="136">    //dot notation, like 'a.b.c'.
</a><a name="line-137" data-line="137">    function getGlobal(value) {
</a><a name="line-138" data-line="138">        if (!value) {
</a><a name="line-139" data-line="139">            return value;
</a><a name="line-140" data-line="140">        }
</a><a name="line-141" data-line="141">        var g = global;
</a><a name="line-142" data-line="142">        each(value.split('.'), function (part) {
</a><a name="line-143" data-line="143">            g = g[part];
</a><a name="line-144" data-line="144">        });
</a><a name="line-145" data-line="145">        return g;
</a><a name="line-146" data-line="146">    }
</a><a name="line-147" data-line="147">
</a><a name="line-148" data-line="148">    function makeContextModuleFunc(func, relMap, enableBuildCallback) {
</a><a name="line-149" data-line="149">        return function () {
</a><a name="line-150" data-line="150">            //A version of a require function that passes a moduleName
</a><a name="line-151" data-line="151">            //value for items that may need to
</a><a name="line-152" data-line="152">            //look up paths relative to the moduleName
</a><a name="line-153" data-line="153">            var args = aps.call(arguments, 0), lastArg;
</a><a name="line-154" data-line="154">            if (enableBuildCallback &amp;&amp;
</a><a name="line-155" data-line="155">                isFunction((lastArg = args[args.length - 1]))) {
</a><a name="line-156" data-line="156">                lastArg.__requireJsBuild = true;
</a><a name="line-157" data-line="157">            }
</a><a name="line-158" data-line="158">            args.push(relMap);
</a><a name="line-159" data-line="159">            return func.apply(null, args);
</a><a name="line-160" data-line="160">        };
</a><a name="line-161" data-line="161">    }
</a><a name="line-162" data-line="162">
</a><a name="line-163" data-line="163">    function addRequireMethods(req, context, relMap) {
</a><a name="line-164" data-line="164">        each([
</a><a name="line-165" data-line="165">            ['toUrl'],
</a><a name="line-166" data-line="166">            ['undef'],
</a><a name="line-167" data-line="167">            ['defined', 'requireDefined'],
</a><a name="line-168" data-line="168">            ['specified', 'requireSpecified']
</a><a name="line-169" data-line="169">        ], function (item) {
</a><a name="line-170" data-line="170">            var prop = item[1] || item[0];
</a><a name="line-171" data-line="171">            req[item[0]] = context ? makeContextModuleFunc(context[prop], relMap) :
</a><a name="line-172" data-line="172">                //If no context, then use default context. Reference from
</a><a name="line-173" data-line="173">                //contexts instead of early binding to default context, so
</a><a name="line-174" data-line="174">                //that during builds, the latest instance of the default
</a><a name="line-175" data-line="175">                //context with its config gets used.
</a><a name="line-176" data-line="176">                function () {
</a><a name="line-177" data-line="177">                    var ctx = contexts[defContextName];
</a><a name="line-178" data-line="178">                    return ctx[prop].apply(ctx, arguments);
</a><a name="line-179" data-line="179">                };
</a><a name="line-180" data-line="180">        });
</a><a name="line-181" data-line="181">    }
</a><a name="line-182" data-line="182">
</a><a name="line-183" data-line="183">    /**
</a><a name="line-184" data-line="184">     * Constructs an error with a pointer to an URL with more information.
</a><a name="line-185" data-line="185">     * @param {String} id the error ID that maps to an ID on a web page.
</a><a name="line-186" data-line="186">     * @param {String} message human readable error.
</a><a name="line-187" data-line="187">     * @param {Error} [err] the original error, if there is one.
</a><a name="line-188" data-line="188">     *
</a><a name="line-189" data-line="189">     * @returns {Error}
</a><a name="line-190" data-line="190">     */
</a><a name="line-191" data-line="191">    function makeError(id, msg, err, requireModules) {
</a><a name="line-192" data-line="192">        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
</a><a name="line-193" data-line="193">        e.requireType = id;
</a><a name="line-194" data-line="194">        e.requireModules = requireModules;
</a><a name="line-195" data-line="195">        if (err) {
</a><a name="line-196" data-line="196">            e.originalError = err;
</a><a name="line-197" data-line="197">        }
</a><a name="line-198" data-line="198">        return e;
</a><a name="line-199" data-line="199">    }
</a><a name="line-200" data-line="200">
</a><a name="line-201" data-line="201">    if (typeof define !== 'undefined') {
</a><a name="line-202" data-line="202">        //If a define is already in play via another AMD loader,
</a><a name="line-203" data-line="203">        //do not overwrite.
</a><a name="line-204" data-line="204">        return;
</a><a name="line-205" data-line="205">    }
</a><a name="line-206" data-line="206">
</a><a name="line-207" data-line="207">    if (typeof requirejs !== 'undefined') {
</a><a name="line-208" data-line="208">        if (isFunction(requirejs)) {
</a><a name="line-209" data-line="209">            //Do not overwrite and existing requirejs instance.
</a><a name="line-210" data-line="210">            return;
</a><a name="line-211" data-line="211">        }
</a><a name="line-212" data-line="212">        cfg = requirejs;
</a><a name="line-213" data-line="213">        requirejs = undefined;
</a><a name="line-214" data-line="214">    }
</a><a name="line-215" data-line="215">
</a><a name="line-216" data-line="216">    //Allow for a require config object
</a><a name="line-217" data-line="217">    if (typeof require !== 'undefined' &amp;&amp; !isFunction(require)) {
</a><a name="line-218" data-line="218">        //assume it is a config object.
</a><a name="line-219" data-line="219">        cfg = require;
</a><a name="line-220" data-line="220">        require = undefined;
</a><a name="line-221" data-line="221">    }
</a><a name="line-222" data-line="222">
</a><a name="line-223" data-line="223">    function newContext(contextName) {
</a><a name="line-224" data-line="224">        var config = {
</a><a name="line-225" data-line="225">                waitSeconds: 7,
</a><a name="line-226" data-line="226">                baseUrl: './',
</a><a name="line-227" data-line="227">                paths: {},
</a><a name="line-228" data-line="228">                pkgs: {},
</a><a name="line-229" data-line="229">                shim: {}
</a><a name="line-230" data-line="230">            },
</a><a name="line-231" data-line="231">            registry = {},
</a><a name="line-232" data-line="232">            undefEvents = {},
</a><a name="line-233" data-line="233">            defQueue = [],
</a><a name="line-234" data-line="234">            defined = {},
</a><a name="line-235" data-line="235">            urlFetched = {},
</a><a name="line-236" data-line="236">            requireCounter = 1,
</a><a name="line-237" data-line="237">            unnormalizedCounter = 1,
</a><a name="line-238" data-line="238">            //Used to track the order in which modules
</a><a name="line-239" data-line="239">            //should be executed, by the order they
</a><a name="line-240" data-line="240">            //load. Important for consistent cycle resolution
</a><a name="line-241" data-line="241">            //behavior.
</a><a name="line-242" data-line="242">            waitAry = [],
</a><a name="line-243" data-line="243">            inCheckLoaded, Module, context, handlers,
</a><a name="line-244" data-line="244">            checkLoadedTimeoutId;
</a><a name="line-245" data-line="245">
</a><a name="line-246" data-line="246">        /**
</a><a name="line-247" data-line="247">         * Trims the . and .. from an array of path segments.
</a><a name="line-248" data-line="248">         * It will keep a leading path segment if a .. will become
</a><a name="line-249" data-line="249">         * the first path segment, to help with module name lookups,
</a><a name="line-250" data-line="250">         * which act like paths, but can be remapped. But the end result,
</a><a name="line-251" data-line="251">         * all paths that use this function should look normalized.
</a><a name="line-252" data-line="252">         * NOTE: this method MODIFIES the input array.
</a><a name="line-253" data-line="253">         * @param {Array} ary the array of path segments.
</a><a name="line-254" data-line="254">         */
</a><a name="line-255" data-line="255">        function trimDots(ary) {
</a><a name="line-256" data-line="256">            var i, part;
</a><a name="line-257" data-line="257">            for (i = 0; ary[i]; i+= 1) {
</a><a name="line-258" data-line="258">                part = ary[i];
</a><a name="line-259" data-line="259">                if (part === '.') {
</a><a name="line-260" data-line="260">                    ary.splice(i, 1);
</a><a name="line-261" data-line="261">                    i -= 1;
</a><a name="line-262" data-line="262">                } else if (part === '..') {
</a><a name="line-263" data-line="263">                    if (i === 1 &amp;&amp; (ary[2] === '..' || ary[0] === '..')) {
</a><a name="line-264" data-line="264">                        //End of the line. Keep at least one non-dot
</a><a name="line-265" data-line="265">                        //path segment at the front so it can be mapped
</a><a name="line-266" data-line="266">                        //correctly to disk. Otherwise, there is likely
</a><a name="line-267" data-line="267">                        //no path mapping for a path starting with '..'.
</a><a name="line-268" data-line="268">                        //This can still fail, but catches the most reasonable
</a><a name="line-269" data-line="269">                        //uses of ..
</a><a name="line-270" data-line="270">                        break;
</a><a name="line-271" data-line="271">                    } else if (i &gt; 0) {
</a><a name="line-272" data-line="272">                        ary.splice(i - 1, 2);
</a><a name="line-273" data-line="273">                        i -= 2;
</a><a name="line-274" data-line="274">                    }
</a><a name="line-275" data-line="275">                }
</a><a name="line-276" data-line="276">            }
</a><a name="line-277" data-line="277">        }
</a><a name="line-278" data-line="278">
</a><a name="line-279" data-line="279">        /**
</a><a name="line-280" data-line="280">         * Given a relative module name, like ./something, normalize it to
</a><a name="line-281" data-line="281">         * a real name that can be mapped to a path.
</a><a name="line-282" data-line="282">         * @param {String} name the relative name
</a><a name="line-283" data-line="283">         * @param {String} baseName a real name that the name arg is relative
</a><a name="line-284" data-line="284">         * to.
</a><a name="line-285" data-line="285">         * @param {Boolean} applyMap apply the map config to the value. Should
</a><a name="line-286" data-line="286">         * only be done if this normalization is for a dependency ID.
</a><a name="line-287" data-line="287">         * @returns {String} normalized name
</a><a name="line-288" data-line="288">         */
</a><a name="line-289" data-line="289">        function normalize(name, baseName, applyMap) {
</a><a name="line-290" data-line="290">            var baseParts = baseName &amp;&amp; baseName.split('/'),
</a><a name="line-291" data-line="291">                normalizedBaseParts = baseParts,
</a><a name="line-292" data-line="292">                map = config.map,
</a><a name="line-293" data-line="293">                starMap = map &amp;&amp; map['*'],
</a><a name="line-294" data-line="294">                pkgName, pkgConfig, mapValue, nameParts, i, j, nameSegment,
</a><a name="line-295" data-line="295">                foundMap;
</a><a name="line-296" data-line="296">
</a><a name="line-297" data-line="297">            //Adjust any relative paths.
</a><a name="line-298" data-line="298">            if (name &amp;&amp; name.charAt(0) === '.') {
</a><a name="line-299" data-line="299">                //If have a base name, try to normalize against it,
</a><a name="line-300" data-line="300">                //otherwise, assume it is a top-level require that will
</a><a name="line-301" data-line="301">                //be relative to baseUrl in the end.
</a><a name="line-302" data-line="302">                if (baseName) {
</a><a name="line-303" data-line="303">                    if (config.pkgs[baseName]) {
</a><a name="line-304" data-line="304">                        //If the baseName is a package name, then just treat it as one
</a><a name="line-305" data-line="305">                        //name to concat the name with.
</a><a name="line-306" data-line="306">                        normalizedBaseParts = baseParts = [baseName];
</a><a name="line-307" data-line="307">                    } else {
</a><a name="line-308" data-line="308">                        //Convert baseName to array, and lop off the last part,
</a><a name="line-309" data-line="309">                        //so that . matches that 'directory' and not name of the baseName's
</a><a name="line-310" data-line="310">                        //module. For instance, baseName of 'one/two/three', maps to
</a><a name="line-311" data-line="311">                        //'one/two/three.js', but we want the directory, 'one/two' for
</a><a name="line-312" data-line="312">                        //this normalization.
</a><a name="line-313" data-line="313">                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
</a><a name="line-314" data-line="314">                    }
</a><a name="line-315" data-line="315">
</a><a name="line-316" data-line="316">                    name = normalizedBaseParts.concat(name.split('/'));
</a><a name="line-317" data-line="317">                    trimDots(name);
</a><a name="line-318" data-line="318">
</a><a name="line-319" data-line="319">                    //Some use of packages may use a . path to reference the
</a><a name="line-320" data-line="320">                    //'main' module name, so normalize for that.
</a><a name="line-321" data-line="321">                    pkgConfig = config.pkgs[(pkgName = name[0])];
</a><a name="line-322" data-line="322">                    name = name.join('/');
</a><a name="line-323" data-line="323">                    if (pkgConfig &amp;&amp; name === pkgName + '/' + pkgConfig.main) {
</a><a name="line-324" data-line="324">                        name = pkgName;
</a><a name="line-325" data-line="325">                    }
</a><a name="line-326" data-line="326">                } else if (name.indexOf('./') === 0) {
</a><a name="line-327" data-line="327">                    // No baseName, so this is ID is resolved relative
</a><a name="line-328" data-line="328">                    // to baseUrl, pull off the leading dot.
</a><a name="line-329" data-line="329">                    name = name.substring(2);
</a><a name="line-330" data-line="330">                }
</a><a name="line-331" data-line="331">            }
</a><a name="line-332" data-line="332">
</a><a name="line-333" data-line="333">            //Apply map config if available.
</a><a name="line-334" data-line="334">            if (applyMap &amp;&amp; (baseParts || starMap) &amp;&amp; map) {
</a><a name="line-335" data-line="335">                nameParts = name.split('/');
</a><a name="line-336" data-line="336">
</a><a name="line-337" data-line="337">                for (i = nameParts.length; i &gt; 0; i -= 1) {
</a><a name="line-338" data-line="338">                    nameSegment = nameParts.slice(0, i).join('/');
</a><a name="line-339" data-line="339">
</a><a name="line-340" data-line="340">                    if (baseParts) {
</a><a name="line-341" data-line="341">                        //Find the longest baseName segment match in the config.
</a><a name="line-342" data-line="342">                        //So, do joins on the biggest to smallest lengths of baseParts.
</a><a name="line-343" data-line="343">                        for (j = baseParts.length; j &gt; 0; j -= 1) {
</a><a name="line-344" data-line="344">                            mapValue = map[baseParts.slice(0, j).join('/')];
</a><a name="line-345" data-line="345">
</a><a name="line-346" data-line="346">                            //baseName segment has  config, find if it has one for
</a><a name="line-347" data-line="347">                            //this name.
</a><a name="line-348" data-line="348">                            if (mapValue) {
</a><a name="line-349" data-line="349">                                mapValue = mapValue[nameSegment];
</a><a name="line-350" data-line="350">                                if (mapValue) {
</a><a name="line-351" data-line="351">                                    //Match, update name to the new value.
</a><a name="line-352" data-line="352">                                    foundMap = mapValue;
</a><a name="line-353" data-line="353">                                    break;
</a><a name="line-354" data-line="354">                                }
</a><a name="line-355" data-line="355">                            }
</a><a name="line-356" data-line="356">                        }
</a><a name="line-357" data-line="357">                    }
</a><a name="line-358" data-line="358">
</a><a name="line-359" data-line="359">                    if (!foundMap &amp;&amp; starMap &amp;&amp; starMap[nameSegment]) {
</a><a name="line-360" data-line="360">                        foundMap = starMap[nameSegment];
</a><a name="line-361" data-line="361">                    }
</a><a name="line-362" data-line="362">
</a><a name="line-363" data-line="363">                    if (foundMap) {
</a><a name="line-364" data-line="364">                        nameParts.splice(0, i, foundMap);
</a><a name="line-365" data-line="365">                        name = nameParts.join('/');
</a><a name="line-366" data-line="366">                        break;
</a><a name="line-367" data-line="367">                    }
</a><a name="line-368" data-line="368">                }
</a><a name="line-369" data-line="369">            }
</a><a name="line-370" data-line="370">
</a><a name="line-371" data-line="371">            return name;
</a><a name="line-372" data-line="372">        }
</a><a name="line-373" data-line="373">
</a><a name="line-374" data-line="374">        function removeScript(name) {
</a><a name="line-375" data-line="375">            if (isBrowser) {
</a><a name="line-376" data-line="376">                each(scripts(), function (scriptNode) {
</a><a name="line-377" data-line="377">                    if (scriptNode.getAttribute('data-requiremodule') === name &amp;&amp;
</a><a name="line-378" data-line="378">                        scriptNode.getAttribute('data-requirecontext') === context.contextName) {
</a><a name="line-379" data-line="379">                        scriptNode.parentNode.removeChild(scriptNode);
</a><a name="line-380" data-line="380">                        return true;
</a><a name="line-381" data-line="381">                    }
</a><a name="line-382" data-line="382">                });
</a><a name="line-383" data-line="383">            }
</a><a name="line-384" data-line="384">        }
</a><a name="line-385" data-line="385">
</a><a name="line-386" data-line="386">        function hasPathFallback(id) {
</a><a name="line-387" data-line="387">            var pathConfig = config.paths[id];
</a><a name="line-388" data-line="388">            if (pathConfig &amp;&amp; isArray(pathConfig) &amp;&amp; pathConfig.length &gt; 1) {
</a><a name="line-389" data-line="389">                removeScript(id);
</a><a name="line-390" data-line="390">                //Pop off the first array value, since it failed, and
</a><a name="line-391" data-line="391">                //retry
</a><a name="line-392" data-line="392">                pathConfig.shift();
</a><a name="line-393" data-line="393">                context.undef(id);
</a><a name="line-394" data-line="394">                context.require([id]);
</a><a name="line-395" data-line="395">                return true;
</a><a name="line-396" data-line="396">            }
</a><a name="line-397" data-line="397">        }
</a><a name="line-398" data-line="398">
</a><a name="line-399" data-line="399">        /**
</a><a name="line-400" data-line="400">         * Creates a module mapping that includes plugin prefix, module
</a><a name="line-401" data-line="401">         * name, and path. If parentModuleMap is provided it will
</a><a name="line-402" data-line="402">         * also normalize the name via require.normalize()
</a><a name="line-403" data-line="403">         *
</a><a name="line-404" data-line="404">         * @param {String} name the module name
</a><a name="line-405" data-line="405">         * @param {String} [parentModuleMap] parent module map
</a><a name="line-406" data-line="406">         * for the module name, used to resolve relative names.
</a><a name="line-407" data-line="407">         * @param {Boolean} isNormalized: is the ID already normalized.
</a><a name="line-408" data-line="408">         * This is true if this call is done for a define() module ID.
</a><a name="line-409" data-line="409">         * @param {Boolean} applyMap: apply the map config to the ID.
</a><a name="line-410" data-line="410">         * Should only be true if this map is for a dependency.
</a><a name="line-411" data-line="411">         *
</a><a name="line-412" data-line="412">         * @returns {Object}
</a><a name="line-413" data-line="413">         */
</a><a name="line-414" data-line="414">        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
</a><a name="line-415" data-line="415">            var index = name ? name.indexOf('!') : -1,
</a><a name="line-416" data-line="416">                prefix = null,
</a><a name="line-417" data-line="417">                parentName = parentModuleMap ? parentModuleMap.name : null,
</a><a name="line-418" data-line="418">                originalName = name,
</a><a name="line-419" data-line="419">                isDefine = true,
</a><a name="line-420" data-line="420">                normalizedName = '',
</a><a name="line-421" data-line="421">                url, pluginModule, suffix;
</a><a name="line-422" data-line="422">
</a><a name="line-423" data-line="423">            //If no name, then it means it is a require call, generate an
</a><a name="line-424" data-line="424">            //internal name.
</a><a name="line-425" data-line="425">            if (!name) {
</a><a name="line-426" data-line="426">                isDefine = false;
</a><a name="line-427" data-line="427">                name = '_@r' + (requireCounter += 1);
</a><a name="line-428" data-line="428">            }
</a><a name="line-429" data-line="429">
</a><a name="line-430" data-line="430">            if (index !== -1) {
</a><a name="line-431" data-line="431">                prefix = name.substring(0, index);
</a><a name="line-432" data-line="432">                name = name.substring(index + 1, name.length);
</a><a name="line-433" data-line="433">            }
</a><a name="line-434" data-line="434">
</a><a name="line-435" data-line="435">            if (prefix) {
</a><a name="line-436" data-line="436">                prefix = normalize(prefix, parentName, applyMap);
</a><a name="line-437" data-line="437">                pluginModule = defined[prefix];
</a><a name="line-438" data-line="438">            }
</a><a name="line-439" data-line="439">
</a><a name="line-440" data-line="440">            //Account for relative paths if there is a base name.
</a><a name="line-441" data-line="441">            if (name) {
</a><a name="line-442" data-line="442">                if (prefix) {
</a><a name="line-443" data-line="443">                    if (pluginModule &amp;&amp; pluginModule.normalize) {
</a><a name="line-444" data-line="444">                        //Plugin is loaded, use its normalize method.
</a><a name="line-445" data-line="445">                        normalizedName = pluginModule.normalize(name, function (name) {
</a><a name="line-446" data-line="446">                            return normalize(name, parentName, applyMap);
</a><a name="line-447" data-line="447">                        });
</a><a name="line-448" data-line="448">                    } else {
</a><a name="line-449" data-line="449">                        normalizedName = normalize(name, parentName, applyMap);
</a><a name="line-450" data-line="450">                    }
</a><a name="line-451" data-line="451">                } else {
</a><a name="line-452" data-line="452">                    //A regular module.
</a><a name="line-453" data-line="453">                    normalizedName = normalize(name, parentName, applyMap);
</a><a name="line-454" data-line="454">                    url = context.nameToUrl(normalizedName);
</a><a name="line-455" data-line="455">                }
</a><a name="line-456" data-line="456">            }
</a><a name="line-457" data-line="457">
</a><a name="line-458" data-line="458">            //If the id is a plugin id that cannot be determined if it needs
</a><a name="line-459" data-line="459">            //normalization, stamp it with a unique ID so two matching relative
</a><a name="line-460" data-line="460">            //ids that may conflict can be separate.
</a><a name="line-461" data-line="461">            suffix = prefix &amp;&amp; !pluginModule &amp;&amp; !isNormalized ?
</a><a name="line-462" data-line="462">                     '_unnormalized' + (unnormalizedCounter += 1) :
</a><a name="line-463" data-line="463">                     '';
</a><a name="line-464" data-line="464">
</a><a name="line-465" data-line="465">            return {
</a><a name="line-466" data-line="466">                prefix: prefix,
</a><a name="line-467" data-line="467">                name: normalizedName,
</a><a name="line-468" data-line="468">                parentMap: parentModuleMap,
</a><a name="line-469" data-line="469">                unnormalized: !!suffix,
</a><a name="line-470" data-line="470">                url: url,
</a><a name="line-471" data-line="471">                originalName: originalName,
</a><a name="line-472" data-line="472">                isDefine: isDefine,
</a><a name="line-473" data-line="473">                id: (prefix ?
</a><a name="line-474" data-line="474">                    prefix + '!' + normalizedName :
</a><a name="line-475" data-line="475">                    normalizedName) + suffix
</a><a name="line-476" data-line="476">            };
</a><a name="line-477" data-line="477">        }
</a><a name="line-478" data-line="478">
</a><a name="line-479" data-line="479">        function getModule(depMap) {
</a><a name="line-480" data-line="480">            var id = depMap.id,
</a><a name="line-481" data-line="481">                mod = registry[id];
</a><a name="line-482" data-line="482">
</a><a name="line-483" data-line="483">            if (!mod) {
</a><a name="line-484" data-line="484">                mod = registry[id] = new context.Module(depMap);
</a><a name="line-485" data-line="485">            }
</a><a name="line-486" data-line="486">
</a><a name="line-487" data-line="487">            return mod;
</a><a name="line-488" data-line="488">        }
</a><a name="line-489" data-line="489">
</a><a name="line-490" data-line="490">        function on(depMap, name, fn) {
</a><a name="line-491" data-line="491">            var id = depMap.id,
</a><a name="line-492" data-line="492">                mod = registry[id];
</a><a name="line-493" data-line="493">
</a><a name="line-494" data-line="494">            if (hasProp(defined, id) &amp;&amp;
</a><a name="line-495" data-line="495">                (!mod || mod.defineEmitComplete)) {
</a><a name="line-496" data-line="496">                if (name === 'defined') {
</a><a name="line-497" data-line="497">                    fn(defined[id]);
</a><a name="line-498" data-line="498">                }
</a><a name="line-499" data-line="499">            } else {
</a><a name="line-500" data-line="500">                getModule(depMap).on(name, fn);
</a><a name="line-501" data-line="501">            }
</a><a name="line-502" data-line="502">        }
</a><a name="line-503" data-line="503">
</a><a name="line-504" data-line="504">        function onError(err, errback) {
</a><a name="line-505" data-line="505">            var ids = err.requireModules,
</a><a name="line-506" data-line="506">                notified = false;
</a><a name="line-507" data-line="507">
</a><a name="line-508" data-line="508">            if (errback) {
</a><a name="line-509" data-line="509">                errback(err);
</a><a name="line-510" data-line="510">            } else {
</a><a name="line-511" data-line="511">                each(ids, function (id) {
</a><a name="line-512" data-line="512">                    var mod = registry[id];
</a><a name="line-513" data-line="513">                    if (mod) {
</a><a name="line-514" data-line="514">                        //Set error on module, so it skips timeout checks.
</a><a name="line-515" data-line="515">                        mod.error = err;
</a><a name="line-516" data-line="516">                        if (mod.events.error) {
</a><a name="line-517" data-line="517">                            notified = true;
</a><a name="line-518" data-line="518">                            mod.emit('error', err);
</a><a name="line-519" data-line="519">                        }
</a><a name="line-520" data-line="520">                    }
</a><a name="line-521" data-line="521">                });
</a><a name="line-522" data-line="522">
</a><a name="line-523" data-line="523">                if (!notified) {
</a><a name="line-524" data-line="524">                    req.onError(err);
</a><a name="line-525" data-line="525">                }
</a><a name="line-526" data-line="526">            }
</a><a name="line-527" data-line="527">        }
</a><a name="line-528" data-line="528">
</a><a name="line-529" data-line="529">        /**
</a><a name="line-530" data-line="530">         * Internal method to transfer globalQueue items to this context's
</a><a name="line-531" data-line="531">         * defQueue.
</a><a name="line-532" data-line="532">         */
</a><a name="line-533" data-line="533">        function takeGlobalQueue() {
</a><a name="line-534" data-line="534">            //Push all the globalDefQueue items into the context's defQueue
</a><a name="line-535" data-line="535">            if (globalDefQueue.length) {
</a><a name="line-536" data-line="536">                //Array splice in the values since the context code has a
</a><a name="line-537" data-line="537">                //local var ref to defQueue, so cannot just reassign the one
</a><a name="line-538" data-line="538">                //on context.
</a><a name="line-539" data-line="539">                apsp.apply(defQueue,
</a><a name="line-540" data-line="540">                           [defQueue.length - 1, 0].concat(globalDefQueue));
</a><a name="line-541" data-line="541">                globalDefQueue = [];
</a><a name="line-542" data-line="542">            }
</a><a name="line-543" data-line="543">        }
</a><a name="line-544" data-line="544">
</a><a name="line-545" data-line="545">        /**
</a><a name="line-546" data-line="546">         * Helper function that creates a require function object to give to
</a><a name="line-547" data-line="547">         * modules that ask for it as a dependency. It needs to be specific
</a><a name="line-548" data-line="548">         * per module because of the implication of path mappings that may
</a><a name="line-549" data-line="549">         * need to be relative to the module name.
</a><a name="line-550" data-line="550">         */
</a><a name="line-551" data-line="551">        function makeRequire(mod, enableBuildCallback, altRequire) {
</a><a name="line-552" data-line="552">            var relMap = mod &amp;&amp; mod.map,
</a><a name="line-553" data-line="553">                modRequire = makeContextModuleFunc(altRequire || context.require,
</a><a name="line-554" data-line="554">                                                   relMap,
</a><a name="line-555" data-line="555">                                                   enableBuildCallback);
</a><a name="line-556" data-line="556">
</a><a name="line-557" data-line="557">            addRequireMethods(modRequire, context, relMap);
</a><a name="line-558" data-line="558">            modRequire.isBrowser = isBrowser;
</a><a name="line-559" data-line="559">
</a><a name="line-560" data-line="560">            return modRequire;
</a><a name="line-561" data-line="561">        }
</a><a name="line-562" data-line="562">
</a><a name="line-563" data-line="563">        handlers = {
</a><a name="line-564" data-line="564">            'require': function (mod) {
</a><a name="line-565" data-line="565">                return makeRequire(mod);
</a><a name="line-566" data-line="566">            },
</a><a name="line-567" data-line="567">            'exports': function (mod) {
</a><a name="line-568" data-line="568">                mod.usingExports = true;
</a><a name="line-569" data-line="569">                if (mod.map.isDefine) {
</a><a name="line-570" data-line="570">                    return (mod.exports = defined[mod.map.id] = {});
</a><a name="line-571" data-line="571">                }
</a><a name="line-572" data-line="572">            },
</a><a name="line-573" data-line="573">            'module': function (mod) {
</a><a name="line-574" data-line="574">                return (mod.module = {
</a><a name="line-575" data-line="575">                    id: mod.map.id,
</a><a name="line-576" data-line="576">                    uri: mod.map.url,
</a><a name="line-577" data-line="577">                    config: function () {
</a><a name="line-578" data-line="578">                        return (config.config &amp;&amp; config.config[mod.map.id]) || {};
</a><a name="line-579" data-line="579">                    },
</a><a name="line-580" data-line="580">                    exports: defined[mod.map.id]
</a><a name="line-581" data-line="581">                });
</a><a name="line-582" data-line="582">            }
</a><a name="line-583" data-line="583">        };
</a><a name="line-584" data-line="584">
</a><a name="line-585" data-line="585">        function removeWaiting(id) {
</a><a name="line-586" data-line="586">            //Clean up machinery used for waiting modules.
</a><a name="line-587" data-line="587">            delete registry[id];
</a><a name="line-588" data-line="588">
</a><a name="line-589" data-line="589">            each(waitAry, function (mod, i) {
</a><a name="line-590" data-line="590">                if (mod.map.id === id) {
</a><a name="line-591" data-line="591">                    waitAry.splice(i, 1);
</a><a name="line-592" data-line="592">                    if (!mod.defined) {
</a><a name="line-593" data-line="593">                        context.waitCount -= 1;
</a><a name="line-594" data-line="594">                    }
</a><a name="line-595" data-line="595">                    return true;
</a><a name="line-596" data-line="596">                }
</a><a name="line-597" data-line="597">            });
</a><a name="line-598" data-line="598">        }
</a><a name="line-599" data-line="599">
</a><a name="line-600" data-line="600">        function findCycle(mod, traced) {
</a><a name="line-601" data-line="601">            var id = mod.map.id,
</a><a name="line-602" data-line="602">                depArray = mod.depMaps,
</a><a name="line-603" data-line="603">                foundModule;
</a><a name="line-604" data-line="604">
</a><a name="line-605" data-line="605">            //Do not bother with unitialized modules or not yet enabled
</a><a name="line-606" data-line="606">            //modules.
</a><a name="line-607" data-line="607">            if (!mod.inited) {
</a><a name="line-608" data-line="608">                return;
</a><a name="line-609" data-line="609">            }
</a><a name="line-610" data-line="610">
</a><a name="line-611" data-line="611">            //Found the cycle.
</a><a name="line-612" data-line="612">            if (traced[id]) {
</a><a name="line-613" data-line="613">                return mod;
</a><a name="line-614" data-line="614">            }
</a><a name="line-615" data-line="615">
</a><a name="line-616" data-line="616">            traced[id] = true;
</a><a name="line-617" data-line="617">
</a><a name="line-618" data-line="618">            //Trace through the dependencies.
</a><a name="line-619" data-line="619">            each(depArray, function (depMap) {
</a><a name="line-620" data-line="620">                var depId = depMap.id,
</a><a name="line-621" data-line="621">                    depMod = registry[depId];
</a><a name="line-622" data-line="622">
</a><a name="line-623" data-line="623">                if (!depMod) {
</a><a name="line-624" data-line="624">                    return;
</a><a name="line-625" data-line="625">                }
</a><a name="line-626" data-line="626">
</a><a name="line-627" data-line="627">                if (!depMod.inited || !depMod.enabled) {
</a><a name="line-628" data-line="628">                    //Dependency is not inited, so this cannot
</a><a name="line-629" data-line="629">                    //be used to determine a cycle.
</a><a name="line-630" data-line="630">                    foundModule = null;
</a><a name="line-631" data-line="631">                    delete traced[id];
</a><a name="line-632" data-line="632">                    return true;
</a><a name="line-633" data-line="633">                }
</a><a name="line-634" data-line="634">
</a><a name="line-635" data-line="635">                //mixin traced to a new object for each dependency, so that
</a><a name="line-636" data-line="636">                //sibling dependencies in this object to not generate a
</a><a name="line-637" data-line="637">                //false positive match on a cycle. Ideally an Object.create
</a><a name="line-638" data-line="638">                //type of prototype delegation would be used here, but
</a><a name="line-639" data-line="639">                //optimizing for file size vs. execution speed since hopefully
</a><a name="line-640" data-line="640">                //the trees are small for circular dependency scans relative
</a><a name="line-641" data-line="641">                //to the full app perf.
</a><a name="line-642" data-line="642">                return (foundModule = findCycle(depMod, mixin({}, traced)));
</a><a name="line-643" data-line="643">            });
</a><a name="line-644" data-line="644">
</a><a name="line-645" data-line="645">            return foundModule;
</a><a name="line-646" data-line="646">        }
</a><a name="line-647" data-line="647">
</a><a name="line-648" data-line="648">        function forceExec(mod, traced, uninited) {
</a><a name="line-649" data-line="649">            var id = mod.map.id,
</a><a name="line-650" data-line="650">                depArray = mod.depMaps;
</a><a name="line-651" data-line="651">
</a><a name="line-652" data-line="652">            if (!mod.inited || !mod.map.isDefine) {
</a><a name="line-653" data-line="653">                return;
</a><a name="line-654" data-line="654">            }
</a><a name="line-655" data-line="655">
</a><a name="line-656" data-line="656">            if (traced[id]) {
</a><a name="line-657" data-line="657">                return defined[id];
</a><a name="line-658" data-line="658">            }
</a><a name="line-659" data-line="659">
</a><a name="line-660" data-line="660">            traced[id] = mod;
</a><a name="line-661" data-line="661">
</a><a name="line-662" data-line="662">            each(depArray, function(depMap) {
</a><a name="line-663" data-line="663">                var depId = depMap.id,
</a><a name="line-664" data-line="664">                    depMod = registry[depId],
</a><a name="line-665" data-line="665">                    value;
</a><a name="line-666" data-line="666">
</a><a name="line-667" data-line="667">                if (handlers[depId]) {
</a><a name="line-668" data-line="668">                    return;
</a><a name="line-669" data-line="669">                }
</a><a name="line-670" data-line="670">
</a><a name="line-671" data-line="671">                if (depMod) {
</a><a name="line-672" data-line="672">                    if (!depMod.inited || !depMod.enabled) {
</a><a name="line-673" data-line="673">                        //Dependency is not inited,
</a><a name="line-674" data-line="674">                        //so this module cannot be
</a><a name="line-675" data-line="675">                        //given a forced value yet.
</a><a name="line-676" data-line="676">                        uninited[id] = true;
</a><a name="line-677" data-line="677">                        return;
</a><a name="line-678" data-line="678">                    }
</a><a name="line-679" data-line="679">
</a><a name="line-680" data-line="680">                    //Get the value for the current dependency
</a><a name="line-681" data-line="681">                    value = forceExec(depMod, traced, uninited);
</a><a name="line-682" data-line="682">
</a><a name="line-683" data-line="683">                    //Even with forcing it may not be done,
</a><a name="line-684" data-line="684">                    //in particular if the module is waiting
</a><a name="line-685" data-line="685">                    //on a plugin resource.
</a><a name="line-686" data-line="686">                    if (!uninited[depId]) {
</a><a name="line-687" data-line="687">                        mod.defineDepById(depId, value);
</a><a name="line-688" data-line="688">                    }
</a><a name="line-689" data-line="689">                }
</a><a name="line-690" data-line="690">            });
</a><a name="line-691" data-line="691">
</a><a name="line-692" data-line="692">            mod.check(true);
</a><a name="line-693" data-line="693">
</a><a name="line-694" data-line="694">            return defined[id];
</a><a name="line-695" data-line="695">        }
</a><a name="line-696" data-line="696">
</a><a name="line-697" data-line="697">        function modCheck(mod) {
</a><a name="line-698" data-line="698">            mod.check();
</a><a name="line-699" data-line="699">        }
</a><a name="line-700" data-line="700">
</a><a name="line-701" data-line="701">        function checkLoaded() {
</a><a name="line-702" data-line="702">            var waitInterval = config.waitSeconds * 1000,
</a><a name="line-703" data-line="703">                //It is possible to disable the wait interval by using waitSeconds of 0.
</a><a name="line-704" data-line="704">                expired = waitInterval &amp;&amp; (context.startTime + waitInterval) &lt; new Date().getTime(),
</a><a name="line-705" data-line="705">                noLoads = [],
</a><a name="line-706" data-line="706">                stillLoading = false,
</a><a name="line-707" data-line="707">                needCycleCheck = true,
</a><a name="line-708" data-line="708">                map, modId, err, usingPathFallback;
</a><a name="line-709" data-line="709">
</a><a name="line-710" data-line="710">            //Do not bother if this call was a result of a cycle break.
</a><a name="line-711" data-line="711">            if (inCheckLoaded) {
</a><a name="line-712" data-line="712">                return;
</a><a name="line-713" data-line="713">            }
</a><a name="line-714" data-line="714">
</a><a name="line-715" data-line="715">            inCheckLoaded = true;
</a><a name="line-716" data-line="716">
</a><a name="line-717" data-line="717">            //Figure out the state of all the modules.
</a><a name="line-718" data-line="718">            eachProp(registry, function (mod) {
</a><a name="line-719" data-line="719">                map = mod.map;
</a><a name="line-720" data-line="720">                modId = map.id;
</a><a name="line-721" data-line="721">
</a><a name="line-722" data-line="722">                //Skip things that are not enabled or in error state.
</a><a name="line-723" data-line="723">                if (!mod.enabled) {
</a><a name="line-724" data-line="724">                    return;
</a><a name="line-725" data-line="725">                }
</a><a name="line-726" data-line="726">
</a><a name="line-727" data-line="727">                if (!mod.error) {
</a><a name="line-728" data-line="728">                    //If the module should be executed, and it has not
</a><a name="line-729" data-line="729">                    //been inited and time is up, remember it.
</a><a name="line-730" data-line="730">                    if (!mod.inited &amp;&amp; expired) {
</a><a name="line-731" data-line="731">                        if (hasPathFallback(modId)) {
</a><a name="line-732" data-line="732">                            usingPathFallback = true;
</a><a name="line-733" data-line="733">                            stillLoading = true;
</a><a name="line-734" data-line="734">                        } else {
</a><a name="line-735" data-line="735">                            noLoads.push(modId);
</a><a name="line-736" data-line="736">                            removeScript(modId);
</a><a name="line-737" data-line="737">                        }
</a><a name="line-738" data-line="738">                    } else if (!mod.inited &amp;&amp; mod.fetched &amp;&amp; map.isDefine) {
</a><a name="line-739" data-line="739">                        stillLoading = true;
</a><a name="line-740" data-line="740">                        if (!map.prefix) {
</a><a name="line-741" data-line="741">                            //No reason to keep looking for unfinished
</a><a name="line-742" data-line="742">                            //loading. If the only stillLoading is a
</a><a name="line-743" data-line="743">                            //plugin resource though, keep going,
</a><a name="line-744" data-line="744">                            //because it may be that a plugin resource
</a><a name="line-745" data-line="745">                            //is waiting on a non-plugin cycle.
</a><a name="line-746" data-line="746">                            return (needCycleCheck = false);
</a><a name="line-747" data-line="747">                        }
</a><a name="line-748" data-line="748">                    }
</a><a name="line-749" data-line="749">                }
</a><a name="line-750" data-line="750">            });
</a><a name="line-751" data-line="751">
</a><a name="line-752" data-line="752">            if (expired &amp;&amp; noLoads.length) {
</a><a name="line-753" data-line="753">                //If wait time expired, throw error of unloaded modules.
</a><a name="line-754" data-line="754">                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
</a><a name="line-755" data-line="755">                err.contextName = context.contextName;
</a><a name="line-756" data-line="756">                return onError(err);
</a><a name="line-757" data-line="757">            }
</a><a name="line-758" data-line="758">
</a><a name="line-759" data-line="759">            //Not expired, check for a cycle.
</a><a name="line-760" data-line="760">            if (needCycleCheck) {
</a><a name="line-761" data-line="761">
</a><a name="line-762" data-line="762">                each(waitAry, function (mod) {
</a><a name="line-763" data-line="763">                    if (mod.defined) {
</a><a name="line-764" data-line="764">                        return;
</a><a name="line-765" data-line="765">                    }
</a><a name="line-766" data-line="766">
</a><a name="line-767" data-line="767">                    var cycleMod = findCycle(mod, {}),
</a><a name="line-768" data-line="768">                        traced = {};
</a><a name="line-769" data-line="769">
</a><a name="line-770" data-line="770">                    if (cycleMod) {
</a><a name="line-771" data-line="771">                        forceExec(cycleMod, traced, {});
</a><a name="line-772" data-line="772">
</a><a name="line-773" data-line="773">                        //traced modules may have been
</a><a name="line-774" data-line="774">                        //removed from the registry, but
</a><a name="line-775" data-line="775">                        //their listeners still need to
</a><a name="line-776" data-line="776">                        //be called.
</a><a name="line-777" data-line="777">                        eachProp(traced, modCheck);
</a><a name="line-778" data-line="778">                    }
</a><a name="line-779" data-line="779">                });
</a><a name="line-780" data-line="780">
</a><a name="line-781" data-line="781">                //Now that dependencies have
</a><a name="line-782" data-line="782">                //been satisfied, trigger the
</a><a name="line-783" data-line="783">                //completion check that then
</a><a name="line-784" data-line="784">                //notifies listeners.
</a><a name="line-785" data-line="785">                eachProp(registry, modCheck);
</a><a name="line-786" data-line="786">            }
</a><a name="line-787" data-line="787">
</a><a name="line-788" data-line="788">            //If still waiting on loads, and the waiting load is something
</a><a name="line-789" data-line="789">            //other than a plugin resource, or there are still outstanding
</a><a name="line-790" data-line="790">            //scripts, then just try back later.
</a><a name="line-791" data-line="791">            if ((!expired || usingPathFallback) &amp;&amp; stillLoading) {
</a><a name="line-792" data-line="792">                //Something is still waiting to load. Wait for it, but only
</a><a name="line-793" data-line="793">                //if a timeout is not already in effect.
</a><a name="line-794" data-line="794">                if ((isBrowser || isWebWorker) &amp;&amp; !checkLoadedTimeoutId) {
</a><a name="line-795" data-line="795">                    checkLoadedTimeoutId = setTimeout(function () {
</a><a name="line-796" data-line="796">                        checkLoadedTimeoutId = 0;
</a><a name="line-797" data-line="797">                        checkLoaded();
</a><a name="line-798" data-line="798">                    }, 50);
</a><a name="line-799" data-line="799">                }
</a><a name="line-800" data-line="800">            }
</a><a name="line-801" data-line="801">
</a><a name="line-802" data-line="802">            inCheckLoaded = false;
</a><a name="line-803" data-line="803">        }
</a><a name="line-804" data-line="804">
</a><a name="line-805" data-line="805">        Module = function (map) {
</a><a name="line-806" data-line="806">            this.events = undefEvents[map.id] || {};
</a><a name="line-807" data-line="807">            this.map = map;
</a><a name="line-808" data-line="808">            this.shim = config.shim[map.id];
</a><a name="line-809" data-line="809">            this.depExports = [];
</a><a name="line-810" data-line="810">            this.depMaps = [];
</a><a name="line-811" data-line="811">            this.depMatched = [];
</a><a name="line-812" data-line="812">            this.pluginMaps = {};
</a><a name="line-813" data-line="813">            this.depCount = 0;
</a><a name="line-814" data-line="814">
</a><a name="line-815" data-line="815">            /* this.exports this.factory
</a><a name="line-816" data-line="816">               this.depMaps = [],
</a><a name="line-817" data-line="817">               this.enabled, this.fetched
</a><a name="line-818" data-line="818">            */
</a><a name="line-819" data-line="819">        };
</a><a name="line-820" data-line="820">
</a><a name="line-821" data-line="821">        Module.prototype = {
</a><a name="line-822" data-line="822">            init: function(depMaps, factory, errback, options) {
</a><a name="line-823" data-line="823">                options = options || {};
</a><a name="line-824" data-line="824">
</a><a name="line-825" data-line="825">                //Do not do more inits if already done. Can happen if there
</a><a name="line-826" data-line="826">                //are multiple define calls for the same module. That is not
</a><a name="line-827" data-line="827">                //a normal, common case, but it is also not unexpected.
</a><a name="line-828" data-line="828">                if (this.inited) {
</a><a name="line-829" data-line="829">                    return;
</a><a name="line-830" data-line="830">                }
</a><a name="line-831" data-line="831">
</a><a name="line-832" data-line="832">                this.factory = factory;
</a><a name="line-833" data-line="833">
</a><a name="line-834" data-line="834">                if (errback) {
</a><a name="line-835" data-line="835">                    //Register for errors on this module.
</a><a name="line-836" data-line="836">                    this.on('error', errback);
</a><a name="line-837" data-line="837">                } else if (this.events.error) {
</a><a name="line-838" data-line="838">                    //If no errback already, but there are error listeners
</a><a name="line-839" data-line="839">                    //on this module, set up an errback to pass to the deps.
</a><a name="line-840" data-line="840">                    errback = bind(this, function (err) {
</a><a name="line-841" data-line="841">                        this.emit('error', err);
</a><a name="line-842" data-line="842">                    });
</a><a name="line-843" data-line="843">                }
</a><a name="line-844" data-line="844">
</a><a name="line-845" data-line="845">                //Do a copy of the dependency array, so that
</a><a name="line-846" data-line="846">                //source inputs are not modified. For example
</a><a name="line-847" data-line="847">                //&quot;shim&quot; deps are passed in here directly, and
</a><a name="line-848" data-line="848">                //doing a direct modification of the depMaps array
</a><a name="line-849" data-line="849">                //would affect that config.
</a><a name="line-850" data-line="850">                this.depMaps = depMaps &amp;&amp; depMaps.slice(0);
</a><a name="line-851" data-line="851">                this.depMaps.rjsSkipMap = depMaps.rjsSkipMap;
</a><a name="line-852" data-line="852">
</a><a name="line-853" data-line="853">                this.errback = errback;
</a><a name="line-854" data-line="854">
</a><a name="line-855" data-line="855">                //Indicate this module has be initialized
</a><a name="line-856" data-line="856">                this.inited = true;
</a><a name="line-857" data-line="857">
</a><a name="line-858" data-line="858">                this.ignore = options.ignore;
</a><a name="line-859" data-line="859">
</a><a name="line-860" data-line="860">                //Could have option to init this module in enabled mode,
</a><a name="line-861" data-line="861">                //or could have been previously marked as enabled. However,
</a><a name="line-862" data-line="862">                //the dependencies are not known until init is called. So
</a><a name="line-863" data-line="863">                //if enabled previously, now trigger dependencies as enabled.
</a><a name="line-864" data-line="864">                if (options.enabled || this.enabled) {
</a><a name="line-865" data-line="865">                    //Enable this module and dependencies.
</a><a name="line-866" data-line="866">                    //Will call this.check()
</a><a name="line-867" data-line="867">                    this.enable();
</a><a name="line-868" data-line="868">                } else {
</a><a name="line-869" data-line="869">                    this.check();
</a><a name="line-870" data-line="870">                }
</a><a name="line-871" data-line="871">            },
</a><a name="line-872" data-line="872">
</a><a name="line-873" data-line="873">            defineDepById: function (id, depExports) {
</a><a name="line-874" data-line="874">                var i;
</a><a name="line-875" data-line="875">
</a><a name="line-876" data-line="876">                //Find the index for this dependency.
</a><a name="line-877" data-line="877">                each(this.depMaps, function (map, index) {
</a><a name="line-878" data-line="878">                    if (map.id === id) {
</a><a name="line-879" data-line="879">                        i = index;
</a><a name="line-880" data-line="880">                        return true;
</a><a name="line-881" data-line="881">                    }
</a><a name="line-882" data-line="882">                });
</a><a name="line-883" data-line="883">
</a><a name="line-884" data-line="884">                return this.defineDep(i, depExports);
</a><a name="line-885" data-line="885">            },
</a><a name="line-886" data-line="886">
</a><a name="line-887" data-line="887">            defineDep: function (i, depExports) {
</a><a name="line-888" data-line="888">                //Because of cycles, defined callback for a given
</a><a name="line-889" data-line="889">                //export can be called more than once.
</a><a name="line-890" data-line="890">                if (!this.depMatched[i]) {
</a><a name="line-891" data-line="891">                    this.depMatched[i] = true;
</a><a name="line-892" data-line="892">                    this.depCount -= 1;
</a><a name="line-893" data-line="893">                    this.depExports[i] = depExports;
</a><a name="line-894" data-line="894">                }
</a><a name="line-895" data-line="895">            },
</a><a name="line-896" data-line="896">
</a><a name="line-897" data-line="897">            fetch: function () {
</a><a name="line-898" data-line="898">                if (this.fetched) {
</a><a name="line-899" data-line="899">                    return;
</a><a name="line-900" data-line="900">                }
</a><a name="line-901" data-line="901">                this.fetched = true;
</a><a name="line-902" data-line="902">
</a><a name="line-903" data-line="903">                context.startTime = (new Date()).getTime();
</a><a name="line-904" data-line="904">
</a><a name="line-905" data-line="905">                var map = this.map;
</a><a name="line-906" data-line="906">
</a><a name="line-907" data-line="907">                //If the manager is for a plugin managed resource,
</a><a name="line-908" data-line="908">                //ask the plugin to load it now.
</a><a name="line-909" data-line="909">                if (this.shim) {
</a><a name="line-910" data-line="910">                    makeRequire(this, true)(this.shim.deps || [], bind(this, function () {
</a><a name="line-911" data-line="911">                        return map.prefix ? this.callPlugin() : this.load();
</a><a name="line-912" data-line="912">                    }));
</a><a name="line-913" data-line="913">                } else {
</a><a name="line-914" data-line="914">                    //Regular dependency.
</a><a name="line-915" data-line="915">                    return map.prefix ? this.callPlugin() : this.load();
</a><a name="line-916" data-line="916">                }
</a><a name="line-917" data-line="917">            },
</a><a name="line-918" data-line="918">
</a><a name="line-919" data-line="919">            load: function() {
</a><a name="line-920" data-line="920">                var url = this.map.url;
</a><a name="line-921" data-line="921">
</a><a name="line-922" data-line="922">                //Regular dependency.
</a><a name="line-923" data-line="923">                if (!urlFetched[url]) {
</a><a name="line-924" data-line="924">                    urlFetched[url] = true;
</a><a name="line-925" data-line="925">                    context.load(this.map.id, url);
</a><a name="line-926" data-line="926">                }
</a><a name="line-927" data-line="927">            },
</a><a name="line-928" data-line="928">
</a><a name="line-929" data-line="929">            /**
</a><a name="line-930" data-line="930">             * Checks is the module is ready to define itself, and if so,
</a><a name="line-931" data-line="931">             * define it. If the silent argument is true, then it will just
</a><a name="line-932" data-line="932">             * define, but not notify listeners, and not ask for a context-wide
</a><a name="line-933" data-line="933">             * check of all loaded modules. That is useful for cycle breaking.
</a><a name="line-934" data-line="934">             */
</a><a name="line-935" data-line="935">            check: function (silent) {
</a><a name="line-936" data-line="936">                if (!this.enabled || this.enabling) {
</a><a name="line-937" data-line="937">                    return;
</a><a name="line-938" data-line="938">                }
</a><a name="line-939" data-line="939">
</a><a name="line-940" data-line="940">                var id = this.map.id,
</a><a name="line-941" data-line="941">                    depExports = this.depExports,
</a><a name="line-942" data-line="942">                    exports = this.exports,
</a><a name="line-943" data-line="943">                    factory = this.factory,
</a><a name="line-944" data-line="944">                    err, cjsModule;
</a><a name="line-945" data-line="945">
</a><a name="line-946" data-line="946">                if (!this.inited) {
</a><a name="line-947" data-line="947">                    this.fetch();
</a><a name="line-948" data-line="948">                } else if (this.error) {
</a><a name="line-949" data-line="949">                    this.emit('error', this.error);
</a><a name="line-950" data-line="950">                } else if (!this.defining) {
</a><a name="line-951" data-line="951">                    //The factory could trigger another require call
</a><a name="line-952" data-line="952">                    //that would result in checking this module to
</a><a name="line-953" data-line="953">                    //define itself again. If already in the process
</a><a name="line-954" data-line="954">                    //of doing that, skip this work.
</a><a name="line-955" data-line="955">                    this.defining = true;
</a><a name="line-956" data-line="956">
</a><a name="line-957" data-line="957">                    if (this.depCount &lt; 1 &amp;&amp; !this.defined) {
</a><a name="line-958" data-line="958">                        if (isFunction(factory)) {
</a><a name="line-959" data-line="959">                            //If there is an error listener, favor passing
</a><a name="line-960" data-line="960">                            //to that instead of throwing an error.
</a><a name="line-961" data-line="961">                            if (this.events.error) {
</a><a name="line-962" data-line="962">                                try {
</a><a name="line-963" data-line="963">                                    exports = context.execCb(id, factory, depExports, exports);
</a><a name="line-964" data-line="964">                                } catch (e) {
</a><a name="line-965" data-line="965">                                    err = e;
</a><a name="line-966" data-line="966">                                }
</a><a name="line-967" data-line="967">                            } else {
</a><a name="line-968" data-line="968">                                exports = context.execCb(id, factory, depExports, exports);
</a><a name="line-969" data-line="969">                            }
</a><a name="line-970" data-line="970">
</a><a name="line-971" data-line="971">                            if (this.map.isDefine) {
</a><a name="line-972" data-line="972">                                //If setting exports via 'module' is in play,
</a><a name="line-973" data-line="973">                                //favor that over return value and exports. After that,
</a><a name="line-974" data-line="974">                                //favor a non-undefined return value over exports use.
</a><a name="line-975" data-line="975">                                cjsModule = this.module;
</a><a name="line-976" data-line="976">                                if (cjsModule &amp;&amp;
</a><a name="line-977" data-line="977">                                    cjsModule.exports !== undefined &amp;&amp;
</a><a name="line-978" data-line="978">                                    //Make sure it is not already the exports value
</a><a name="line-979" data-line="979">                                    cjsModule.exports !== this.exports) {
</a><a name="line-980" data-line="980">                                    exports = cjsModule.exports;
</a><a name="line-981" data-line="981">                                } else if (exports === undefined &amp;&amp; this.usingExports) {
</a><a name="line-982" data-line="982">                                    //exports already set the defined value.
</a><a name="line-983" data-line="983">                                    exports = this.exports;
</a><a name="line-984" data-line="984">                                }
</a><a name="line-985" data-line="985">                            }
</a><a name="line-986" data-line="986">
</a><a name="line-987" data-line="987">                            if (err) {
</a><a name="line-988" data-line="988">                                err.requireMap = this.map;
</a><a name="line-989" data-line="989">                                err.requireModules = [this.map.id];
</a><a name="line-990" data-line="990">                                err.requireType = 'define';
</a><a name="line-991" data-line="991">                                return onError((this.error = err));
</a><a name="line-992" data-line="992">                            }
</a><a name="line-993" data-line="993">
</a><a name="line-994" data-line="994">                        } else {
</a><a name="line-995" data-line="995">                            //Just a literal value
</a><a name="line-996" data-line="996">                            exports = factory;
</a><a name="line-997" data-line="997">                        }
</a><a name="line-998" data-line="998">
</a><a name="line-999" data-line="999">                        this.exports = exports;
</a><a name="line-1000" data-line="1000">
</a><a name="line-1001" data-line="1001">                        if (this.map.isDefine &amp;&amp; !this.ignore) {
</a><a name="line-1002" data-line="1002">                            defined[id] = exports;
</a><a name="line-1003" data-line="1003">
</a><a name="line-1004" data-line="1004">                            if (req.onResourceLoad) {
</a><a name="line-1005" data-line="1005">                                req.onResourceLoad(context, this.map, this.depMaps);
</a><a name="line-1006" data-line="1006">                            }
</a><a name="line-1007" data-line="1007">                        }
</a><a name="line-1008" data-line="1008">
</a><a name="line-1009" data-line="1009">                        //Clean up
</a><a name="line-1010" data-line="1010">                        delete registry[id];
</a><a name="line-1011" data-line="1011">
</a><a name="line-1012" data-line="1012">                        this.defined = true;
</a><a name="line-1013" data-line="1013">                        context.waitCount -= 1;
</a><a name="line-1014" data-line="1014">                        if (context.waitCount === 0) {
</a><a name="line-1015" data-line="1015">                            //Clear the wait array used for cycles.
</a><a name="line-1016" data-line="1016">                            waitAry = [];
</a><a name="line-1017" data-line="1017">                        }
</a><a name="line-1018" data-line="1018">                    }
</a><a name="line-1019" data-line="1019">
</a><a name="line-1020" data-line="1020">                    //Finished the define stage. Allow calling check again
</a><a name="line-1021" data-line="1021">                    //to allow define notifications below in the case of a
</a><a name="line-1022" data-line="1022">                    //cycle.
</a><a name="line-1023" data-line="1023">                    this.defining = false;
</a><a name="line-1024" data-line="1024">
</a><a name="line-1025" data-line="1025">                    if (!silent) {
</a><a name="line-1026" data-line="1026">                        if (this.defined &amp;&amp; !this.defineEmitted) {
</a><a name="line-1027" data-line="1027">                            this.defineEmitted = true;
</a><a name="line-1028" data-line="1028">                            this.emit('defined', this.exports);
</a><a name="line-1029" data-line="1029">                            this.defineEmitComplete = true;
</a><a name="line-1030" data-line="1030">                        }
</a><a name="line-1031" data-line="1031">                    }
</a><a name="line-1032" data-line="1032">                }
</a><a name="line-1033" data-line="1033">            },
</a><a name="line-1034" data-line="1034">
</a><a name="line-1035" data-line="1035">            callPlugin: function() {
</a><a name="line-1036" data-line="1036">                var map = this.map,
</a><a name="line-1037" data-line="1037">                    id = map.id,
</a><a name="line-1038" data-line="1038">                    pluginMap = makeModuleMap(map.prefix, null, false, true);
</a><a name="line-1039" data-line="1039">
</a><a name="line-1040" data-line="1040">                on(pluginMap, 'defined', bind(this, function (plugin) {
</a><a name="line-1041" data-line="1041">                    var name = this.map.name,
</a><a name="line-1042" data-line="1042">                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
</a><a name="line-1043" data-line="1043">                        load, normalizedMap, normalizedMod;
</a><a name="line-1044" data-line="1044">
</a><a name="line-1045" data-line="1045">                    //If current map is not normalized, wait for that
</a><a name="line-1046" data-line="1046">                    //normalized name to load instead of continuing.
</a><a name="line-1047" data-line="1047">                    if (this.map.unnormalized) {
</a><a name="line-1048" data-line="1048">                        //Normalize the ID if the plugin allows it.
</a><a name="line-1049" data-line="1049">                        if (plugin.normalize) {
</a><a name="line-1050" data-line="1050">                            name = plugin.normalize(name, function (name) {
</a><a name="line-1051" data-line="1051">                                return normalize(name, parentName, true);
</a><a name="line-1052" data-line="1052">                            }) || '';
</a><a name="line-1053" data-line="1053">                        }
</a><a name="line-1054" data-line="1054">
</a><a name="line-1055" data-line="1055">                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
</a><a name="line-1056" data-line="1056">                                                      this.map.parentMap,
</a><a name="line-1057" data-line="1057">                                                      false,
</a><a name="line-1058" data-line="1058">                                                      true);
</a><a name="line-1059" data-line="1059">                        on(normalizedMap,
</a><a name="line-1060" data-line="1060">                           'defined', bind(this, function (value) {
</a><a name="line-1061" data-line="1061">                            this.init([], function () { return value; }, null, {
</a><a name="line-1062" data-line="1062">                                enabled: true,
</a><a name="line-1063" data-line="1063">                                ignore: true
</a><a name="line-1064" data-line="1064">                            });
</a><a name="line-1065" data-line="1065">                        }));
</a><a name="line-1066" data-line="1066">                        normalizedMod = registry[normalizedMap.id];
</a><a name="line-1067" data-line="1067">                        if (normalizedMod) {
</a><a name="line-1068" data-line="1068">                            if (this.events.error) {
</a><a name="line-1069" data-line="1069">                                normalizedMod.on('error', bind(this, function (err) {
</a><a name="line-1070" data-line="1070">                                    this.emit('error', err);
</a><a name="line-1071" data-line="1071">                                }));
</a><a name="line-1072" data-line="1072">                            }
</a><a name="line-1073" data-line="1073">                            normalizedMod.enable();
</a><a name="line-1074" data-line="1074">                        }
</a><a name="line-1075" data-line="1075">
</a><a name="line-1076" data-line="1076">                        return;
</a><a name="line-1077" data-line="1077">                    }
</a><a name="line-1078" data-line="1078">
</a><a name="line-1079" data-line="1079">                    load = bind(this, function (value) {
</a><a name="line-1080" data-line="1080">                        this.init([], function () { return value; }, null, {
</a><a name="line-1081" data-line="1081">                            enabled: true
</a><a name="line-1082" data-line="1082">                        });
</a><a name="line-1083" data-line="1083">                    });
</a><a name="line-1084" data-line="1084">
</a><a name="line-1085" data-line="1085">                    load.error = bind(this, function (err) {
</a><a name="line-1086" data-line="1086">                        this.inited = true;
</a><a name="line-1087" data-line="1087">                        this.error = err;
</a><a name="line-1088" data-line="1088">                        err.requireModules = [id];
</a><a name="line-1089" data-line="1089">
</a><a name="line-1090" data-line="1090">                        //Remove temp unnormalized modules for this module,
</a><a name="line-1091" data-line="1091">                        //since they will never be resolved otherwise now.
</a><a name="line-1092" data-line="1092">                        eachProp(registry, function (mod) {
</a><a name="line-1093" data-line="1093">                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
</a><a name="line-1094" data-line="1094">                                removeWaiting(mod.map.id);
</a><a name="line-1095" data-line="1095">                            }
</a><a name="line-1096" data-line="1096">                        });
</a><a name="line-1097" data-line="1097">
</a><a name="line-1098" data-line="1098">                        onError(err);
</a><a name="line-1099" data-line="1099">                    });
</a><a name="line-1100" data-line="1100">
</a><a name="line-1101" data-line="1101">                    //Allow plugins to load other code without having to know the
</a><a name="line-1102" data-line="1102">                    //context or how to 'complete' the load.
</a><a name="line-1103" data-line="1103">                    load.fromText = function (moduleName, text) {
</a><a name="line-1104" data-line="1104">                        /*jslint evil: true */
</a><a name="line-1105" data-line="1105">                        var hasInteractive = useInteractive;
</a><a name="line-1106" data-line="1106">
</a><a name="line-1107" data-line="1107">                        //Turn off interactive script matching for IE for any define
</a><a name="line-1108" data-line="1108">                        //calls in the text, then turn it back on at the end.
</a><a name="line-1109" data-line="1109">                        if (hasInteractive) {
</a><a name="line-1110" data-line="1110">                            useInteractive = false;
</a><a name="line-1111" data-line="1111">                        }
</a><a name="line-1112" data-line="1112">
</a><a name="line-1113" data-line="1113">                        //Prime the system by creating a module instance for
</a><a name="line-1114" data-line="1114">                        //it.
</a><a name="line-1115" data-line="1115">                        getModule(makeModuleMap(moduleName));
</a><a name="line-1116" data-line="1116">
</a><a name="line-1117" data-line="1117">                        req.exec(text);
</a><a name="line-1118" data-line="1118">
</a><a name="line-1119" data-line="1119">                        if (hasInteractive) {
</a><a name="line-1120" data-line="1120">                            useInteractive = true;
</a><a name="line-1121" data-line="1121">                        }
</a><a name="line-1122" data-line="1122">
</a><a name="line-1123" data-line="1123">                        //Support anonymous modules.
</a><a name="line-1124" data-line="1124">                        context.completeLoad(moduleName);
</a><a name="line-1125" data-line="1125">                    };
</a><a name="line-1126" data-line="1126">
</a><a name="line-1127" data-line="1127">                    //Use parentName here since the plugin's name is not reliable,
</a><a name="line-1128" data-line="1128">                    //could be some weird string with no path that actually wants to
</a><a name="line-1129" data-line="1129">                    //reference the parentName's path.
</a><a name="line-1130" data-line="1130">                    plugin.load(map.name, makeRequire(map.parentMap, true, function (deps, cb) {
</a><a name="line-1131" data-line="1131">                        deps.rjsSkipMap = true;
</a><a name="line-1132" data-line="1132">                        return context.require(deps, cb);
</a><a name="line-1133" data-line="1133">                    }), load, config);
</a><a name="line-1134" data-line="1134">                }));
</a><a name="line-1135" data-line="1135">
</a><a name="line-1136" data-line="1136">                context.enable(pluginMap, this);
</a><a name="line-1137" data-line="1137">                this.pluginMaps[pluginMap.id] = pluginMap;
</a><a name="line-1138" data-line="1138">            },
</a><a name="line-1139" data-line="1139">
</a><a name="line-1140" data-line="1140">            enable: function () {
</a><a name="line-1141" data-line="1141">                this.enabled = true;
</a><a name="line-1142" data-line="1142">
</a><a name="line-1143" data-line="1143">                if (!this.waitPushed) {
</a><a name="line-1144" data-line="1144">                    waitAry.push(this);
</a><a name="line-1145" data-line="1145">                    context.waitCount += 1;
</a><a name="line-1146" data-line="1146">                    this.waitPushed = true;
</a><a name="line-1147" data-line="1147">                }
</a><a name="line-1148" data-line="1148">
</a><a name="line-1149" data-line="1149">                //Set flag mentioning that the module is enabling,
</a><a name="line-1150" data-line="1150">                //so that immediate calls to the defined callbacks
</a><a name="line-1151" data-line="1151">                //for dependencies do not trigger inadvertent load
</a><a name="line-1152" data-line="1152">                //with the depCount still being zero.
</a><a name="line-1153" data-line="1153">                this.enabling = true;
</a><a name="line-1154" data-line="1154">
</a><a name="line-1155" data-line="1155">                //Enable each dependency
</a><a name="line-1156" data-line="1156">                each(this.depMaps, bind(this, function (depMap, i) {
</a><a name="line-1157" data-line="1157">                    var id, mod, handler;
</a><a name="line-1158" data-line="1158">
</a><a name="line-1159" data-line="1159">                    if (typeof depMap === 'string') {
</a><a name="line-1160" data-line="1160">                        //Dependency needs to be converted to a depMap
</a><a name="line-1161" data-line="1161">                        //and wired up to this module.
</a><a name="line-1162" data-line="1162">                        depMap = makeModuleMap(depMap,
</a><a name="line-1163" data-line="1163">                                               (this.map.isDefine ? this.map : this.map.parentMap),
</a><a name="line-1164" data-line="1164">                                               false,
</a><a name="line-1165" data-line="1165">                                               !this.depMaps.rjsSkipMap);
</a><a name="line-1166" data-line="1166">                        this.depMaps[i] = depMap;
</a><a name="line-1167" data-line="1167">
</a><a name="line-1168" data-line="1168">                        handler = handlers[depMap.id];
</a><a name="line-1169" data-line="1169">
</a><a name="line-1170" data-line="1170">                        if (handler) {
</a><a name="line-1171" data-line="1171">                            this.depExports[i] = handler(this);
</a><a name="line-1172" data-line="1172">                            return;
</a><a name="line-1173" data-line="1173">                        }
</a><a name="line-1174" data-line="1174">
</a><a name="line-1175" data-line="1175">                        this.depCount += 1;
</a><a name="line-1176" data-line="1176">
</a><a name="line-1177" data-line="1177">                        on(depMap, 'defined', bind(this, function (depExports) {
</a><a name="line-1178" data-line="1178">                            this.defineDep(i, depExports);
</a><a name="line-1179" data-line="1179">                            this.check();
</a><a name="line-1180" data-line="1180">                        }));
</a><a name="line-1181" data-line="1181">
</a><a name="line-1182" data-line="1182">                        if (this.errback) {
</a><a name="line-1183" data-line="1183">                            on(depMap, 'error', this.errback);
</a><a name="line-1184" data-line="1184">                        }
</a><a name="line-1185" data-line="1185">                    }
</a><a name="line-1186" data-line="1186">
</a><a name="line-1187" data-line="1187">                    id = depMap.id;
</a><a name="line-1188" data-line="1188">                    mod = registry[id];
</a><a name="line-1189" data-line="1189">
</a><a name="line-1190" data-line="1190">                    //Skip special modules like 'require', 'exports', 'module'
</a><a name="line-1191" data-line="1191">                    //Also, don't call enable if it is already enabled,
</a><a name="line-1192" data-line="1192">                    //important in circular dependency cases.
</a><a name="line-1193" data-line="1193">                    if (!handlers[id] &amp;&amp; mod &amp;&amp; !mod.enabled) {
</a><a name="line-1194" data-line="1194">                        context.enable(depMap, this);
</a><a name="line-1195" data-line="1195">                    }
</a><a name="line-1196" data-line="1196">                }));
</a><a name="line-1197" data-line="1197">
</a><a name="line-1198" data-line="1198">                //Enable each plugin that is used in
</a><a name="line-1199" data-line="1199">                //a dependency
</a><a name="line-1200" data-line="1200">                eachProp(this.pluginMaps, bind(this, function (pluginMap) {
</a><a name="line-1201" data-line="1201">                    var mod = registry[pluginMap.id];
</a><a name="line-1202" data-line="1202">                    if (mod &amp;&amp; !mod.enabled) {
</a><a name="line-1203" data-line="1203">                        context.enable(pluginMap, this);
</a><a name="line-1204" data-line="1204">                    }
</a><a name="line-1205" data-line="1205">                }));
</a><a name="line-1206" data-line="1206">
</a><a name="line-1207" data-line="1207">                this.enabling = false;
</a><a name="line-1208" data-line="1208">
</a><a name="line-1209" data-line="1209">                this.check();
</a><a name="line-1210" data-line="1210">            },
</a><a name="line-1211" data-line="1211">
</a><a name="line-1212" data-line="1212">            on: function(name, cb) {
</a><a name="line-1213" data-line="1213">                var cbs = this.events[name];
</a><a name="line-1214" data-line="1214">                if (!cbs) {
</a><a name="line-1215" data-line="1215">                    cbs = this.events[name] = [];
</a><a name="line-1216" data-line="1216">                }
</a><a name="line-1217" data-line="1217">                cbs.push(cb);
</a><a name="line-1218" data-line="1218">            },
</a><a name="line-1219" data-line="1219">
</a><a name="line-1220" data-line="1220">            emit: function (name, evt) {
</a><a name="line-1221" data-line="1221">                each(this.events[name], function (cb) {
</a><a name="line-1222" data-line="1222">                    cb(evt);
</a><a name="line-1223" data-line="1223">                });
</a><a name="line-1224" data-line="1224">                if (name === 'error') {
</a><a name="line-1225" data-line="1225">                    //Now that the error handler was triggered, remove
</a><a name="line-1226" data-line="1226">                    //the listeners, since this broken Module instance
</a><a name="line-1227" data-line="1227">                    //can stay around for a while in the registry/waitAry.
</a><a name="line-1228" data-line="1228">                    delete this.events[name];
</a><a name="line-1229" data-line="1229">                }
</a><a name="line-1230" data-line="1230">            }
</a><a name="line-1231" data-line="1231">        };
</a><a name="line-1232" data-line="1232">
</a><a name="line-1233" data-line="1233">        function callGetModule(args) {
</a><a name="line-1234" data-line="1234">            getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
</a><a name="line-1235" data-line="1235">        }
</a><a name="line-1236" data-line="1236">
</a><a name="line-1237" data-line="1237">        function removeListener(node, func, name, ieName) {
</a><a name="line-1238" data-line="1238">            //Favor detachEvent because of IE9
</a><a name="line-1239" data-line="1239">            //issue, see attachEvent/addEventListener comment elsewhere
</a><a name="line-1240" data-line="1240">            //in this file.
</a><a name="line-1241" data-line="1241">            if (node.detachEvent &amp;&amp; !isOpera) {
</a><a name="line-1242" data-line="1242">                //Probably IE. If not it will throw an error, which will be
</a><a name="line-1243" data-line="1243">                //useful to know.
</a><a name="line-1244" data-line="1244">                if (ieName) {
</a><a name="line-1245" data-line="1245">                    node.detachEvent(ieName, func);
</a><a name="line-1246" data-line="1246">                }
</a><a name="line-1247" data-line="1247">            } else {
</a><a name="line-1248" data-line="1248">                node.removeEventListener(name, func, false);
</a><a name="line-1249" data-line="1249">            }
</a><a name="line-1250" data-line="1250">        }
</a><a name="line-1251" data-line="1251">
</a><a name="line-1252" data-line="1252">        /**
</a><a name="line-1253" data-line="1253">         * Given an event from a script node, get the requirejs info from it,
</a><a name="line-1254" data-line="1254">         * and then removes the event listeners on the node.
</a><a name="line-1255" data-line="1255">         * @param {Event} evt
</a><a name="line-1256" data-line="1256">         * @returns {Object}
</a><a name="line-1257" data-line="1257">         */
</a><a name="line-1258" data-line="1258">        function getScriptData(evt) {
</a><a name="line-1259" data-line="1259">            //Using currentTarget instead of target for Firefox 2.0's sake. Not
</a><a name="line-1260" data-line="1260">            //all old browsers will be supported, but this one was easy enough
</a><a name="line-1261" data-line="1261">            //to support and still makes sense.
</a><a name="line-1262" data-line="1262">            var node = evt.currentTarget || evt.srcElement;
</a><a name="line-1263" data-line="1263">
</a><a name="line-1264" data-line="1264">            //Remove the listeners once here.
</a><a name="line-1265" data-line="1265">            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
</a><a name="line-1266" data-line="1266">            removeListener(node, context.onScriptError, 'error');
</a><a name="line-1267" data-line="1267">
</a><a name="line-1268" data-line="1268">            return {
</a><a name="line-1269" data-line="1269">                node: node,
</a><a name="line-1270" data-line="1270">                id: node &amp;&amp; node.getAttribute('data-requiremodule')
</a><a name="line-1271" data-line="1271">            };
</a><a name="line-1272" data-line="1272">        }
</a><a name="line-1273" data-line="1273">
</a><a name="line-1274" data-line="1274">        return (context = {
</a><a name="line-1275" data-line="1275">            config: config,
</a><a name="line-1276" data-line="1276">            contextName: contextName,
</a><a name="line-1277" data-line="1277">            registry: registry,
</a><a name="line-1278" data-line="1278">            defined: defined,
</a><a name="line-1279" data-line="1279">            urlFetched: urlFetched,
</a><a name="line-1280" data-line="1280">            waitCount: 0,
</a><a name="line-1281" data-line="1281">            defQueue: defQueue,
</a><a name="line-1282" data-line="1282">            Module: Module,
</a><a name="line-1283" data-line="1283">            makeModuleMap: makeModuleMap,
</a><a name="line-1284" data-line="1284">
</a><a name="line-1285" data-line="1285">            /**
</a><a name="line-1286" data-line="1286">             * Set a configuration for the context.
</a><a name="line-1287" data-line="1287">             * @param {Object} cfg config object to integrate.
</a><a name="line-1288" data-line="1288">             */
</a><a name="line-1289" data-line="1289">            configure: function (cfg) {
</a><a name="line-1290" data-line="1290">                //Make sure the baseUrl ends in a slash.
</a><a name="line-1291" data-line="1291">                if (cfg.baseUrl) {
</a><a name="line-1292" data-line="1292">                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
</a><a name="line-1293" data-line="1293">                        cfg.baseUrl += '/';
</a><a name="line-1294" data-line="1294">                    }
</a><a name="line-1295" data-line="1295">                }
</a><a name="line-1296" data-line="1296">
</a><a name="line-1297" data-line="1297">                //Save off the paths and packages since they require special processing,
</a><a name="line-1298" data-line="1298">                //they are additive.
</a><a name="line-1299" data-line="1299">                var pkgs = config.pkgs,
</a><a name="line-1300" data-line="1300">                    shim = config.shim,
</a><a name="line-1301" data-line="1301">                    paths = config.paths,
</a><a name="line-1302" data-line="1302">                    map = config.map;
</a><a name="line-1303" data-line="1303">
</a><a name="line-1304" data-line="1304">                //Mix in the config values, favoring the new values over
</a><a name="line-1305" data-line="1305">                //existing ones in context.config.
</a><a name="line-1306" data-line="1306">                mixin(config, cfg, true);
</a><a name="line-1307" data-line="1307">
</a><a name="line-1308" data-line="1308">                //Merge paths.
</a><a name="line-1309" data-line="1309">                config.paths = mixin(paths, cfg.paths, true);
</a><a name="line-1310" data-line="1310">
</a><a name="line-1311" data-line="1311">                //Merge map
</a><a name="line-1312" data-line="1312">                if (cfg.map) {
</a><a name="line-1313" data-line="1313">                    config.map = mixin(map || {}, cfg.map, true, true);
</a><a name="line-1314" data-line="1314">                }
</a><a name="line-1315" data-line="1315">
</a><a name="line-1316" data-line="1316">                //Merge shim
</a><a name="line-1317" data-line="1317">                if (cfg.shim) {
</a><a name="line-1318" data-line="1318">                    eachProp(cfg.shim, function (value, id) {
</a><a name="line-1319" data-line="1319">                        //Normalize the structure
</a><a name="line-1320" data-line="1320">                        if (isArray(value)) {
</a><a name="line-1321" data-line="1321">                            value = {
</a><a name="line-1322" data-line="1322">                                deps: value
</a><a name="line-1323" data-line="1323">                            };
</a><a name="line-1324" data-line="1324">                        }
</a><a name="line-1325" data-line="1325">                        if (value.exports &amp;&amp; !value.exports.__buildReady) {
</a><a name="line-1326" data-line="1326">                            value.exports = context.makeShimExports(value.exports);
</a><a name="line-1327" data-line="1327">                        }
</a><a name="line-1328" data-line="1328">                        shim[id] = value;
</a><a name="line-1329" data-line="1329">                    });
</a><a name="line-1330" data-line="1330">                    config.shim = shim;
</a><a name="line-1331" data-line="1331">                }
</a><a name="line-1332" data-line="1332">
</a><a name="line-1333" data-line="1333">                //Adjust packages if necessary.
</a><a name="line-1334" data-line="1334">                if (cfg.packages) {
</a><a name="line-1335" data-line="1335">                    each(cfg.packages, function (pkgObj) {
</a><a name="line-1336" data-line="1336">                        var location;
</a><a name="line-1337" data-line="1337">
</a><a name="line-1338" data-line="1338">                        pkgObj = typeof pkgObj === 'string' ? { name: pkgObj } : pkgObj;
</a><a name="line-1339" data-line="1339">                        location = pkgObj.location;
</a><a name="line-1340" data-line="1340">
</a><a name="line-1341" data-line="1341">                        //Create a brand new object on pkgs, since currentPackages can
</a><a name="line-1342" data-line="1342">                        //be passed in again, and config.pkgs is the internal transformed
</a><a name="line-1343" data-line="1343">                        //state for all package configs.
</a><a name="line-1344" data-line="1344">                        pkgs[pkgObj.name] = {
</a><a name="line-1345" data-line="1345">                            name: pkgObj.name,
</a><a name="line-1346" data-line="1346">                            location: location || pkgObj.name,
</a><a name="line-1347" data-line="1347">                            //Remove leading dot in main, so main paths are normalized,
</a><a name="line-1348" data-line="1348">                            //and remove any trailing .js, since different package
</a><a name="line-1349" data-line="1349">                            //envs have different conventions: some use a module name,
</a><a name="line-1350" data-line="1350">                            //some use a file name.
</a><a name="line-1351" data-line="1351">                            main: (pkgObj.main || 'main')
</a><a name="line-1352" data-line="1352">                                  .replace(currDirRegExp, '')
</a><a name="line-1353" data-line="1353">                                  .replace(jsSuffixRegExp, '')
</a><a name="line-1354" data-line="1354">                        };
</a><a name="line-1355" data-line="1355">                    });
</a><a name="line-1356" data-line="1356">
</a><a name="line-1357" data-line="1357">                    //Done with modifications, assing packages back to context config
</a><a name="line-1358" data-line="1358">                    config.pkgs = pkgs;
</a><a name="line-1359" data-line="1359">                }
</a><a name="line-1360" data-line="1360">
</a><a name="line-1361" data-line="1361">                //If there are any &quot;waiting to execute&quot; modules in the registry,
</a><a name="line-1362" data-line="1362">                //update the maps for them, since their info, like URLs to load,
</a><a name="line-1363" data-line="1363">                //may have changed.
</a><a name="line-1364" data-line="1364">                eachProp(registry, function (mod, id) {
</a><a name="line-1365" data-line="1365">                    mod.map = makeModuleMap(id);
</a><a name="line-1366" data-line="1366">                });
</a><a name="line-1367" data-line="1367">
</a><a name="line-1368" data-line="1368">                //If a deps array or a config callback is specified, then call
</a><a name="line-1369" data-line="1369">                //require with those args. This is useful when require is defined as a
</a><a name="line-1370" data-line="1370">                //config object before require.js is loaded.
</a><a name="line-1371" data-line="1371">                if (cfg.deps || cfg.callback) {
</a><a name="line-1372" data-line="1372">                    context.require(cfg.deps || [], cfg.callback);
</a><a name="line-1373" data-line="1373">                }
</a><a name="line-1374" data-line="1374">            },
</a><a name="line-1375" data-line="1375">
</a><a name="line-1376" data-line="1376">            makeShimExports: function (exports) {
</a><a name="line-1377" data-line="1377">                var func;
</a><a name="line-1378" data-line="1378">                if (typeof exports === 'string') {
</a><a name="line-1379" data-line="1379">                    func = function () {
</a><a name="line-1380" data-line="1380">                        return getGlobal(exports);
</a><a name="line-1381" data-line="1381">                    };
</a><a name="line-1382" data-line="1382">                    //Save the exports for use in nodefine checking.
</a><a name="line-1383" data-line="1383">                    func.exports = exports;
</a><a name="line-1384" data-line="1384">                    return func;
</a><a name="line-1385" data-line="1385">                } else {
</a><a name="line-1386" data-line="1386">                    return function () {
</a><a name="line-1387" data-line="1387">                        return exports.apply(global, arguments);
</a><a name="line-1388" data-line="1388">                    };
</a><a name="line-1389" data-line="1389">                }
</a><a name="line-1390" data-line="1390">            },
</a><a name="line-1391" data-line="1391">
</a><a name="line-1392" data-line="1392">            requireDefined: function (id, relMap) {
</a><a name="line-1393" data-line="1393">                return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
</a><a name="line-1394" data-line="1394">            },
</a><a name="line-1395" data-line="1395">
</a><a name="line-1396" data-line="1396">            requireSpecified: function (id, relMap) {
</a><a name="line-1397" data-line="1397">                id = makeModuleMap(id, relMap, false, true).id;
</a><a name="line-1398" data-line="1398">                return hasProp(defined, id) || hasProp(registry, id);
</a><a name="line-1399" data-line="1399">            },
</a><a name="line-1400" data-line="1400">
</a><a name="line-1401" data-line="1401">            require: function (deps, callback, errback, relMap) {
</a><a name="line-1402" data-line="1402">                var moduleName, id, map, requireMod, args;
</a><a name="line-1403" data-line="1403">                if (typeof deps === 'string') {
</a><a name="line-1404" data-line="1404">                    if (isFunction(callback)) {
</a><a name="line-1405" data-line="1405">                        //Invalid call
</a><a name="line-1406" data-line="1406">                        return onError(makeError('requireargs', 'Invalid require call'), errback);
</a><a name="line-1407" data-line="1407">                    }
</a><a name="line-1408" data-line="1408">
</a><a name="line-1409" data-line="1409">                    //Synchronous access to one module. If require.get is
</a><a name="line-1410" data-line="1410">                    //available (as in the Node adapter), prefer that.
</a><a name="line-1411" data-line="1411">                    //In this case deps is the moduleName and callback is
</a><a name="line-1412" data-line="1412">                    //the relMap
</a><a name="line-1413" data-line="1413">                    if (req.get) {
</a><a name="line-1414" data-line="1414">                        return req.get(context, deps, callback);
</a><a name="line-1415" data-line="1415">                    }
</a><a name="line-1416" data-line="1416">
</a><a name="line-1417" data-line="1417">                    //Just return the module wanted. In this scenario, the
</a><a name="line-1418" data-line="1418">                    //second arg (if passed) is just the relMap.
</a><a name="line-1419" data-line="1419">                    moduleName = deps;
</a><a name="line-1420" data-line="1420">                    relMap = callback;
</a><a name="line-1421" data-line="1421">
</a><a name="line-1422" data-line="1422">                    //Normalize module name, if it contains . or ..
</a><a name="line-1423" data-line="1423">                    map = makeModuleMap(moduleName, relMap, false, true);
</a><a name="line-1424" data-line="1424">                    id = map.id;
</a><a name="line-1425" data-line="1425">
</a><a name="line-1426" data-line="1426">                    if (!hasProp(defined, id)) {
</a><a name="line-1427" data-line="1427">                        return onError(makeError('notloaded', 'Module name &quot;' +
</a><a name="line-1428" data-line="1428">                                    id +
</a><a name="line-1429" data-line="1429">                                    '&quot; has not been loaded yet for context: ' +
</a><a name="line-1430" data-line="1430">                                    contextName));
</a><a name="line-1431" data-line="1431">                    }
</a><a name="line-1432" data-line="1432">                    return defined[id];
</a><a name="line-1433" data-line="1433">                }
</a><a name="line-1434" data-line="1434">
</a><a name="line-1435" data-line="1435">                //Callback require. Normalize args. if callback or errback is
</a><a name="line-1436" data-line="1436">                //not a function, it means it is a relMap. Test errback first.
</a><a name="line-1437" data-line="1437">                if (errback &amp;&amp; !isFunction(errback)) {
</a><a name="line-1438" data-line="1438">                    relMap = errback;
</a><a name="line-1439" data-line="1439">                    errback = undefined;
</a><a name="line-1440" data-line="1440">                }
</a><a name="line-1441" data-line="1441">                if (callback &amp;&amp; !isFunction(callback)) {
</a><a name="line-1442" data-line="1442">                    relMap = callback;
</a><a name="line-1443" data-line="1443">                    callback = undefined;
</a><a name="line-1444" data-line="1444">                }
</a><a name="line-1445" data-line="1445">
</a><a name="line-1446" data-line="1446">                //Any defined modules in the global queue, intake them now.
</a><a name="line-1447" data-line="1447">                takeGlobalQueue();
</a><a name="line-1448" data-line="1448">
</a><a name="line-1449" data-line="1449">                //Make sure any remaining defQueue items get properly processed.
</a><a name="line-1450" data-line="1450">                while (defQueue.length) {
</a><a name="line-1451" data-line="1451">                    args = defQueue.shift();
</a><a name="line-1452" data-line="1452">                    if (args[0] === null) {
</a><a name="line-1453" data-line="1453">                        return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
</a><a name="line-1454" data-line="1454">                    } else {
</a><a name="line-1455" data-line="1455">                        //args are id, deps, factory. Should be normalized by the
</a><a name="line-1456" data-line="1456">                        //define() function.
</a><a name="line-1457" data-line="1457">                        callGetModule(args);
</a><a name="line-1458" data-line="1458">                    }
</a><a name="line-1459" data-line="1459">                }
</a><a name="line-1460" data-line="1460">
</a><a name="line-1461" data-line="1461">                //Mark all the dependencies as needing to be loaded.
</a><a name="line-1462" data-line="1462">                requireMod = getModule(makeModuleMap(null, relMap));
</a><a name="line-1463" data-line="1463">
</a><a name="line-1464" data-line="1464">                requireMod.init(deps, callback, errback, {
</a><a name="line-1465" data-line="1465">                    enabled: true
</a><a name="line-1466" data-line="1466">                });
</a><a name="line-1467" data-line="1467">
</a><a name="line-1468" data-line="1468">                checkLoaded();
</a><a name="line-1469" data-line="1469">
</a><a name="line-1470" data-line="1470">                return context.require;
</a><a name="line-1471" data-line="1471">            },
</a><a name="line-1472" data-line="1472">
</a><a name="line-1473" data-line="1473">            undef: function (id) {
</a><a name="line-1474" data-line="1474">                var map = makeModuleMap(id, null, true),
</a><a name="line-1475" data-line="1475">                    mod = registry[id];
</a><a name="line-1476" data-line="1476">
</a><a name="line-1477" data-line="1477">                delete defined[id];
</a><a name="line-1478" data-line="1478">                delete urlFetched[map.url];
</a><a name="line-1479" data-line="1479">                delete undefEvents[id];
</a><a name="line-1480" data-line="1480">
</a><a name="line-1481" data-line="1481">                if (mod) {
</a><a name="line-1482" data-line="1482">                    //Hold on to listeners in case the
</a><a name="line-1483" data-line="1483">                    //module will be attempted to be reloaded
</a><a name="line-1484" data-line="1484">                    //using a different config.
</a><a name="line-1485" data-line="1485">                    if (mod.events.defined) {
</a><a name="line-1486" data-line="1486">                        undefEvents[id] = mod.events;
</a><a name="line-1487" data-line="1487">                    }
</a><a name="line-1488" data-line="1488">
</a><a name="line-1489" data-line="1489">                    removeWaiting(id);
</a><a name="line-1490" data-line="1490">                }
</a><a name="line-1491" data-line="1491">            },
</a><a name="line-1492" data-line="1492">
</a><a name="line-1493" data-line="1493">            /**
</a><a name="line-1494" data-line="1494">             * Called to enable a module if it is still in the registry
</a><a name="line-1495" data-line="1495">             * awaiting enablement. parent module is passed in for context,
</a><a name="line-1496" data-line="1496">             * used by the optimizer.
</a><a name="line-1497" data-line="1497">             */
</a><a name="line-1498" data-line="1498">            enable: function (depMap, parent) {
</a><a name="line-1499" data-line="1499">                var mod = registry[depMap.id];
</a><a name="line-1500" data-line="1500">                if (mod) {
</a><a name="line-1501" data-line="1501">                    getModule(depMap).enable();
</a><a name="line-1502" data-line="1502">                }
</a><a name="line-1503" data-line="1503">            },
</a><a name="line-1504" data-line="1504">
</a><a name="line-1505" data-line="1505">            /**
</a><a name="line-1506" data-line="1506">             * Internal method used by environment adapters to complete a load event.
</a><a name="line-1507" data-line="1507">             * A load event could be a script load or just a load pass from a synchronous
</a><a name="line-1508" data-line="1508">             * load call.
</a><a name="line-1509" data-line="1509">             * @param {String} moduleName the name of the module to potentially complete.
</a><a name="line-1510" data-line="1510">             */
</a><a name="line-1511" data-line="1511">            completeLoad: function (moduleName) {
</a><a name="line-1512" data-line="1512">                var shim = config.shim[moduleName] || {},
</a><a name="line-1513" data-line="1513">                shExports = shim.exports &amp;&amp; shim.exports.exports,
</a><a name="line-1514" data-line="1514">                found, args, mod;
</a><a name="line-1515" data-line="1515">
</a><a name="line-1516" data-line="1516">                takeGlobalQueue();
</a><a name="line-1517" data-line="1517">
</a><a name="line-1518" data-line="1518">                while (defQueue.length) {
</a><a name="line-1519" data-line="1519">                    args = defQueue.shift();
</a><a name="line-1520" data-line="1520">                    if (args[0] === null) {
</a><a name="line-1521" data-line="1521">                        args[0] = moduleName;
</a><a name="line-1522" data-line="1522">                        //If already found an anonymous module and bound it
</a><a name="line-1523" data-line="1523">                        //to this name, then this is some other anon module
</a><a name="line-1524" data-line="1524">                        //waiting for its completeLoad to fire.
</a><a name="line-1525" data-line="1525">                        if (found) {
</a><a name="line-1526" data-line="1526">                            break;
</a><a name="line-1527" data-line="1527">                        }
</a><a name="line-1528" data-line="1528">                        found = true;
</a><a name="line-1529" data-line="1529">                    } else if (args[0] === moduleName) {
</a><a name="line-1530" data-line="1530">                        //Found matching define call for this script!
</a><a name="line-1531" data-line="1531">                        found = true;
</a><a name="line-1532" data-line="1532">                    }
</a><a name="line-1533" data-line="1533">
</a><a name="line-1534" data-line="1534">                    callGetModule(args);
</a><a name="line-1535" data-line="1535">                }
</a><a name="line-1536" data-line="1536">
</a><a name="line-1537" data-line="1537">                //Do this after the cycle of callGetModule in case the result
</a><a name="line-1538" data-line="1538">                //of those calls/init calls changes the registry.
</a><a name="line-1539" data-line="1539">                mod = registry[moduleName];
</a><a name="line-1540" data-line="1540">
</a><a name="line-1541" data-line="1541">                if (!found &amp;&amp;
</a><a name="line-1542" data-line="1542">                    !defined[moduleName] &amp;&amp;
</a><a name="line-1543" data-line="1543">                    mod &amp;&amp; !mod.inited) {
</a><a name="line-1544" data-line="1544">                    if (config.enforceDefine &amp;&amp; (!shExports || !getGlobal(shExports))) {
</a><a name="line-1545" data-line="1545">                        if (hasPathFallback(moduleName)) {
</a><a name="line-1546" data-line="1546">                            return;
</a><a name="line-1547" data-line="1547">                        } else {
</a><a name="line-1548" data-line="1548">                            return onError(makeError('nodefine',
</a><a name="line-1549" data-line="1549">                                             'No define call for ' + moduleName,
</a><a name="line-1550" data-line="1550">                                             null,
</a><a name="line-1551" data-line="1551">                                             [moduleName]));
</a><a name="line-1552" data-line="1552">                        }
</a><a name="line-1553" data-line="1553">                    } else {
</a><a name="line-1554" data-line="1554">                        //A script that does not call define(), so just simulate
</a><a name="line-1555" data-line="1555">                        //the call for it.
</a><a name="line-1556" data-line="1556">                        callGetModule([moduleName, (shim.deps || []), shim.exports]);
</a><a name="line-1557" data-line="1557">                    }
</a><a name="line-1558" data-line="1558">                }
</a><a name="line-1559" data-line="1559">
</a><a name="line-1560" data-line="1560">                checkLoaded();
</a><a name="line-1561" data-line="1561">            },
</a><a name="line-1562" data-line="1562">
</a><a name="line-1563" data-line="1563">            /**
</a><a name="line-1564" data-line="1564">             * Converts a module name + .extension into an URL path.
</a><a name="line-1565" data-line="1565">             * *Requires* the use of a module name. It does not support using
</a><a name="line-1566" data-line="1566">             * plain URLs like nameToUrl.
</a><a name="line-1567" data-line="1567">             */
</a><a name="line-1568" data-line="1568">            toUrl: function (moduleNamePlusExt, relModuleMap) {
</a><a name="line-1569" data-line="1569">                var index = moduleNamePlusExt.lastIndexOf('.'),
</a><a name="line-1570" data-line="1570">                    ext = null;
</a><a name="line-1571" data-line="1571">
</a><a name="line-1572" data-line="1572">                if (index !== -1) {
</a><a name="line-1573" data-line="1573">                    ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
</a><a name="line-1574" data-line="1574">                    moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
</a><a name="line-1575" data-line="1575">                }
</a><a name="line-1576" data-line="1576">
</a><a name="line-1577" data-line="1577">                return context.nameToUrl(normalize(moduleNamePlusExt, relModuleMap &amp;&amp; relModuleMap.id, true),
</a><a name="line-1578" data-line="1578">                                         ext);
</a><a name="line-1579" data-line="1579">            },
</a><a name="line-1580" data-line="1580">
</a><a name="line-1581" data-line="1581">            /**
</a><a name="line-1582" data-line="1582">             * Converts a module name to a file path. Supports cases where
</a><a name="line-1583" data-line="1583">             * moduleName may actually be just an URL.
</a><a name="line-1584" data-line="1584">             * Note that it **does not** call normalize on the moduleName,
</a><a name="line-1585" data-line="1585">             * it is assumed to have already been normalized. This is an
</a><a name="line-1586" data-line="1586">             * internal API, not a public one. Use toUrl for the public API.
</a><a name="line-1587" data-line="1587">             */
</a><a name="line-1588" data-line="1588">            nameToUrl: function (moduleName, ext) {
</a><a name="line-1589" data-line="1589">                var paths, pkgs, pkg, pkgPath, syms, i, parentModule, url,
</a><a name="line-1590" data-line="1590">                    parentPath;
</a><a name="line-1591" data-line="1591">
</a><a name="line-1592" data-line="1592">                //If a colon is in the URL, it indicates a protocol is used and it is just
</a><a name="line-1593" data-line="1593">                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
</a><a name="line-1594" data-line="1594">                //or ends with .js, then assume the user meant to use an url and not a module id.
</a><a name="line-1595" data-line="1595">                //The slash is important for protocol-less URLs as well as full paths.
</a><a name="line-1596" data-line="1596">                if (req.jsExtRegExp.test(moduleName)) {
</a><a name="line-1597" data-line="1597">                    //Just a plain path, not module name lookup, so just return it.
</a><a name="line-1598" data-line="1598">                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
</a><a name="line-1599" data-line="1599">                    //an extension, this method probably needs to be reworked.
</a><a name="line-1600" data-line="1600">                    url = moduleName + (ext || '');
</a><a name="line-1601" data-line="1601">                } else {
</a><a name="line-1602" data-line="1602">                    //A module that needs to be converted to a path.
</a><a name="line-1603" data-line="1603">                    paths = config.paths;
</a><a name="line-1604" data-line="1604">                    pkgs = config.pkgs;
</a><a name="line-1605" data-line="1605">
</a><a name="line-1606" data-line="1606">                    syms = moduleName.split('/');
</a><a name="line-1607" data-line="1607">                    //For each module name segment, see if there is a path
</a><a name="line-1608" data-line="1608">                    //registered for it. Start with most specific name
</a><a name="line-1609" data-line="1609">                    //and work up from it.
</a><a name="line-1610" data-line="1610">                    for (i = syms.length; i &gt; 0; i -= 1) {
</a><a name="line-1611" data-line="1611">                        parentModule = syms.slice(0, i).join('/');
</a><a name="line-1612" data-line="1612">                        pkg = pkgs[parentModule];
</a><a name="line-1613" data-line="1613">                        parentPath = paths[parentModule];
</a><a name="line-1614" data-line="1614">                        if (parentPath) {
</a><a name="line-1615" data-line="1615">                            //If an array, it means there are a few choices,
</a><a name="line-1616" data-line="1616">                            //Choose the one that is desired
</a><a name="line-1617" data-line="1617">                            if (isArray(parentPath)) {
</a><a name="line-1618" data-line="1618">                                parentPath = parentPath[0];
</a><a name="line-1619" data-line="1619">                            }
</a><a name="line-1620" data-line="1620">                            syms.splice(0, i, parentPath);
</a><a name="line-1621" data-line="1621">                            break;
</a><a name="line-1622" data-line="1622">                        } else if (pkg) {
</a><a name="line-1623" data-line="1623">                            //If module name is just the package name, then looking
</a><a name="line-1624" data-line="1624">                            //for the main module.
</a><a name="line-1625" data-line="1625">                            if (moduleName === pkg.name) {
</a><a name="line-1626" data-line="1626">                                pkgPath = pkg.location + '/' + pkg.main;
</a><a name="line-1627" data-line="1627">                            } else {
</a><a name="line-1628" data-line="1628">                                pkgPath = pkg.location;
</a><a name="line-1629" data-line="1629">                            }
</a><a name="line-1630" data-line="1630">                            syms.splice(0, i, pkgPath);
</a><a name="line-1631" data-line="1631">                            break;
</a><a name="line-1632" data-line="1632">                        }
</a><a name="line-1633" data-line="1633">                    }
</a><a name="line-1634" data-line="1634">
</a><a name="line-1635" data-line="1635">                    //Join the path parts together, then figure out if baseUrl is needed.
</a><a name="line-1636" data-line="1636">                    url = syms.join('/') + (ext || '.js');
</a><a name="line-1637" data-line="1637">                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
</a><a name="line-1638" data-line="1638">                }
</a><a name="line-1639" data-line="1639">
</a><a name="line-1640" data-line="1640">                return config.urlArgs ? url +
</a><a name="line-1641" data-line="1641">                                        ((url.indexOf('?') === -1 ? '?' : '&amp;') +
</a><a name="line-1642" data-line="1642">                                         config.urlArgs) : url;
</a><a name="line-1643" data-line="1643">            },
</a><a name="line-1644" data-line="1644">
</a><a name="line-1645" data-line="1645">            //Delegates to req.load. Broken out as a separate function to
</a><a name="line-1646" data-line="1646">            //allow overriding in the optimizer.
</a><a name="line-1647" data-line="1647">            load: function (id, url) {
</a><a name="line-1648" data-line="1648">                req.load(context, id, url);
</a><a name="line-1649" data-line="1649">            },
</a><a name="line-1650" data-line="1650">
</a><a name="line-1651" data-line="1651">            /**
</a><a name="line-1652" data-line="1652">             * Executes a module callack function. Broken out as a separate function
</a><a name="line-1653" data-line="1653">             * solely to allow the build system to sequence the files in the built
</a><a name="line-1654" data-line="1654">             * layer in the right sequence.
</a><a name="line-1655" data-line="1655">             *
</a><a name="line-1656" data-line="1656">             * @private
</a><a name="line-1657" data-line="1657">             */
</a><a name="line-1658" data-line="1658">            execCb: function (name, callback, args, exports) {
</a><a name="line-1659" data-line="1659">                return callback.apply(exports, args);
</a><a name="line-1660" data-line="1660">            },
</a><a name="line-1661" data-line="1661">
</a><a name="line-1662" data-line="1662">            /**
</a><a name="line-1663" data-line="1663">             * callback for script loads, used to check status of loading.
</a><a name="line-1664" data-line="1664">             *
</a><a name="line-1665" data-line="1665">             * @param {Event} evt the event from the browser for the script
</a><a name="line-1666" data-line="1666">             * that was loaded.
</a><a name="line-1667" data-line="1667">             */
</a><a name="line-1668" data-line="1668">            onScriptLoad: function (evt) {
</a><a name="line-1669" data-line="1669">                //Using currentTarget instead of target for Firefox 2.0's sake. Not
</a><a name="line-1670" data-line="1670">                //all old browsers will be supported, but this one was easy enough
</a><a name="line-1671" data-line="1671">                //to support and still makes sense.
</a><a name="line-1672" data-line="1672">                if (evt.type === 'load' ||
</a><a name="line-1673" data-line="1673">                    (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
</a><a name="line-1674" data-line="1674">                    //Reset interactive script so a script node is not held onto for
</a><a name="line-1675" data-line="1675">                    //to long.
</a><a name="line-1676" data-line="1676">                    interactiveScript = null;
</a><a name="line-1677" data-line="1677">
</a><a name="line-1678" data-line="1678">                    //Pull out the name of the module and the context.
</a><a name="line-1679" data-line="1679">                    var data = getScriptData(evt);
</a><a name="line-1680" data-line="1680">                    context.completeLoad(data.id);
</a><a name="line-1681" data-line="1681">                }
</a><a name="line-1682" data-line="1682">            },
</a><a name="line-1683" data-line="1683">
</a><a name="line-1684" data-line="1684">            /**
</a><a name="line-1685" data-line="1685">             * Callback for script errors.
</a><a name="line-1686" data-line="1686">             */
</a><a name="line-1687" data-line="1687">            onScriptError: function (evt) {
</a><a name="line-1688" data-line="1688">                var data = getScriptData(evt);
</a><a name="line-1689" data-line="1689">                if (!hasPathFallback(data.id)) {
</a><a name="line-1690" data-line="1690">                    return onError(makeError('scripterror', 'Script error', evt, [data.id]));
</a><a name="line-1691" data-line="1691">                }
</a><a name="line-1692" data-line="1692">            }
</a><a name="line-1693" data-line="1693">        });
</a><a name="line-1694" data-line="1694">    }
</a><a name="line-1695" data-line="1695">
</a><a name="line-1696" data-line="1696">    /**
</a><a name="line-1697" data-line="1697">     * Main entry point.
</a><a name="line-1698" data-line="1698">     *
</a><a name="line-1699" data-line="1699">     * If the only argument to require is a string, then the module that
</a><a name="line-1700" data-line="1700">     * is represented by that string is fetched for the appropriate context.
</a><a name="line-1701" data-line="1701">     *
</a><a name="line-1702" data-line="1702">     * If the first argument is an array, then it will be treated as an array
</a><a name="line-1703" data-line="1703">     * of dependency string names to fetch. An optional function callback can
</a><a name="line-1704" data-line="1704">     * be specified to execute when all of those dependencies are available.
</a><a name="line-1705" data-line="1705">     *
</a><a name="line-1706" data-line="1706">     * Make a local req variable to help Caja compliance (it assumes things
</a><a name="line-1707" data-line="1707">     * on a require that are not standardized), and to give a short
</a><a name="line-1708" data-line="1708">     * name for minification/local scope use.
</a><a name="line-1709" data-line="1709">     */
</a><a name="line-1710" data-line="1710">    req = requirejs = function (deps, callback, errback, optional) {
</a><a name="line-1711" data-line="1711">
</a><a name="line-1712" data-line="1712">        //Find the right context, use default
</a><a name="line-1713" data-line="1713">        var contextName = defContextName,
</a><a name="line-1714" data-line="1714">            context, config;
</a><a name="line-1715" data-line="1715">
</a><a name="line-1716" data-line="1716">        // Determine if have config object in the call.
</a><a name="line-1717" data-line="1717">        if (!isArray(deps) &amp;&amp; typeof deps !== 'string') {
</a><a name="line-1718" data-line="1718">            // deps is a config object
</a><a name="line-1719" data-line="1719">            config = deps;
</a><a name="line-1720" data-line="1720">            if (isArray(callback)) {
</a><a name="line-1721" data-line="1721">                // Adjust args if there are dependencies
</a><a name="line-1722" data-line="1722">                deps = callback;
</a><a name="line-1723" data-line="1723">                callback = errback;
</a><a name="line-1724" data-line="1724">                errback = optional;
</a><a name="line-1725" data-line="1725">            } else {
</a><a name="line-1726" data-line="1726">                deps = [];
</a><a name="line-1727" data-line="1727">            }
</a><a name="line-1728" data-line="1728">        }
</a><a name="line-1729" data-line="1729">
</a><a name="line-1730" data-line="1730">        if (config &amp;&amp; config.context) {
</a><a name="line-1731" data-line="1731">            contextName = config.context;
</a><a name="line-1732" data-line="1732">        }
</a><a name="line-1733" data-line="1733">
</a><a name="line-1734" data-line="1734">        context = contexts[contextName];
</a><a name="line-1735" data-line="1735">        if (!context) {
</a><a name="line-1736" data-line="1736">            context = contexts[contextName] = req.s.newContext(contextName);
</a><a name="line-1737" data-line="1737">        }
</a><a name="line-1738" data-line="1738">
</a><a name="line-1739" data-line="1739">        if (config) {
</a><a name="line-1740" data-line="1740">            context.configure(config);
</a><a name="line-1741" data-line="1741">        }
</a><a name="line-1742" data-line="1742">
</a><a name="line-1743" data-line="1743">        return context.require(deps, callback, errback);
</a><a name="line-1744" data-line="1744">    };
</a><a name="line-1745" data-line="1745">
</a><a name="line-1746" data-line="1746">    /**
</a><a name="line-1747" data-line="1747">     * Support require.config() to make it easier to cooperate with other
</a><a name="line-1748" data-line="1748">     * AMD loaders on globally agreed names.
</a><a name="line-1749" data-line="1749">     */
</a><a name="line-1750" data-line="1750">    req.config = function (config) {
</a><a name="line-1751" data-line="1751">        return req(config);
</a><a name="line-1752" data-line="1752">    };
</a><a name="line-1753" data-line="1753">
</a><a name="line-1754" data-line="1754">    /**
</a><a name="line-1755" data-line="1755">     * Export require as a global, but only if it does not already exist.
</a><a name="line-1756" data-line="1756">     */
</a><a name="line-1757" data-line="1757">    if (!require) {
</a><a name="line-1758" data-line="1758">        require = req;
</a><a name="line-1759" data-line="1759">    }
</a><a name="line-1760" data-line="1760">
</a><a name="line-1761" data-line="1761">    req.version = version;
</a><a name="line-1762" data-line="1762">
</a><a name="line-1763" data-line="1763">    //Used to filter out dependencies that are already paths.
</a><a name="line-1764" data-line="1764">    req.jsExtRegExp = /^\/|:|\?|\.js$/;
</a><a name="line-1765" data-line="1765">    req.isBrowser = isBrowser;
</a><a name="line-1766" data-line="1766">    s = req.s = {
</a><a name="line-1767" data-line="1767">        contexts: contexts,
</a><a name="line-1768" data-line="1768">        newContext: newContext
</a><a name="line-1769" data-line="1769">    };
</a><a name="line-1770" data-line="1770">
</a><a name="line-1771" data-line="1771">    //Create default context.
</a><a name="line-1772" data-line="1772">    req({});
</a><a name="line-1773" data-line="1773">
</a><a name="line-1774" data-line="1774">    //Exports some context-sensitive methods on global require, using
</a><a name="line-1775" data-line="1775">    //default context if no context specified.
</a><a name="line-1776" data-line="1776">    addRequireMethods(req);
</a><a name="line-1777" data-line="1777">
</a><a name="line-1778" data-line="1778">    if (isBrowser) {
</a><a name="line-1779" data-line="1779">        head = s.head = document.getElementsByTagName('head')[0];
</a><a name="line-1780" data-line="1780">        //If BASE tag is in play, using appendChild is a problem for IE6.
</a><a name="line-1781" data-line="1781">        //When that browser dies, this can be removed. Details in this jQuery bug:
</a><a name="line-1782" data-line="1782">        //http://dev.jquery.com/ticket/2709
</a><a name="line-1783" data-line="1783">        baseElement = document.getElementsByTagName('base')[0];
</a><a name="line-1784" data-line="1784">        if (baseElement) {
</a><a name="line-1785" data-line="1785">            head = s.head = baseElement.parentNode;
</a><a name="line-1786" data-line="1786">        }
</a><a name="line-1787" data-line="1787">    }
</a><a name="line-1788" data-line="1788">
</a><a name="line-1789" data-line="1789">    /**
</a><a name="line-1790" data-line="1790">     * Any errors that require explicitly generates will be passed to this
</a><a name="line-1791" data-line="1791">     * function. Intercept/override it if you want custom error handling.
</a><a name="line-1792" data-line="1792">     * @param {Error} err the error object.
</a><a name="line-1793" data-line="1793">     */
</a><a name="line-1794" data-line="1794">    req.onError = function (err) {
</a><a name="line-1795" data-line="1795">        throw err;
</a><a name="line-1796" data-line="1796">    };
</a><a name="line-1797" data-line="1797">
</a><a name="line-1798" data-line="1798">    /**
</a><a name="line-1799" data-line="1799">     * Does the request to load a module for the browser case.
</a><a name="line-1800" data-line="1800">     * Make this a separate function to allow other environments
</a><a name="line-1801" data-line="1801">     * to override it.
</a><a name="line-1802" data-line="1802">     *
</a><a name="line-1803" data-line="1803">     * @param {Object} context the require context to find state.
</a><a name="line-1804" data-line="1804">     * @param {String} moduleName the name of the module.
</a><a name="line-1805" data-line="1805">     * @param {Object} url the URL to the module.
</a><a name="line-1806" data-line="1806">     */
</a><a name="line-1807" data-line="1807">    req.load = function (context, moduleName, url) {
</a><a name="line-1808" data-line="1808">        var config = (context &amp;&amp; context.config) || {},
</a><a name="line-1809" data-line="1809">            node;
</a><a name="line-1810" data-line="1810">        if (isBrowser) {
</a><a name="line-1811" data-line="1811">            //In the browser so use a script tag
</a><a name="line-1812" data-line="1812">            node = config.xhtml ?
</a><a name="line-1813" data-line="1813">                   document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
</a><a name="line-1814" data-line="1814">                   document.createElement('script');
</a><a name="line-1815" data-line="1815">            node.type = config.scriptType || 'text/javascript';
</a><a name="line-1816" data-line="1816">            node.charset = 'utf-8';
</a><a name="line-1817" data-line="1817">            node.async = true;
</a><a name="line-1818" data-line="1818">
</a><a name="line-1819" data-line="1819">            node.setAttribute('data-requirecontext', context.contextName);
</a><a name="line-1820" data-line="1820">            node.setAttribute('data-requiremodule', moduleName);
</a><a name="line-1821" data-line="1821">
</a><a name="line-1822" data-line="1822">            //Set up load listener. Test attachEvent first because IE9 has
</a><a name="line-1823" data-line="1823">            //a subtle issue in its addEventListener and script onload firings
</a><a name="line-1824" data-line="1824">            //that do not match the behavior of all other browsers with
</a><a name="line-1825" data-line="1825">            //addEventListener support, which fire the onload event for a
</a><a name="line-1826" data-line="1826">            //script right after the script execution. See:
</a><a name="line-1827" data-line="1827">            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
</a><a name="line-1828" data-line="1828">            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
</a><a name="line-1829" data-line="1829">            //script execution mode.
</a><a name="line-1830" data-line="1830">            if (node.attachEvent &amp;&amp;
</a><a name="line-1831" data-line="1831">                //Check if node.attachEvent is artificially added by custom script or
</a><a name="line-1832" data-line="1832">                //natively supported by browser
</a><a name="line-1833" data-line="1833">                //read https://github.com/jrburke/requirejs/issues/187
</a><a name="line-1834" data-line="1834">                //if we can NOT find [native code] then it must NOT natively supported.
</a><a name="line-1835" data-line="1835">                //in IE8, node.attachEvent does not have toString()
</a><a name="line-1836" data-line="1836">                //Note the test for &quot;[native code&quot; with no closing brace, see:
</a><a name="line-1837" data-line="1837">                //https://github.com/jrburke/requirejs/issues/273
</a><a name="line-1838" data-line="1838">                !(node.attachEvent.toString &amp;&amp; node.attachEvent.toString().indexOf('[native code') &lt; 0) &amp;&amp;
</a><a name="line-1839" data-line="1839">                !isOpera) {
</a><a name="line-1840" data-line="1840">                //Probably IE. IE (at least 6-8) do not fire
</a><a name="line-1841" data-line="1841">                //script onload right after executing the script, so
</a><a name="line-1842" data-line="1842">                //we cannot tie the anonymous define call to a name.
</a><a name="line-1843" data-line="1843">                //However, IE reports the script as being in 'interactive'
</a><a name="line-1844" data-line="1844">                //readyState at the time of the define call.
</a><a name="line-1845" data-line="1845">                useInteractive = true;
</a><a name="line-1846" data-line="1846">
</a><a name="line-1847" data-line="1847">                node.attachEvent('onreadystatechange', context.onScriptLoad);
</a><a name="line-1848" data-line="1848">                //It would be great to add an error handler here to catch
</a><a name="line-1849" data-line="1849">                //404s in IE9+. However, onreadystatechange will fire before
</a><a name="line-1850" data-line="1850">                //the error handler, so that does not help. If addEvenListener
</a><a name="line-1851" data-line="1851">                //is used, then IE will fire error before load, but we cannot
</a><a name="line-1852" data-line="1852">                //use that pathway given the connect.microsoft.com issue
</a><a name="line-1853" data-line="1853">                //mentioned above about not doing the 'script execute,
</a><a name="line-1854" data-line="1854">                //then fire the script load event listener before execute
</a><a name="line-1855" data-line="1855">                //next script' that other browsers do.
</a><a name="line-1856" data-line="1856">                //Best hope: IE10 fixes the issues,
</a><a name="line-1857" data-line="1857">                //and then destroys all installs of IE 6-9.
</a><a name="line-1858" data-line="1858">                //node.attachEvent('onerror', context.onScriptError);
</a><a name="line-1859" data-line="1859">            } else {
</a><a name="line-1860" data-line="1860">                node.addEventListener('load', context.onScriptLoad, false);
</a><a name="line-1861" data-line="1861">                node.addEventListener('error', context.onScriptError, false);
</a><a name="line-1862" data-line="1862">            }
</a><a name="line-1863" data-line="1863">            node.src = url;
</a><a name="line-1864" data-line="1864">
</a><a name="line-1865" data-line="1865">            //For some cache cases in IE 6-8, the script executes before the end
</a><a name="line-1866" data-line="1866">            //of the appendChild execution, so to tie an anonymous define
</a><a name="line-1867" data-line="1867">            //call to the module name (which is stored on the node), hold on
</a><a name="line-1868" data-line="1868">            //to a reference to this node, but clear after the DOM insertion.
</a><a name="line-1869" data-line="1869">            currentlyAddingScript = node;
</a><a name="line-1870" data-line="1870">            if (baseElement) {
</a><a name="line-1871" data-line="1871">                head.insertBefore(node, baseElement);
</a><a name="line-1872" data-line="1872">            } else {
</a><a name="line-1873" data-line="1873">                head.appendChild(node);
</a><a name="line-1874" data-line="1874">            }
</a><a name="line-1875" data-line="1875">            currentlyAddingScript = null;
</a><a name="line-1876" data-line="1876">
</a><a name="line-1877" data-line="1877">            return node;
</a><a name="line-1878" data-line="1878">        } else if (isWebWorker) {
</a><a name="line-1879" data-line="1879">            //In a web worker, use importScripts. This is not a very
</a><a name="line-1880" data-line="1880">            //efficient use of importScripts, importScripts will block until
</a><a name="line-1881" data-line="1881">            //its script is downloaded and evaluated. However, if web workers
</a><a name="line-1882" data-line="1882">            //are in play, the expectation that a build has been done so that
</a><a name="line-1883" data-line="1883">            //only one script needs to be loaded anyway. This may need to be
</a><a name="line-1884" data-line="1884">            //reevaluated if other use cases become common.
</a><a name="line-1885" data-line="1885">            importScripts(url);
</a><a name="line-1886" data-line="1886">
</a><a name="line-1887" data-line="1887">            //Account for anonymous modules
</a><a name="line-1888" data-line="1888">            context.completeLoad(moduleName);
</a><a name="line-1889" data-line="1889">        }
</a><a name="line-1890" data-line="1890">    };
</a><a name="line-1891" data-line="1891">
</a><a name="line-1892" data-line="1892">    function getInteractiveScript() {
</a><a name="line-1893" data-line="1893">        if (interactiveScript &amp;&amp; interactiveScript.readyState === 'interactive') {
</a><a name="line-1894" data-line="1894">            return interactiveScript;
</a><a name="line-1895" data-line="1895">        }
</a><a name="line-1896" data-line="1896">
</a><a name="line-1897" data-line="1897">        eachReverse(scripts(), function (script) {
</a><a name="line-1898" data-line="1898">            if (script.readyState === 'interactive') {
</a><a name="line-1899" data-line="1899">                return (interactiveScript = script);
</a><a name="line-1900" data-line="1900">            }
</a><a name="line-1901" data-line="1901">        });
</a><a name="line-1902" data-line="1902">        return interactiveScript;
</a><a name="line-1903" data-line="1903">    }
</a><a name="line-1904" data-line="1904">
</a><a name="line-1905" data-line="1905">    //Look for a data-main script attribute, which could also adjust the baseUrl.
</a><a name="line-1906" data-line="1906">    if (isBrowser) {
</a><a name="line-1907" data-line="1907">        //Figure out baseUrl. Get it from the script tag with require.js in it.
</a><a name="line-1908" data-line="1908">        eachReverse(scripts(), function (script) {
</a><a name="line-1909" data-line="1909">            //Set the 'head' where we can append children by
</a><a name="line-1910" data-line="1910">            //using the script's parent.
</a><a name="line-1911" data-line="1911">            if (!head) {
</a><a name="line-1912" data-line="1912">                head = script.parentNode;
</a><a name="line-1913" data-line="1913">            }
</a><a name="line-1914" data-line="1914">
</a><a name="line-1915" data-line="1915">            //Look for a data-main attribute to set main script for the page
</a><a name="line-1916" data-line="1916">            //to load. If it is there, the path to data main becomes the
</a><a name="line-1917" data-line="1917">            //baseUrl, if it is not already set.
</a><a name="line-1918" data-line="1918">            dataMain = script.getAttribute('data-main');
</a><a name="line-1919" data-line="1919">            if (dataMain) {
</a><a name="line-1920" data-line="1920">                //Set final baseUrl if there is not already an explicit one.
</a><a name="line-1921" data-line="1921">                if (!cfg.baseUrl) {
</a><a name="line-1922" data-line="1922">                    //Pull off the directory of data-main for use as the
</a><a name="line-1923" data-line="1923">                    //baseUrl.
</a><a name="line-1924" data-line="1924">                    src = dataMain.split('/');
</a><a name="line-1925" data-line="1925">                    mainScript = src.pop();
</a><a name="line-1926" data-line="1926">                    subPath = src.length ? src.join('/')  + '/' : './';
</a><a name="line-1927" data-line="1927">
</a><a name="line-1928" data-line="1928">                    cfg.baseUrl = subPath;
</a><a name="line-1929" data-line="1929">                    dataMain = mainScript;
</a><a name="line-1930" data-line="1930">                }
</a><a name="line-1931" data-line="1931">
</a><a name="line-1932" data-line="1932">                //Strip off any trailing .js since dataMain is now
</a><a name="line-1933" data-line="1933">                //like a module name.
</a><a name="line-1934" data-line="1934">                dataMain = dataMain.replace(jsSuffixRegExp, '');
</a><a name="line-1935" data-line="1935">
</a><a name="line-1936" data-line="1936">                //Put the data-main script in the files to load.
</a><a name="line-1937" data-line="1937">                cfg.deps = cfg.deps ? cfg.deps.concat(dataMain) : [dataMain];
</a><a name="line-1938" data-line="1938">
</a><a name="line-1939" data-line="1939">                return true;
</a><a name="line-1940" data-line="1940">            }
</a><a name="line-1941" data-line="1941">        });
</a><a name="line-1942" data-line="1942">    }
</a><a name="line-1943" data-line="1943">
</a><a name="line-1944" data-line="1944">    /**
</a><a name="line-1945" data-line="1945">     * The function that handles definitions of modules. Differs from
</a><a name="line-1946" data-line="1946">     * require() in that a string for the module should be the first argument,
</a><a name="line-1947" data-line="1947">     * and the function to execute after dependencies are loaded should
</a><a name="line-1948" data-line="1948">     * return a value to define the module corresponding to the first argument's
</a><a name="line-1949" data-line="1949">     * name.
</a><a name="line-1950" data-line="1950">     */
</a><a name="line-1951" data-line="1951">    define = function (name, deps, callback) {
</a><a name="line-1952" data-line="1952">        var node, context;
</a><a name="line-1953" data-line="1953">
</a><a name="line-1954" data-line="1954">        //Allow for anonymous functions
</a><a name="line-1955" data-line="1955">        if (typeof name !== 'string') {
</a><a name="line-1956" data-line="1956">            //Adjust args appropriately
</a><a name="line-1957" data-line="1957">            callback = deps;
</a><a name="line-1958" data-line="1958">            deps = name;
</a><a name="line-1959" data-line="1959">            name = null;
</a><a name="line-1960" data-line="1960">        }
</a><a name="line-1961" data-line="1961">
</a><a name="line-1962" data-line="1962">        //This module may not have dependencies
</a><a name="line-1963" data-line="1963">        if (!isArray(deps)) {
</a><a name="line-1964" data-line="1964">            callback = deps;
</a><a name="line-1965" data-line="1965">            deps = [];
</a><a name="line-1966" data-line="1966">        }
</a><a name="line-1967" data-line="1967">
</a><a name="line-1968" data-line="1968">        //If no name, and callback is a function, then figure out if it a
</a><a name="line-1969" data-line="1969">        //CommonJS thing with dependencies.
</a><a name="line-1970" data-line="1970">        if (!deps.length &amp;&amp; isFunction(callback)) {
</a><a name="line-1971" data-line="1971">            //Remove comments from the callback string,
</a><a name="line-1972" data-line="1972">            //look for require calls, and pull them into the dependencies,
</a><a name="line-1973" data-line="1973">            //but only if there are function args.
</a><a name="line-1974" data-line="1974">            if (callback.length) {
</a><a name="line-1975" data-line="1975">                callback
</a><a name="line-1976" data-line="1976">                    .toString()
</a><a name="line-1977" data-line="1977">                    .replace(commentRegExp, '')
</a><a name="line-1978" data-line="1978">                    .replace(cjsRequireRegExp, function (match, dep) {
</a><a name="line-1979" data-line="1979">                        deps.push(dep);
</a><a name="line-1980" data-line="1980">                    });
</a><a name="line-1981" data-line="1981">
</a><a name="line-1982" data-line="1982">                //May be a CommonJS thing even without require calls, but still
</a><a name="line-1983" data-line="1983">                //could use exports, and module. Avoid doing exports and module
</a><a name="line-1984" data-line="1984">                //work though if it just needs require.
</a><a name="line-1985" data-line="1985">                //REQUIRES the function to expect the CommonJS variables in the
</a><a name="line-1986" data-line="1986">                //order listed below.
</a><a name="line-1987" data-line="1987">                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
</a><a name="line-1988" data-line="1988">            }
</a><a name="line-1989" data-line="1989">        }
</a><a name="line-1990" data-line="1990">
</a><a name="line-1991" data-line="1991">        //If in IE 6-8 and hit an anonymous define() call, do the interactive
</a><a name="line-1992" data-line="1992">        //work.
</a><a name="line-1993" data-line="1993">        if (useInteractive) {
</a><a name="line-1994" data-line="1994">            node = currentlyAddingScript || getInteractiveScript();
</a><a name="line-1995" data-line="1995">            if (node) {
</a><a name="line-1996" data-line="1996">                if (!name) {
</a><a name="line-1997" data-line="1997">                    name = node.getAttribute('data-requiremodule');
</a><a name="line-1998" data-line="1998">                }
</a><a name="line-1999" data-line="1999">                context = contexts[node.getAttribute('data-requirecontext')];
</a><a name="line-2000" data-line="2000">            }
</a><a name="line-2001" data-line="2001">        }
</a><a name="line-2002" data-line="2002">
</a><a name="line-2003" data-line="2003">        //Always save off evaluating the def call until the script onload handler.
</a><a name="line-2004" data-line="2004">        //This allows multiple modules to be in a file without prematurely
</a><a name="line-2005" data-line="2005">        //tracing dependencies, and allows for anonymous module support,
</a><a name="line-2006" data-line="2006">        //where the module name is not known until the script onload event
</a><a name="line-2007" data-line="2007">        //occurs. If no context, use the global queue, and get it processed
</a><a name="line-2008" data-line="2008">        //in the onscript load callback.
</a><a name="line-2009" data-line="2009">        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
</a><a name="line-2010" data-line="2010">    };
</a><a name="line-2011" data-line="2011">
</a><a name="line-2012" data-line="2012">    define.amd = {
</a><a name="line-2013" data-line="2013">        jQuery: true
</a><a name="line-2014" data-line="2014">    };
</a><a name="line-2015" data-line="2015">
</a><a name="line-2016" data-line="2016">
</a><a name="line-2017" data-line="2017">    /**
</a><a name="line-2018" data-line="2018">     * Executes the text. Normally just uses eval, but can be modified
</a><a name="line-2019" data-line="2019">     * to use a better, environment-specific call. Only used for transpiling
</a><a name="line-2020" data-line="2020">     * loader plugins, not for plain JS modules.
</a><a name="line-2021" data-line="2021">     * @param {String} text the text to execute/evaluate.
</a><a name="line-2022" data-line="2022">     */
</a><a name="line-2023" data-line="2023">    req.exec = function (text) {
</a><a name="line-2024" data-line="2024">        /*jslint evil: true */
</a><a name="line-2025" data-line="2025">        return eval(text);
</a><a name="line-2026" data-line="2026">    };
</a><a name="line-2027" data-line="2027">
</a><a name="line-2028" data-line="2028">    //Set up with config info.
</a><a name="line-2029" data-line="2029">    req(cfg);
</a><a name="line-2030" data-line="2030">}(this));
</a><a name="line-2031" data-line="2031">/*!
</a><a name="line-2032" data-line="2032"> * jQuery JavaScript Library v1.7.2
</a><a name="line-2033" data-line="2033"> * http://jquery.com/
</a><a name="line-2034" data-line="2034"> *
</a><a name="line-2035" data-line="2035"> * Copyright 2011, John Resig
</a><a name="line-2036" data-line="2036"> * Dual licensed under the MIT or GPL Version 2 licenses.
</a><a name="line-2037" data-line="2037"> * http://jquery.org/license
</a><a name="line-2038" data-line="2038"> *
</a><a name="line-2039" data-line="2039"> * Includes Sizzle.js
</a><a name="line-2040" data-line="2040"> * http://sizzlejs.com/
</a><a name="line-2041" data-line="2041"> * Copyright 2011, The Dojo Foundation
</a><a name="line-2042" data-line="2042"> * Released under the MIT, BSD, and GPL Licenses.
</a><a name="line-2043" data-line="2043"> *
</a><a name="line-2044" data-line="2044"> * Date: Wed Mar 21 12:46:34 2012 -0700
</a><a name="line-2045" data-line="2045"> */
</a><a name="line-2046" data-line="2046">(function( window, undefined ) {
</a><a name="line-2047" data-line="2047">
</a><a name="line-2048" data-line="2048">// Use the correct document accordingly with window argument (sandbox)
</a><a name="line-2049" data-line="2049">var document = window.document,
</a><a name="line-2050" data-line="2050">	navigator = window.navigator,
</a><a name="line-2051" data-line="2051">	location = window.location;
</a><a name="line-2052" data-line="2052">var jQuery = (function() {
</a><a name="line-2053" data-line="2053">
</a><a name="line-2054" data-line="2054">// Define a local copy of jQuery
</a><a name="line-2055" data-line="2055">var jQuery = function( selector, context ) {
</a><a name="line-2056" data-line="2056">		// The jQuery object is actually just the init constructor 'enhanced'
</a><a name="line-2057" data-line="2057">		return new jQuery.fn.init( selector, context, rootjQuery );
</a><a name="line-2058" data-line="2058">	},
</a><a name="line-2059" data-line="2059">
</a><a name="line-2060" data-line="2060">	// Map over jQuery in case of overwrite
</a><a name="line-2061" data-line="2061">	_jQuery = window.jQuery,
</a><a name="line-2062" data-line="2062">
</a><a name="line-2063" data-line="2063">	// Map over the $ in case of overwrite
</a><a name="line-2064" data-line="2064">	_$ = window.$,
</a><a name="line-2065" data-line="2065">
</a><a name="line-2066" data-line="2066">	// A central reference to the root jQuery(document)
</a><a name="line-2067" data-line="2067">	rootjQuery,
</a><a name="line-2068" data-line="2068">
</a><a name="line-2069" data-line="2069">	// A simple way to check for HTML strings or ID strings
</a><a name="line-2070" data-line="2070">	// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
</a><a name="line-2071" data-line="2071">	quickExpr = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/,
</a><a name="line-2072" data-line="2072">
</a><a name="line-2073" data-line="2073">	// Check if a string has a non-whitespace character in it
</a><a name="line-2074" data-line="2074">	rnotwhite = /\S/,
</a><a name="line-2075" data-line="2075">
</a><a name="line-2076" data-line="2076">	// Used for trimming whitespace
</a><a name="line-2077" data-line="2077">	trimLeft = /^\s+/,
</a><a name="line-2078" data-line="2078">	trimRight = /\s+$/,
</a><a name="line-2079" data-line="2079">
</a><a name="line-2080" data-line="2080">	// Match a standalone tag
</a><a name="line-2081" data-line="2081">	rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;)?$/,
</a><a name="line-2082" data-line="2082">
</a><a name="line-2083" data-line="2083">	// JSON RegExp
</a><a name="line-2084" data-line="2084">	rvalidchars = /^[\],:{}\s]*$/,
</a><a name="line-2085" data-line="2085">	rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
</a><a name="line-2086" data-line="2086">	rvalidtokens = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
</a><a name="line-2087" data-line="2087">	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
</a><a name="line-2088" data-line="2088">
</a><a name="line-2089" data-line="2089">	// Useragent RegExp
</a><a name="line-2090" data-line="2090">	rwebkit = /(webkit)[ \/]([\w.]+)/,
</a><a name="line-2091" data-line="2091">	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
</a><a name="line-2092" data-line="2092">	rmsie = /(msie) ([\w.]+)/,
</a><a name="line-2093" data-line="2093">	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,
</a><a name="line-2094" data-line="2094">
</a><a name="line-2095" data-line="2095">	// Matches dashed string for camelizing
</a><a name="line-2096" data-line="2096">	rdashAlpha = /-([a-z]|[0-9])/ig,
</a><a name="line-2097" data-line="2097">	rmsPrefix = /^-ms-/,
</a><a name="line-2098" data-line="2098">
</a><a name="line-2099" data-line="2099">	// Used by jQuery.camelCase as callback to replace()
</a><a name="line-2100" data-line="2100">	fcamelCase = function( all, letter ) {
</a><a name="line-2101" data-line="2101">		return ( letter + &quot;&quot; ).toUpperCase();
</a><a name="line-2102" data-line="2102">	},
</a><a name="line-2103" data-line="2103">
</a><a name="line-2104" data-line="2104">	// Keep a UserAgent string for use with jQuery.browser
</a><a name="line-2105" data-line="2105">	userAgent = navigator.userAgent,
</a><a name="line-2106" data-line="2106">
</a><a name="line-2107" data-line="2107">	// For matching the engine and version of the browser
</a><a name="line-2108" data-line="2108">	browserMatch,
</a><a name="line-2109" data-line="2109">
</a><a name="line-2110" data-line="2110">	// The deferred used on DOM ready
</a><a name="line-2111" data-line="2111">	readyList,
</a><a name="line-2112" data-line="2112">
</a><a name="line-2113" data-line="2113">	// The ready event handler
</a><a name="line-2114" data-line="2114">	DOMContentLoaded,
</a><a name="line-2115" data-line="2115">
</a><a name="line-2116" data-line="2116">	// Save a reference to some core methods
</a><a name="line-2117" data-line="2117">	toString = Object.prototype.toString,
</a><a name="line-2118" data-line="2118">	hasOwn = Object.prototype.hasOwnProperty,
</a><a name="line-2119" data-line="2119">	push = Array.prototype.push,
</a><a name="line-2120" data-line="2120">	slice = Array.prototype.slice,
</a><a name="line-2121" data-line="2121">	trim = String.prototype.trim,
</a><a name="line-2122" data-line="2122">	indexOf = Array.prototype.indexOf,
</a><a name="line-2123" data-line="2123">
</a><a name="line-2124" data-line="2124">	// [[Class]] -&gt; type pairs
</a><a name="line-2125" data-line="2125">	class2type = {};
</a><a name="line-2126" data-line="2126">
</a><a name="line-2127" data-line="2127">jQuery.fn = jQuery.prototype = {
</a><a name="line-2128" data-line="2128">	constructor: jQuery,
</a><a name="line-2129" data-line="2129">	init: function( selector, context, rootjQuery ) {
</a><a name="line-2130" data-line="2130">		var match, elem, ret, doc;
</a><a name="line-2131" data-line="2131">
</a><a name="line-2132" data-line="2132">		// Handle $(&quot;&quot;), $(null), or $(undefined)
</a><a name="line-2133" data-line="2133">		if ( !selector ) {
</a><a name="line-2134" data-line="2134">			return this;
</a><a name="line-2135" data-line="2135">		}
</a><a name="line-2136" data-line="2136">
</a><a name="line-2137" data-line="2137">		// Handle $(DOMElement)
</a><a name="line-2138" data-line="2138">		if ( selector.nodeType ) {
</a><a name="line-2139" data-line="2139">			this.context = this[0] = selector;
</a><a name="line-2140" data-line="2140">			this.length = 1;
</a><a name="line-2141" data-line="2141">			return this;
</a><a name="line-2142" data-line="2142">		}
</a><a name="line-2143" data-line="2143">
</a><a name="line-2144" data-line="2144">		// The body element only exists once, optimize finding it
</a><a name="line-2145" data-line="2145">		if ( selector === &quot;body&quot; &amp;&amp; !context &amp;&amp; document.body ) {
</a><a name="line-2146" data-line="2146">			this.context = document;
</a><a name="line-2147" data-line="2147">			this[0] = document.body;
</a><a name="line-2148" data-line="2148">			this.selector = selector;
</a><a name="line-2149" data-line="2149">			this.length = 1;
</a><a name="line-2150" data-line="2150">			return this;
</a><a name="line-2151" data-line="2151">		}
</a><a name="line-2152" data-line="2152">
</a><a name="line-2153" data-line="2153">		// Handle HTML strings
</a><a name="line-2154" data-line="2154">		if ( typeof selector === &quot;string&quot; ) {
</a><a name="line-2155" data-line="2155">			// Are we dealing with HTML string or an ID?
</a><a name="line-2156" data-line="2156">			if ( selector.charAt(0) === &quot;&lt;&quot; &amp;&amp; selector.charAt( selector.length - 1 ) === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) {
</a><a name="line-2157" data-line="2157">				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
</a><a name="line-2158" data-line="2158">				match = [ null, selector, null ];
</a><a name="line-2159" data-line="2159">
</a><a name="line-2160" data-line="2160">			} else {
</a><a name="line-2161" data-line="2161">				match = quickExpr.exec( selector );
</a><a name="line-2162" data-line="2162">			}
</a><a name="line-2163" data-line="2163">
</a><a name="line-2164" data-line="2164">			// Verify a match, and that no context was specified for #id
</a><a name="line-2165" data-line="2165">			if ( match &amp;&amp; (match[1] || !context) ) {
</a><a name="line-2166" data-line="2166">
</a><a name="line-2167" data-line="2167">				// HANDLE: $(html) -&gt; $(array)
</a><a name="line-2168" data-line="2168">				if ( match[1] ) {
</a><a name="line-2169" data-line="2169">					context = context instanceof jQuery ? context[0] : context;
</a><a name="line-2170" data-line="2170">					doc = ( context ? context.ownerDocument || context : document );
</a><a name="line-2171" data-line="2171">
</a><a name="line-2172" data-line="2172">					// If a single string is passed in and it's a single tag
</a><a name="line-2173" data-line="2173">					// just do a createElement and skip the rest
</a><a name="line-2174" data-line="2174">					ret = rsingleTag.exec( selector );
</a><a name="line-2175" data-line="2175">
</a><a name="line-2176" data-line="2176">					if ( ret ) {
</a><a name="line-2177" data-line="2177">						if ( jQuery.isPlainObject( context ) ) {
</a><a name="line-2178" data-line="2178">							selector = [ document.createElement( ret[1] ) ];
</a><a name="line-2179" data-line="2179">							jQuery.fn.attr.call( selector, context, true );
</a><a name="line-2180" data-line="2180">
</a><a name="line-2181" data-line="2181">						} else {
</a><a name="line-2182" data-line="2182">							selector = [ doc.createElement( ret[1] ) ];
</a><a name="line-2183" data-line="2183">						}
</a><a name="line-2184" data-line="2184">
</a><a name="line-2185" data-line="2185">					} else {
</a><a name="line-2186" data-line="2186">						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
</a><a name="line-2187" data-line="2187">						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
</a><a name="line-2188" data-line="2188">					}
</a><a name="line-2189" data-line="2189">
</a><a name="line-2190" data-line="2190">					return jQuery.merge( this, selector );
</a><a name="line-2191" data-line="2191">
</a><a name="line-2192" data-line="2192">				// HANDLE: $(&quot;#id&quot;)
</a><a name="line-2193" data-line="2193">				} else {
</a><a name="line-2194" data-line="2194">					elem = document.getElementById( match[2] );
</a><a name="line-2195" data-line="2195">
</a><a name="line-2196" data-line="2196">					// Check parentNode to catch when Blackberry 4.6 returns
</a><a name="line-2197" data-line="2197">					// nodes that are no longer in the document #6963
</a><a name="line-2198" data-line="2198">					if ( elem &amp;&amp; elem.parentNode ) {
</a><a name="line-2199" data-line="2199">						// Handle the case where IE and Opera return items
</a><a name="line-2200" data-line="2200">						// by name instead of ID
</a><a name="line-2201" data-line="2201">						if ( elem.id !== match[2] ) {
</a><a name="line-2202" data-line="2202">							return rootjQuery.find( selector );
</a><a name="line-2203" data-line="2203">						}
</a><a name="line-2204" data-line="2204">
</a><a name="line-2205" data-line="2205">						// Otherwise, we inject the element directly into the jQuery object
</a><a name="line-2206" data-line="2206">						this.length = 1;
</a><a name="line-2207" data-line="2207">						this[0] = elem;
</a><a name="line-2208" data-line="2208">					}
</a><a name="line-2209" data-line="2209">
</a><a name="line-2210" data-line="2210">					this.context = document;
</a><a name="line-2211" data-line="2211">					this.selector = selector;
</a><a name="line-2212" data-line="2212">					return this;
</a><a name="line-2213" data-line="2213">				}
</a><a name="line-2214" data-line="2214">
</a><a name="line-2215" data-line="2215">			// HANDLE: $(expr, $(...))
</a><a name="line-2216" data-line="2216">			} else if ( !context || context.jquery ) {
</a><a name="line-2217" data-line="2217">				return ( context || rootjQuery ).find( selector );
</a><a name="line-2218" data-line="2218">
</a><a name="line-2219" data-line="2219">			// HANDLE: $(expr, context)
</a><a name="line-2220" data-line="2220">			// (which is just equivalent to: $(context).find(expr)
</a><a name="line-2221" data-line="2221">			} else {
</a><a name="line-2222" data-line="2222">				return this.constructor( context ).find( selector );
</a><a name="line-2223" data-line="2223">			}
</a><a name="line-2224" data-line="2224">
</a><a name="line-2225" data-line="2225">		// HANDLE: $(function)
</a><a name="line-2226" data-line="2226">		// Shortcut for document ready
</a><a name="line-2227" data-line="2227">		} else if ( jQuery.isFunction( selector ) ) {
</a><a name="line-2228" data-line="2228">			return rootjQuery.ready( selector );
</a><a name="line-2229" data-line="2229">		}
</a><a name="line-2230" data-line="2230">
</a><a name="line-2231" data-line="2231">		if ( selector.selector !== undefined ) {
</a><a name="line-2232" data-line="2232">			this.selector = selector.selector;
</a><a name="line-2233" data-line="2233">			this.context = selector.context;
</a><a name="line-2234" data-line="2234">		}
</a><a name="line-2235" data-line="2235">
</a><a name="line-2236" data-line="2236">		return jQuery.makeArray( selector, this );
</a><a name="line-2237" data-line="2237">	},
</a><a name="line-2238" data-line="2238">
</a><a name="line-2239" data-line="2239">	// Start with an empty selector
</a><a name="line-2240" data-line="2240">	selector: &quot;&quot;,
</a><a name="line-2241" data-line="2241">
</a><a name="line-2242" data-line="2242">	// The current version of jQuery being used
</a><a name="line-2243" data-line="2243">	jquery: &quot;1.7.2&quot;,
</a><a name="line-2244" data-line="2244">
</a><a name="line-2245" data-line="2245">	// The default length of a jQuery object is 0
</a><a name="line-2246" data-line="2246">	length: 0,
</a><a name="line-2247" data-line="2247">
</a><a name="line-2248" data-line="2248">	// The number of elements contained in the matched element set
</a><a name="line-2249" data-line="2249">	size: function() {
</a><a name="line-2250" data-line="2250">		return this.length;
</a><a name="line-2251" data-line="2251">	},
</a><a name="line-2252" data-line="2252">
</a><a name="line-2253" data-line="2253">	toArray: function() {
</a><a name="line-2254" data-line="2254">		return slice.call( this, 0 );
</a><a name="line-2255" data-line="2255">	},
</a><a name="line-2256" data-line="2256">
</a><a name="line-2257" data-line="2257">	// Get the Nth element in the matched element set OR
</a><a name="line-2258" data-line="2258">	// Get the whole matched element set as a clean array
</a><a name="line-2259" data-line="2259">	get: function( num ) {
</a><a name="line-2260" data-line="2260">		return num == null ?
</a><a name="line-2261" data-line="2261">
</a><a name="line-2262" data-line="2262">			// Return a 'clean' array
</a><a name="line-2263" data-line="2263">			this.toArray() :
</a><a name="line-2264" data-line="2264">
</a><a name="line-2265" data-line="2265">			// Return just the object
</a><a name="line-2266" data-line="2266">			( num &lt; 0 ? this[ this.length + num ] : this[ num ] );
</a><a name="line-2267" data-line="2267">	},
</a><a name="line-2268" data-line="2268">
</a><a name="line-2269" data-line="2269">	// Take an array of elements and push it onto the stack
</a><a name="line-2270" data-line="2270">	// (returning the new matched element set)
</a><a name="line-2271" data-line="2271">	pushStack: function( elems, name, selector ) {
</a><a name="line-2272" data-line="2272">		// Build a new jQuery matched element set
</a><a name="line-2273" data-line="2273">		var ret = this.constructor();
</a><a name="line-2274" data-line="2274">
</a><a name="line-2275" data-line="2275">		if ( jQuery.isArray( elems ) ) {
</a><a name="line-2276" data-line="2276">			push.apply( ret, elems );
</a><a name="line-2277" data-line="2277">
</a><a name="line-2278" data-line="2278">		} else {
</a><a name="line-2279" data-line="2279">			jQuery.merge( ret, elems );
</a><a name="line-2280" data-line="2280">		}
</a><a name="line-2281" data-line="2281">
</a><a name="line-2282" data-line="2282">		// Add the old object onto the stack (as a reference)
</a><a name="line-2283" data-line="2283">		ret.prevObject = this;
</a><a name="line-2284" data-line="2284">
</a><a name="line-2285" data-line="2285">		ret.context = this.context;
</a><a name="line-2286" data-line="2286">
</a><a name="line-2287" data-line="2287">		if ( name === &quot;find&quot; ) {
</a><a name="line-2288" data-line="2288">			ret.selector = this.selector + ( this.selector ? &quot; &quot; : &quot;&quot; ) + selector;
</a><a name="line-2289" data-line="2289">		} else if ( name ) {
</a><a name="line-2290" data-line="2290">			ret.selector = this.selector + &quot;.&quot; + name + &quot;(&quot; + selector + &quot;)&quot;;
</a><a name="line-2291" data-line="2291">		}
</a><a name="line-2292" data-line="2292">
</a><a name="line-2293" data-line="2293">		// Return the newly-formed element set
</a><a name="line-2294" data-line="2294">		return ret;
</a><a name="line-2295" data-line="2295">	},
</a><a name="line-2296" data-line="2296">
</a><a name="line-2297" data-line="2297">	// Execute a callback for every element in the matched set.
</a><a name="line-2298" data-line="2298">	// (You can seed the arguments with an array of args, but this is
</a><a name="line-2299" data-line="2299">	// only used internally.)
</a><a name="line-2300" data-line="2300">	each: function( callback, args ) {
</a><a name="line-2301" data-line="2301">		return jQuery.each( this, callback, args );
</a><a name="line-2302" data-line="2302">	},
</a><a name="line-2303" data-line="2303">
</a><a name="line-2304" data-line="2304">	ready: function( fn ) {
</a><a name="line-2305" data-line="2305">		// Attach the listeners
</a><a name="line-2306" data-line="2306">		jQuery.bindReady();
</a><a name="line-2307" data-line="2307">
</a><a name="line-2308" data-line="2308">		// Add the callback
</a><a name="line-2309" data-line="2309">		readyList.add( fn );
</a><a name="line-2310" data-line="2310">
</a><a name="line-2311" data-line="2311">		return this;
</a><a name="line-2312" data-line="2312">	},
</a><a name="line-2313" data-line="2313">
</a><a name="line-2314" data-line="2314">	eq: function( i ) {
</a><a name="line-2315" data-line="2315">		i = +i;
</a><a name="line-2316" data-line="2316">		return i === -1 ?
</a><a name="line-2317" data-line="2317">			this.slice( i ) :
</a><a name="line-2318" data-line="2318">			this.slice( i, i + 1 );
</a><a name="line-2319" data-line="2319">	},
</a><a name="line-2320" data-line="2320">
</a><a name="line-2321" data-line="2321">	first: function() {
</a><a name="line-2322" data-line="2322">		return this.eq( 0 );
</a><a name="line-2323" data-line="2323">	},
</a><a name="line-2324" data-line="2324">
</a><a name="line-2325" data-line="2325">	last: function() {
</a><a name="line-2326" data-line="2326">		return this.eq( -1 );
</a><a name="line-2327" data-line="2327">	},
</a><a name="line-2328" data-line="2328">
</a><a name="line-2329" data-line="2329">	slice: function() {
</a><a name="line-2330" data-line="2330">		return this.pushStack( slice.apply( this, arguments ),
</a><a name="line-2331" data-line="2331">			&quot;slice&quot;, slice.call(arguments).join(&quot;,&quot;) );
</a><a name="line-2332" data-line="2332">	},
</a><a name="line-2333" data-line="2333">
</a><a name="line-2334" data-line="2334">	map: function( callback ) {
</a><a name="line-2335" data-line="2335">		return this.pushStack( jQuery.map(this, function( elem, i ) {
</a><a name="line-2336" data-line="2336">			return callback.call( elem, i, elem );
</a><a name="line-2337" data-line="2337">		}));
</a><a name="line-2338" data-line="2338">	},
</a><a name="line-2339" data-line="2339">
</a><a name="line-2340" data-line="2340">	end: function() {
</a><a name="line-2341" data-line="2341">		return this.prevObject || this.constructor(null);
</a><a name="line-2342" data-line="2342">	},
</a><a name="line-2343" data-line="2343">
</a><a name="line-2344" data-line="2344">	// For internal use only.
</a><a name="line-2345" data-line="2345">	// Behaves like an Array's method, not like a jQuery method.
</a><a name="line-2346" data-line="2346">	push: push,
</a><a name="line-2347" data-line="2347">	sort: [].sort,
</a><a name="line-2348" data-line="2348">	splice: [].splice
</a><a name="line-2349" data-line="2349">};
</a><a name="line-2350" data-line="2350">
</a><a name="line-2351" data-line="2351">// Give the init function the jQuery prototype for later instantiation
</a><a name="line-2352" data-line="2352">jQuery.fn.init.prototype = jQuery.fn;
</a><a name="line-2353" data-line="2353">
</a><a name="line-2354" data-line="2354">jQuery.extend = jQuery.fn.extend = function() {
</a><a name="line-2355" data-line="2355">	var options, name, src, copy, copyIsArray, clone,
</a><a name="line-2356" data-line="2356">		target = arguments[0] || {},
</a><a name="line-2357" data-line="2357">		i = 1,
</a><a name="line-2358" data-line="2358">		length = arguments.length,
</a><a name="line-2359" data-line="2359">		deep = false;
</a><a name="line-2360" data-line="2360">
</a><a name="line-2361" data-line="2361">	// Handle a deep copy situation
</a><a name="line-2362" data-line="2362">	if ( typeof target === &quot;boolean&quot; ) {
</a><a name="line-2363" data-line="2363">		deep = target;
</a><a name="line-2364" data-line="2364">		target = arguments[1] || {};
</a><a name="line-2365" data-line="2365">		// skip the boolean and the target
</a><a name="line-2366" data-line="2366">		i = 2;
</a><a name="line-2367" data-line="2367">	}
</a><a name="line-2368" data-line="2368">
</a><a name="line-2369" data-line="2369">	// Handle case when target is a string or something (possible in deep copy)
</a><a name="line-2370" data-line="2370">	if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) {
</a><a name="line-2371" data-line="2371">		target = {};
</a><a name="line-2372" data-line="2372">	}
</a><a name="line-2373" data-line="2373">
</a><a name="line-2374" data-line="2374">	// extend jQuery itself if only one argument is passed
</a><a name="line-2375" data-line="2375">	if ( length === i ) {
</a><a name="line-2376" data-line="2376">		target = this;
</a><a name="line-2377" data-line="2377">		--i;
</a><a name="line-2378" data-line="2378">	}
</a><a name="line-2379" data-line="2379">
</a><a name="line-2380" data-line="2380">	for ( ; i &lt; length; i++ ) {
</a><a name="line-2381" data-line="2381">		// Only deal with non-null/undefined values
</a><a name="line-2382" data-line="2382">		if ( (options = arguments[ i ]) != null ) {
</a><a name="line-2383" data-line="2383">			// Extend the base object
</a><a name="line-2384" data-line="2384">			for ( name in options ) {
</a><a name="line-2385" data-line="2385">				src = target[ name ];
</a><a name="line-2386" data-line="2386">				copy = options[ name ];
</a><a name="line-2387" data-line="2387">
</a><a name="line-2388" data-line="2388">				// Prevent never-ending loop
</a><a name="line-2389" data-line="2389">				if ( target === copy ) {
</a><a name="line-2390" data-line="2390">					continue;
</a><a name="line-2391" data-line="2391">				}
</a><a name="line-2392" data-line="2392">
</a><a name="line-2393" data-line="2393">				// Recurse if we're merging plain objects or arrays
</a><a name="line-2394" data-line="2394">				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
</a><a name="line-2395" data-line="2395">					if ( copyIsArray ) {
</a><a name="line-2396" data-line="2396">						copyIsArray = false;
</a><a name="line-2397" data-line="2397">						clone = src &amp;&amp; jQuery.isArray(src) ? src : [];
</a><a name="line-2398" data-line="2398">
</a><a name="line-2399" data-line="2399">					} else {
</a><a name="line-2400" data-line="2400">						clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
</a><a name="line-2401" data-line="2401">					}
</a><a name="line-2402" data-line="2402">
</a><a name="line-2403" data-line="2403">					// Never move original objects, clone them
</a><a name="line-2404" data-line="2404">					target[ name ] = jQuery.extend( deep, clone, copy );
</a><a name="line-2405" data-line="2405">
</a><a name="line-2406" data-line="2406">				// Don't bring in undefined values
</a><a name="line-2407" data-line="2407">				} else if ( copy !== undefined ) {
</a><a name="line-2408" data-line="2408">					target[ name ] = copy;
</a><a name="line-2409" data-line="2409">				}
</a><a name="line-2410" data-line="2410">			}
</a><a name="line-2411" data-line="2411">		}
</a><a name="line-2412" data-line="2412">	}
</a><a name="line-2413" data-line="2413">
</a><a name="line-2414" data-line="2414">	// Return the modified object
</a><a name="line-2415" data-line="2415">	return target;
</a><a name="line-2416" data-line="2416">};
</a><a name="line-2417" data-line="2417">
</a><a name="line-2418" data-line="2418">jQuery.extend({
</a><a name="line-2419" data-line="2419">	noConflict: function( deep ) {
</a><a name="line-2420" data-line="2420">		if ( window.$ === jQuery ) {
</a><a name="line-2421" data-line="2421">			window.$ = _$;
</a><a name="line-2422" data-line="2422">		}
</a><a name="line-2423" data-line="2423">
</a><a name="line-2424" data-line="2424">		if ( deep &amp;&amp; window.jQuery === jQuery ) {
</a><a name="line-2425" data-line="2425">			window.jQuery = _jQuery;
</a><a name="line-2426" data-line="2426">		}
</a><a name="line-2427" data-line="2427">
</a><a name="line-2428" data-line="2428">		return jQuery;
</a><a name="line-2429" data-line="2429">	},
</a><a name="line-2430" data-line="2430">
</a><a name="line-2431" data-line="2431">	// Is the DOM ready to be used? Set to true once it occurs.
</a><a name="line-2432" data-line="2432">	isReady: false,
</a><a name="line-2433" data-line="2433">
</a><a name="line-2434" data-line="2434">	// A counter to track how many items to wait for before
</a><a name="line-2435" data-line="2435">	// the ready event fires. See #6781
</a><a name="line-2436" data-line="2436">	readyWait: 1,
</a><a name="line-2437" data-line="2437">
</a><a name="line-2438" data-line="2438">	// Hold (or release) the ready event
</a><a name="line-2439" data-line="2439">	holdReady: function( hold ) {
</a><a name="line-2440" data-line="2440">		if ( hold ) {
</a><a name="line-2441" data-line="2441">			jQuery.readyWait++;
</a><a name="line-2442" data-line="2442">		} else {
</a><a name="line-2443" data-line="2443">			jQuery.ready( true );
</a><a name="line-2444" data-line="2444">		}
</a><a name="line-2445" data-line="2445">	},
</a><a name="line-2446" data-line="2446">
</a><a name="line-2447" data-line="2447">	// Handle when the DOM is ready
</a><a name="line-2448" data-line="2448">	ready: function( wait ) {
</a><a name="line-2449" data-line="2449">		// Either a released hold or an DOMready/load event and not yet ready
</a><a name="line-2450" data-line="2450">		if ( (wait === true &amp;&amp; !--jQuery.readyWait) || (wait !== true &amp;&amp; !jQuery.isReady) ) {
</a><a name="line-2451" data-line="2451">			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
</a><a name="line-2452" data-line="2452">			if ( !document.body ) {
</a><a name="line-2453" data-line="2453">				return setTimeout( jQuery.ready, 1 );
</a><a name="line-2454" data-line="2454">			}
</a><a name="line-2455" data-line="2455">
</a><a name="line-2456" data-line="2456">			// Remember that the DOM is ready
</a><a name="line-2457" data-line="2457">			jQuery.isReady = true;
</a><a name="line-2458" data-line="2458">
</a><a name="line-2459" data-line="2459">			// If a normal DOM Ready event fired, decrement, and wait if need be
</a><a name="line-2460" data-line="2460">			if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
</a><a name="line-2461" data-line="2461">				return;
</a><a name="line-2462" data-line="2462">			}
</a><a name="line-2463" data-line="2463">
</a><a name="line-2464" data-line="2464">			// If there are functions bound, to execute
</a><a name="line-2465" data-line="2465">			readyList.fireWith( document, [ jQuery ] );
</a><a name="line-2466" data-line="2466">
</a><a name="line-2467" data-line="2467">			// Trigger any bound ready events
</a><a name="line-2468" data-line="2468">			if ( jQuery.fn.trigger ) {
</a><a name="line-2469" data-line="2469">				jQuery( document ).trigger( &quot;ready&quot; ).off( &quot;ready&quot; );
</a><a name="line-2470" data-line="2470">			}
</a><a name="line-2471" data-line="2471">		}
</a><a name="line-2472" data-line="2472">	},
</a><a name="line-2473" data-line="2473">
</a><a name="line-2474" data-line="2474">	bindReady: function() {
</a><a name="line-2475" data-line="2475">		if ( readyList ) {
</a><a name="line-2476" data-line="2476">			return;
</a><a name="line-2477" data-line="2477">		}
</a><a name="line-2478" data-line="2478">
</a><a name="line-2479" data-line="2479">		readyList = jQuery.Callbacks( &quot;once memory&quot; );
</a><a name="line-2480" data-line="2480">
</a><a name="line-2481" data-line="2481">		// Catch cases where $(document).ready() is called after the
</a><a name="line-2482" data-line="2482">		// browser event has already occurred.
</a><a name="line-2483" data-line="2483">		if ( document.readyState === &quot;complete&quot; ) {
</a><a name="line-2484" data-line="2484">			// Handle it asynchronously to allow scripts the opportunity to delay ready
</a><a name="line-2485" data-line="2485">			return setTimeout( jQuery.ready, 1 );
</a><a name="line-2486" data-line="2486">		}
</a><a name="line-2487" data-line="2487">
</a><a name="line-2488" data-line="2488">		// Mozilla, Opera and webkit nightlies currently support this event
</a><a name="line-2489" data-line="2489">		if ( document.addEventListener ) {
</a><a name="line-2490" data-line="2490">			// Use the handy event callback
</a><a name="line-2491" data-line="2491">			document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );
</a><a name="line-2492" data-line="2492">
</a><a name="line-2493" data-line="2493">			// A fallback to window.onload, that will always work
</a><a name="line-2494" data-line="2494">			window.addEventListener( &quot;load&quot;, jQuery.ready, false );
</a><a name="line-2495" data-line="2495">
</a><a name="line-2496" data-line="2496">		// If IE event model is used
</a><a name="line-2497" data-line="2497">		} else if ( document.attachEvent ) {
</a><a name="line-2498" data-line="2498">			// ensure firing before onload,
</a><a name="line-2499" data-line="2499">			// maybe late but safe also for iframes
</a><a name="line-2500" data-line="2500">			document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );
</a><a name="line-2501" data-line="2501">
</a><a name="line-2502" data-line="2502">			// A fallback to window.onload, that will always work
</a><a name="line-2503" data-line="2503">			window.attachEvent( &quot;onload&quot;, jQuery.ready );
</a><a name="line-2504" data-line="2504">
</a><a name="line-2505" data-line="2505">			// If IE and not a frame
</a><a name="line-2506" data-line="2506">			// continually check to see if the document is ready
</a><a name="line-2507" data-line="2507">			var toplevel = false;
</a><a name="line-2508" data-line="2508">
</a><a name="line-2509" data-line="2509">			try {
</a><a name="line-2510" data-line="2510">				toplevel = window.frameElement == null;
</a><a name="line-2511" data-line="2511">			} catch(e) {}
</a><a name="line-2512" data-line="2512">
</a><a name="line-2513" data-line="2513">			if ( document.documentElement.doScroll &amp;&amp; toplevel ) {
</a><a name="line-2514" data-line="2514">				doScrollCheck();
</a><a name="line-2515" data-line="2515">			}
</a><a name="line-2516" data-line="2516">		}
</a><a name="line-2517" data-line="2517">	},
</a><a name="line-2518" data-line="2518">
</a><a name="line-2519" data-line="2519">	// See test/unit/core.js for details concerning isFunction.
</a><a name="line-2520" data-line="2520">	// Since version 1.3, DOM methods and functions like alert
</a><a name="line-2521" data-line="2521">	// aren't supported. They return false on IE (#2968).
</a><a name="line-2522" data-line="2522">	isFunction: function( obj ) {
</a><a name="line-2523" data-line="2523">		return jQuery.type(obj) === &quot;function&quot;;
</a><a name="line-2524" data-line="2524">	},
</a><a name="line-2525" data-line="2525">
</a><a name="line-2526" data-line="2526">	isArray: Array.isArray || function( obj ) {
</a><a name="line-2527" data-line="2527">		return jQuery.type(obj) === &quot;array&quot;;
</a><a name="line-2528" data-line="2528">	},
</a><a name="line-2529" data-line="2529">
</a><a name="line-2530" data-line="2530">	isWindow: function( obj ) {
</a><a name="line-2531" data-line="2531">		return obj != null &amp;&amp; obj == obj.window;
</a><a name="line-2532" data-line="2532">	},
</a><a name="line-2533" data-line="2533">
</a><a name="line-2534" data-line="2534">	isNumeric: function( obj ) {
</a><a name="line-2535" data-line="2535">		return !isNaN( parseFloat(obj) ) &amp;&amp; isFinite( obj );
</a><a name="line-2536" data-line="2536">	},
</a><a name="line-2537" data-line="2537">
</a><a name="line-2538" data-line="2538">	type: function( obj ) {
</a><a name="line-2539" data-line="2539">		return obj == null ?
</a><a name="line-2540" data-line="2540">			String( obj ) :
</a><a name="line-2541" data-line="2541">			class2type[ toString.call(obj) ] || &quot;object&quot;;
</a><a name="line-2542" data-line="2542">	},
</a><a name="line-2543" data-line="2543">
</a><a name="line-2544" data-line="2544">	isPlainObject: function( obj ) {
</a><a name="line-2545" data-line="2545">		// Must be an Object.
</a><a name="line-2546" data-line="2546">		// Because of IE, we also have to check the presence of the constructor property.
</a><a name="line-2547" data-line="2547">		// Make sure that DOM nodes and window objects don't pass through, as well
</a><a name="line-2548" data-line="2548">		if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) {
</a><a name="line-2549" data-line="2549">			return false;
</a><a name="line-2550" data-line="2550">		}
</a><a name="line-2551" data-line="2551">
</a><a name="line-2552" data-line="2552">		try {
</a><a name="line-2553" data-line="2553">			// Not own constructor property must be Object
</a><a name="line-2554" data-line="2554">			if ( obj.constructor &amp;&amp;
</a><a name="line-2555" data-line="2555">				!hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp;
</a><a name="line-2556" data-line="2556">				!hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) {
</a><a name="line-2557" data-line="2557">				return false;
</a><a name="line-2558" data-line="2558">			}
</a><a name="line-2559" data-line="2559">		} catch ( e ) {
</a><a name="line-2560" data-line="2560">			// IE8,9 Will throw exceptions on certain host objects #9897
</a><a name="line-2561" data-line="2561">			return false;
</a><a name="line-2562" data-line="2562">		}
</a><a name="line-2563" data-line="2563">
</a><a name="line-2564" data-line="2564">		// Own properties are enumerated firstly, so to speed up,
</a><a name="line-2565" data-line="2565">		// if last one is own, then all properties are own.
</a><a name="line-2566" data-line="2566">
</a><a name="line-2567" data-line="2567">		var key;
</a><a name="line-2568" data-line="2568">		for ( key in obj ) {}
</a><a name="line-2569" data-line="2569">
</a><a name="line-2570" data-line="2570">		return key === undefined || hasOwn.call( obj, key );
</a><a name="line-2571" data-line="2571">	},
</a><a name="line-2572" data-line="2572">
</a><a name="line-2573" data-line="2573">	isEmptyObject: function( obj ) {
</a><a name="line-2574" data-line="2574">		for ( var name in obj ) {
</a><a name="line-2575" data-line="2575">			return false;
</a><a name="line-2576" data-line="2576">		}
</a><a name="line-2577" data-line="2577">		return true;
</a><a name="line-2578" data-line="2578">	},
</a><a name="line-2579" data-line="2579">
</a><a name="line-2580" data-line="2580">	error: function( msg ) {
</a><a name="line-2581" data-line="2581">		throw new Error( msg );
</a><a name="line-2582" data-line="2582">	},
</a><a name="line-2583" data-line="2583">
</a><a name="line-2584" data-line="2584">	parseJSON: function( data ) {
</a><a name="line-2585" data-line="2585">		if ( typeof data !== &quot;string&quot; || !data ) {
</a><a name="line-2586" data-line="2586">			return null;
</a><a name="line-2587" data-line="2587">		}
</a><a name="line-2588" data-line="2588">
</a><a name="line-2589" data-line="2589">		// Make sure leading/trailing whitespace is removed (IE can't handle it)
</a><a name="line-2590" data-line="2590">		data = jQuery.trim( data );
</a><a name="line-2591" data-line="2591">
</a><a name="line-2592" data-line="2592">		// Attempt to parse using the native JSON parser first
</a><a name="line-2593" data-line="2593">		if ( window.JSON &amp;&amp; window.JSON.parse ) {
</a><a name="line-2594" data-line="2594">			return window.JSON.parse( data );
</a><a name="line-2595" data-line="2595">		}
</a><a name="line-2596" data-line="2596">
</a><a name="line-2597" data-line="2597">		// Make sure the incoming data is actual JSON
</a><a name="line-2598" data-line="2598">		// Logic borrowed from http://json.org/json2.js
</a><a name="line-2599" data-line="2599">		if ( rvalidchars.test( data.replace( rvalidescape, &quot;@&quot; )
</a><a name="line-2600" data-line="2600">			.replace( rvalidtokens, &quot;]&quot; )
</a><a name="line-2601" data-line="2601">			.replace( rvalidbraces, &quot;&quot;)) ) {
</a><a name="line-2602" data-line="2602">
</a><a name="line-2603" data-line="2603">			return ( new Function( &quot;return &quot; + data ) )();
</a><a name="line-2604" data-line="2604">
</a><a name="line-2605" data-line="2605">		}
</a><a name="line-2606" data-line="2606">		jQuery.error( &quot;Invalid JSON: &quot; + data );
</a><a name="line-2607" data-line="2607">	},
</a><a name="line-2608" data-line="2608">
</a><a name="line-2609" data-line="2609">	// Cross-browser xml parsing
</a><a name="line-2610" data-line="2610">	parseXML: function( data ) {
</a><a name="line-2611" data-line="2611">		if ( typeof data !== &quot;string&quot; || !data ) {
</a><a name="line-2612" data-line="2612">			return null;
</a><a name="line-2613" data-line="2613">		}
</a><a name="line-2614" data-line="2614">		var xml, tmp;
</a><a name="line-2615" data-line="2615">		try {
</a><a name="line-2616" data-line="2616">			if ( window.DOMParser ) { // Standard
</a><a name="line-2617" data-line="2617">				tmp = new DOMParser();
</a><a name="line-2618" data-line="2618">				xml = tmp.parseFromString( data , &quot;text/xml&quot; );
</a><a name="line-2619" data-line="2619">			} else { // IE
</a><a name="line-2620" data-line="2620">				xml = new ActiveXObject( &quot;Microsoft.XMLDOM&quot; );
</a><a name="line-2621" data-line="2621">				xml.async = &quot;false&quot;;
</a><a name="line-2622" data-line="2622">				xml.loadXML( data );
</a><a name="line-2623" data-line="2623">			}
</a><a name="line-2624" data-line="2624">		} catch( e ) {
</a><a name="line-2625" data-line="2625">			xml = undefined;
</a><a name="line-2626" data-line="2626">		}
</a><a name="line-2627" data-line="2627">		if ( !xml || !xml.documentElement || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
</a><a name="line-2628" data-line="2628">			jQuery.error( &quot;Invalid XML: &quot; + data );
</a><a name="line-2629" data-line="2629">		}
</a><a name="line-2630" data-line="2630">		return xml;
</a><a name="line-2631" data-line="2631">	},
</a><a name="line-2632" data-line="2632">
</a><a name="line-2633" data-line="2633">	noop: function() {},
</a><a name="line-2634" data-line="2634">
</a><a name="line-2635" data-line="2635">	// Evaluates a script in a global context
</a><a name="line-2636" data-line="2636">	// Workarounds based on findings by Jim Driscoll
</a><a name="line-2637" data-line="2637">	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
</a><a name="line-2638" data-line="2638">	globalEval: function( data ) {
</a><a name="line-2639" data-line="2639">		if ( data &amp;&amp; rnotwhite.test( data ) ) {
</a><a name="line-2640" data-line="2640">			// We use execScript on Internet Explorer
</a><a name="line-2641" data-line="2641">			// We use an anonymous function so that context is window
</a><a name="line-2642" data-line="2642">			// rather than jQuery in Firefox
</a><a name="line-2643" data-line="2643">			( window.execScript || function( data ) {
</a><a name="line-2644" data-line="2644">				window[ &quot;eval&quot; ].call( window, data );
</a><a name="line-2645" data-line="2645">			} )( data );
</a><a name="line-2646" data-line="2646">		}
</a><a name="line-2647" data-line="2647">	},
</a><a name="line-2648" data-line="2648">
</a><a name="line-2649" data-line="2649">	// Convert dashed to camelCase; used by the css and data modules
</a><a name="line-2650" data-line="2650">	// Microsoft forgot to hump their vendor prefix (#9572)
</a><a name="line-2651" data-line="2651">	camelCase: function( string ) {
</a><a name="line-2652" data-line="2652">		return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
</a><a name="line-2653" data-line="2653">	},
</a><a name="line-2654" data-line="2654">
</a><a name="line-2655" data-line="2655">	nodeName: function( elem, name ) {
</a><a name="line-2656" data-line="2656">		return elem.nodeName &amp;&amp; elem.nodeName.toUpperCase() === name.toUpperCase();
</a><a name="line-2657" data-line="2657">	},
</a><a name="line-2658" data-line="2658">
</a><a name="line-2659" data-line="2659">	// args is for internal usage only
</a><a name="line-2660" data-line="2660">	each: function( object, callback, args ) {
</a><a name="line-2661" data-line="2661">		var name, i = 0,
</a><a name="line-2662" data-line="2662">			length = object.length,
</a><a name="line-2663" data-line="2663">			isObj = length === undefined || jQuery.isFunction( object );
</a><a name="line-2664" data-line="2664">
</a><a name="line-2665" data-line="2665">		if ( args ) {
</a><a name="line-2666" data-line="2666">			if ( isObj ) {
</a><a name="line-2667" data-line="2667">				for ( name in object ) {
</a><a name="line-2668" data-line="2668">					if ( callback.apply( object[ name ], args ) === false ) {
</a><a name="line-2669" data-line="2669">						break;
</a><a name="line-2670" data-line="2670">					}
</a><a name="line-2671" data-line="2671">				}
</a><a name="line-2672" data-line="2672">			} else {
</a><a name="line-2673" data-line="2673">				for ( ; i &lt; length; ) {
</a><a name="line-2674" data-line="2674">					if ( callback.apply( object[ i++ ], args ) === false ) {
</a><a name="line-2675" data-line="2675">						break;
</a><a name="line-2676" data-line="2676">					}
</a><a name="line-2677" data-line="2677">				}
</a><a name="line-2678" data-line="2678">			}
</a><a name="line-2679" data-line="2679">
</a><a name="line-2680" data-line="2680">		// A special, fast, case for the most common use of each
</a><a name="line-2681" data-line="2681">		} else {
</a><a name="line-2682" data-line="2682">			if ( isObj ) {
</a><a name="line-2683" data-line="2683">				for ( name in object ) {
</a><a name="line-2684" data-line="2684">					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
</a><a name="line-2685" data-line="2685">						break;
</a><a name="line-2686" data-line="2686">					}
</a><a name="line-2687" data-line="2687">				}
</a><a name="line-2688" data-line="2688">			} else {
</a><a name="line-2689" data-line="2689">				for ( ; i &lt; length; ) {
</a><a name="line-2690" data-line="2690">					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
</a><a name="line-2691" data-line="2691">						break;
</a><a name="line-2692" data-line="2692">					}
</a><a name="line-2693" data-line="2693">				}
</a><a name="line-2694" data-line="2694">			}
</a><a name="line-2695" data-line="2695">		}
</a><a name="line-2696" data-line="2696">
</a><a name="line-2697" data-line="2697">		return object;
</a><a name="line-2698" data-line="2698">	},
</a><a name="line-2699" data-line="2699">
</a><a name="line-2700" data-line="2700">	// Use native String.trim function wherever possible
</a><a name="line-2701" data-line="2701">	trim: trim ?
</a><a name="line-2702" data-line="2702">		function( text ) {
</a><a name="line-2703" data-line="2703">			return text == null ?
</a><a name="line-2704" data-line="2704">				&quot;&quot; :
</a><a name="line-2705" data-line="2705">				trim.call( text );
</a><a name="line-2706" data-line="2706">		} :
</a><a name="line-2707" data-line="2707">
</a><a name="line-2708" data-line="2708">		// Otherwise use our own trimming functionality
</a><a name="line-2709" data-line="2709">		function( text ) {
</a><a name="line-2710" data-line="2710">			return text == null ?
</a><a name="line-2711" data-line="2711">				&quot;&quot; :
</a><a name="line-2712" data-line="2712">				text.toString().replace( trimLeft, &quot;&quot; ).replace( trimRight, &quot;&quot; );
</a><a name="line-2713" data-line="2713">		},
</a><a name="line-2714" data-line="2714">
</a><a name="line-2715" data-line="2715">	// results is for internal usage only
</a><a name="line-2716" data-line="2716">	makeArray: function( array, results ) {
</a><a name="line-2717" data-line="2717">		var ret = results || [];
</a><a name="line-2718" data-line="2718">
</a><a name="line-2719" data-line="2719">		if ( array != null ) {
</a><a name="line-2720" data-line="2720">			// The window, strings (and functions) also have 'length'
</a><a name="line-2721" data-line="2721">			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
</a><a name="line-2722" data-line="2722">			var type = jQuery.type( array );
</a><a name="line-2723" data-line="2723">
</a><a name="line-2724" data-line="2724">			if ( array.length == null || type === &quot;string&quot; || type === &quot;function&quot; || type === &quot;regexp&quot; || jQuery.isWindow( array ) ) {
</a><a name="line-2725" data-line="2725">				push.call( ret, array );
</a><a name="line-2726" data-line="2726">			} else {
</a><a name="line-2727" data-line="2727">				jQuery.merge( ret, array );
</a><a name="line-2728" data-line="2728">			}
</a><a name="line-2729" data-line="2729">		}
</a><a name="line-2730" data-line="2730">
</a><a name="line-2731" data-line="2731">		return ret;
</a><a name="line-2732" data-line="2732">	},
</a><a name="line-2733" data-line="2733">
</a><a name="line-2734" data-line="2734">	inArray: function( elem, array, i ) {
</a><a name="line-2735" data-line="2735">		var len;
</a><a name="line-2736" data-line="2736">
</a><a name="line-2737" data-line="2737">		if ( array ) {
</a><a name="line-2738" data-line="2738">			if ( indexOf ) {
</a><a name="line-2739" data-line="2739">				return indexOf.call( array, elem, i );
</a><a name="line-2740" data-line="2740">			}
</a><a name="line-2741" data-line="2741">
</a><a name="line-2742" data-line="2742">			len = array.length;
</a><a name="line-2743" data-line="2743">			i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0;
</a><a name="line-2744" data-line="2744">
</a><a name="line-2745" data-line="2745">			for ( ; i &lt; len; i++ ) {
</a><a name="line-2746" data-line="2746">				// Skip accessing in sparse arrays
</a><a name="line-2747" data-line="2747">				if ( i in array &amp;&amp; array[ i ] === elem ) {
</a><a name="line-2748" data-line="2748">					return i;
</a><a name="line-2749" data-line="2749">				}
</a><a name="line-2750" data-line="2750">			}
</a><a name="line-2751" data-line="2751">		}
</a><a name="line-2752" data-line="2752">
</a><a name="line-2753" data-line="2753">		return -1;
</a><a name="line-2754" data-line="2754">	},
</a><a name="line-2755" data-line="2755">
</a><a name="line-2756" data-line="2756">	merge: function( first, second ) {
</a><a name="line-2757" data-line="2757">		var i = first.length,
</a><a name="line-2758" data-line="2758">			j = 0;
</a><a name="line-2759" data-line="2759">
</a><a name="line-2760" data-line="2760">		if ( typeof second.length === &quot;number&quot; ) {
</a><a name="line-2761" data-line="2761">			for ( var l = second.length; j &lt; l; j++ ) {
</a><a name="line-2762" data-line="2762">				first[ i++ ] = second[ j ];
</a><a name="line-2763" data-line="2763">			}
</a><a name="line-2764" data-line="2764">
</a><a name="line-2765" data-line="2765">		} else {
</a><a name="line-2766" data-line="2766">			while ( second[j] !== undefined ) {
</a><a name="line-2767" data-line="2767">				first[ i++ ] = second[ j++ ];
</a><a name="line-2768" data-line="2768">			}
</a><a name="line-2769" data-line="2769">		}
</a><a name="line-2770" data-line="2770">
</a><a name="line-2771" data-line="2771">		first.length = i;
</a><a name="line-2772" data-line="2772">
</a><a name="line-2773" data-line="2773">		return first;
</a><a name="line-2774" data-line="2774">	},
</a><a name="line-2775" data-line="2775">
</a><a name="line-2776" data-line="2776">	grep: function( elems, callback, inv ) {
</a><a name="line-2777" data-line="2777">		var ret = [], retVal;
</a><a name="line-2778" data-line="2778">		inv = !!inv;
</a><a name="line-2779" data-line="2779">
</a><a name="line-2780" data-line="2780">		// Go through the array, only saving the items
</a><a name="line-2781" data-line="2781">		// that pass the validator function
</a><a name="line-2782" data-line="2782">		for ( var i = 0, length = elems.length; i &lt; length; i++ ) {
</a><a name="line-2783" data-line="2783">			retVal = !!callback( elems[ i ], i );
</a><a name="line-2784" data-line="2784">			if ( inv !== retVal ) {
</a><a name="line-2785" data-line="2785">				ret.push( elems[ i ] );
</a><a name="line-2786" data-line="2786">			}
</a><a name="line-2787" data-line="2787">		}
</a><a name="line-2788" data-line="2788">
</a><a name="line-2789" data-line="2789">		return ret;
</a><a name="line-2790" data-line="2790">	},
</a><a name="line-2791" data-line="2791">
</a><a name="line-2792" data-line="2792">	// arg is for internal usage only
</a><a name="line-2793" data-line="2793">	map: function( elems, callback, arg ) {
</a><a name="line-2794" data-line="2794">		var value, key, ret = [],
</a><a name="line-2795" data-line="2795">			i = 0,
</a><a name="line-2796" data-line="2796">			length = elems.length,
</a><a name="line-2797" data-line="2797">			// jquery objects are treated as arrays
</a><a name="line-2798" data-line="2798">			isArray = elems instanceof jQuery || length !== undefined &amp;&amp; typeof length === &quot;number&quot; &amp;&amp; ( ( length &gt; 0 &amp;&amp; elems[ 0 ] &amp;&amp; elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;
</a><a name="line-2799" data-line="2799">
</a><a name="line-2800" data-line="2800">		// Go through the array, translating each of the items to their
</a><a name="line-2801" data-line="2801">		if ( isArray ) {
</a><a name="line-2802" data-line="2802">			for ( ; i &lt; length; i++ ) {
</a><a name="line-2803" data-line="2803">				value = callback( elems[ i ], i, arg );
</a><a name="line-2804" data-line="2804">
</a><a name="line-2805" data-line="2805">				if ( value != null ) {
</a><a name="line-2806" data-line="2806">					ret[ ret.length ] = value;
</a><a name="line-2807" data-line="2807">				}
</a><a name="line-2808" data-line="2808">			}
</a><a name="line-2809" data-line="2809">
</a><a name="line-2810" data-line="2810">		// Go through every key on the object,
</a><a name="line-2811" data-line="2811">		} else {
</a><a name="line-2812" data-line="2812">			for ( key in elems ) {
</a><a name="line-2813" data-line="2813">				value = callback( elems[ key ], key, arg );
</a><a name="line-2814" data-line="2814">
</a><a name="line-2815" data-line="2815">				if ( value != null ) {
</a><a name="line-2816" data-line="2816">					ret[ ret.length ] = value;
</a><a name="line-2817" data-line="2817">				}
</a><a name="line-2818" data-line="2818">			}
</a><a name="line-2819" data-line="2819">		}
</a><a name="line-2820" data-line="2820">
</a><a name="line-2821" data-line="2821">		// Flatten any nested arrays
</a><a name="line-2822" data-line="2822">		return ret.concat.apply( [], ret );
</a><a name="line-2823" data-line="2823">	},
</a><a name="line-2824" data-line="2824">
</a><a name="line-2825" data-line="2825">	// A global GUID counter for objects
</a><a name="line-2826" data-line="2826">	guid: 1,
</a><a name="line-2827" data-line="2827">
</a><a name="line-2828" data-line="2828">	// Bind a function to a context, optionally partially applying any
</a><a name="line-2829" data-line="2829">	// arguments.
</a><a name="line-2830" data-line="2830">	proxy: function( fn, context ) {
</a><a name="line-2831" data-line="2831">		if ( typeof context === &quot;string&quot; ) {
</a><a name="line-2832" data-line="2832">			var tmp = fn[ context ];
</a><a name="line-2833" data-line="2833">			context = fn;
</a><a name="line-2834" data-line="2834">			fn = tmp;
</a><a name="line-2835" data-line="2835">		}
</a><a name="line-2836" data-line="2836">
</a><a name="line-2837" data-line="2837">		// Quick check to determine if target is callable, in the spec
</a><a name="line-2838" data-line="2838">		// this throws a TypeError, but we will just return undefined.
</a><a name="line-2839" data-line="2839">		if ( !jQuery.isFunction( fn ) ) {
</a><a name="line-2840" data-line="2840">			return undefined;
</a><a name="line-2841" data-line="2841">		}
</a><a name="line-2842" data-line="2842">
</a><a name="line-2843" data-line="2843">		// Simulated bind
</a><a name="line-2844" data-line="2844">		var args = slice.call( arguments, 2 ),
</a><a name="line-2845" data-line="2845">			proxy = function() {
</a><a name="line-2846" data-line="2846">				return fn.apply( context, args.concat( slice.call( arguments ) ) );
</a><a name="line-2847" data-line="2847">			};
</a><a name="line-2848" data-line="2848">
</a><a name="line-2849" data-line="2849">		// Set the guid of unique handler to the same of original handler, so it can be removed
</a><a name="line-2850" data-line="2850">		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;
</a><a name="line-2851" data-line="2851">
</a><a name="line-2852" data-line="2852">		return proxy;
</a><a name="line-2853" data-line="2853">	},
</a><a name="line-2854" data-line="2854">
</a><a name="line-2855" data-line="2855">	// Mutifunctional method to get and set values to a collection
</a><a name="line-2856" data-line="2856">	// The value/s can optionally be executed if it's a function
</a><a name="line-2857" data-line="2857">	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
</a><a name="line-2858" data-line="2858">		var exec,
</a><a name="line-2859" data-line="2859">			bulk = key == null,
</a><a name="line-2860" data-line="2860">			i = 0,
</a><a name="line-2861" data-line="2861">			length = elems.length;
</a><a name="line-2862" data-line="2862">
</a><a name="line-2863" data-line="2863">		// Sets many values
</a><a name="line-2864" data-line="2864">		if ( key &amp;&amp; typeof key === &quot;object&quot; ) {
</a><a name="line-2865" data-line="2865">			for ( i in key ) {
</a><a name="line-2866" data-line="2866">				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
</a><a name="line-2867" data-line="2867">			}
</a><a name="line-2868" data-line="2868">			chainable = 1;
</a><a name="line-2869" data-line="2869">
</a><a name="line-2870" data-line="2870">		// Sets one value
</a><a name="line-2871" data-line="2871">		} else if ( value !== undefined ) {
</a><a name="line-2872" data-line="2872">			// Optionally, function values get executed if exec is true
</a><a name="line-2873" data-line="2873">			exec = pass === undefined &amp;&amp; jQuery.isFunction( value );
</a><a name="line-2874" data-line="2874">
</a><a name="line-2875" data-line="2875">			if ( bulk ) {
</a><a name="line-2876" data-line="2876">				// Bulk operations only iterate when executing function values
</a><a name="line-2877" data-line="2877">				if ( exec ) {
</a><a name="line-2878" data-line="2878">					exec = fn;
</a><a name="line-2879" data-line="2879">					fn = function( elem, key, value ) {
</a><a name="line-2880" data-line="2880">						return exec.call( jQuery( elem ), value );
</a><a name="line-2881" data-line="2881">					};
</a><a name="line-2882" data-line="2882">
</a><a name="line-2883" data-line="2883">				// Otherwise they run against the entire set
</a><a name="line-2884" data-line="2884">				} else {
</a><a name="line-2885" data-line="2885">					fn.call( elems, value );
</a><a name="line-2886" data-line="2886">					fn = null;
</a><a name="line-2887" data-line="2887">				}
</a><a name="line-2888" data-line="2888">			}
</a><a name="line-2889" data-line="2889">
</a><a name="line-2890" data-line="2890">			if ( fn ) {
</a><a name="line-2891" data-line="2891">				for (; i &lt; length; i++ ) {
</a><a name="line-2892" data-line="2892">					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
</a><a name="line-2893" data-line="2893">				}
</a><a name="line-2894" data-line="2894">			}
</a><a name="line-2895" data-line="2895">
</a><a name="line-2896" data-line="2896">			chainable = 1;
</a><a name="line-2897" data-line="2897">		}
</a><a name="line-2898" data-line="2898">
</a><a name="line-2899" data-line="2899">		return chainable ?
</a><a name="line-2900" data-line="2900">			elems :
</a><a name="line-2901" data-line="2901">
</a><a name="line-2902" data-line="2902">			// Gets
</a><a name="line-2903" data-line="2903">			bulk ?
</a><a name="line-2904" data-line="2904">				fn.call( elems ) :
</a><a name="line-2905" data-line="2905">				length ? fn( elems[0], key ) : emptyGet;
</a><a name="line-2906" data-line="2906">	},
</a><a name="line-2907" data-line="2907">
</a><a name="line-2908" data-line="2908">	now: function() {
</a><a name="line-2909" data-line="2909">		return ( new Date() ).getTime();
</a><a name="line-2910" data-line="2910">	},
</a><a name="line-2911" data-line="2911">
</a><a name="line-2912" data-line="2912">	// Use of jQuery.browser is frowned upon.
</a><a name="line-2913" data-line="2913">	// More details: http://docs.jquery.com/Utilities/jQuery.browser
</a><a name="line-2914" data-line="2914">	uaMatch: function( ua ) {
</a><a name="line-2915" data-line="2915">		ua = ua.toLowerCase();
</a><a name="line-2916" data-line="2916">
</a><a name="line-2917" data-line="2917">		var match = rwebkit.exec( ua ) ||
</a><a name="line-2918" data-line="2918">			ropera.exec( ua ) ||
</a><a name="line-2919" data-line="2919">			rmsie.exec( ua ) ||
</a><a name="line-2920" data-line="2920">			ua.indexOf(&quot;compatible&quot;) &lt; 0 &amp;&amp; rmozilla.exec( ua ) ||
</a><a name="line-2921" data-line="2921">			[];
</a><a name="line-2922" data-line="2922">
</a><a name="line-2923" data-line="2923">		return { browser: match[1] || &quot;&quot;, version: match[2] || &quot;0&quot; };
</a><a name="line-2924" data-line="2924">	},
</a><a name="line-2925" data-line="2925">
</a><a name="line-2926" data-line="2926">	sub: function() {
</a><a name="line-2927" data-line="2927">		function jQuerySub( selector, context ) {
</a><a name="line-2928" data-line="2928">			return new jQuerySub.fn.init( selector, context );
</a><a name="line-2929" data-line="2929">		}
</a><a name="line-2930" data-line="2930">		jQuery.extend( true, jQuerySub, this );
</a><a name="line-2931" data-line="2931">		jQuerySub.superclass = this;
</a><a name="line-2932" data-line="2932">		jQuerySub.fn = jQuerySub.prototype = this();
</a><a name="line-2933" data-line="2933">		jQuerySub.fn.constructor = jQuerySub;
</a><a name="line-2934" data-line="2934">		jQuerySub.sub = this.sub;
</a><a name="line-2935" data-line="2935">		jQuerySub.fn.init = function init( selector, context ) {
</a><a name="line-2936" data-line="2936">			if ( context &amp;&amp; context instanceof jQuery &amp;&amp; !(context instanceof jQuerySub) ) {
</a><a name="line-2937" data-line="2937">				context = jQuerySub( context );
</a><a name="line-2938" data-line="2938">			}
</a><a name="line-2939" data-line="2939">
</a><a name="line-2940" data-line="2940">			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
</a><a name="line-2941" data-line="2941">		};
</a><a name="line-2942" data-line="2942">		jQuerySub.fn.init.prototype = jQuerySub.fn;
</a><a name="line-2943" data-line="2943">		var rootjQuerySub = jQuerySub(document);
</a><a name="line-2944" data-line="2944">		return jQuerySub;
</a><a name="line-2945" data-line="2945">	},
</a><a name="line-2946" data-line="2946">
</a><a name="line-2947" data-line="2947">	browser: {}
</a><a name="line-2948" data-line="2948">});
</a><a name="line-2949" data-line="2949">
</a><a name="line-2950" data-line="2950">// Populate the class2type map
</a><a name="line-2951" data-line="2951">jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object&quot;.split(&quot; &quot;), function(i, name) {
</a><a name="line-2952" data-line="2952">	class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
</a><a name="line-2953" data-line="2953">});
</a><a name="line-2954" data-line="2954">
</a><a name="line-2955" data-line="2955">browserMatch = jQuery.uaMatch( userAgent );
</a><a name="line-2956" data-line="2956">if ( browserMatch.browser ) {
</a><a name="line-2957" data-line="2957">	jQuery.browser[ browserMatch.browser ] = true;
</a><a name="line-2958" data-line="2958">	jQuery.browser.version = browserMatch.version;
</a><a name="line-2959" data-line="2959">}
</a><a name="line-2960" data-line="2960">
</a><a name="line-2961" data-line="2961">// Deprecated, use jQuery.browser.webkit instead
</a><a name="line-2962" data-line="2962">if ( jQuery.browser.webkit ) {
</a><a name="line-2963" data-line="2963">	jQuery.browser.safari = true;
</a><a name="line-2964" data-line="2964">}
</a><a name="line-2965" data-line="2965">
</a><a name="line-2966" data-line="2966">// IE doesn't match non-breaking spaces with \s
</a><a name="line-2967" data-line="2967">if ( rnotwhite.test( &quot;\xA0&quot; ) ) {
</a><a name="line-2968" data-line="2968">	trimLeft = /^[\s\xA0]+/;
</a><a name="line-2969" data-line="2969">	trimRight = /[\s\xA0]+$/;
</a><a name="line-2970" data-line="2970">}
</a><a name="line-2971" data-line="2971">
</a><a name="line-2972" data-line="2972">// All jQuery objects should point back to these
</a><a name="line-2973" data-line="2973">rootjQuery = jQuery(document);
</a><a name="line-2974" data-line="2974">
</a><a name="line-2975" data-line="2975">// Cleanup functions for the document ready method
</a><a name="line-2976" data-line="2976">if ( document.addEventListener ) {
</a><a name="line-2977" data-line="2977">	DOMContentLoaded = function() {
</a><a name="line-2978" data-line="2978">		document.removeEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );
</a><a name="line-2979" data-line="2979">		jQuery.ready();
</a><a name="line-2980" data-line="2980">	};
</a><a name="line-2981" data-line="2981">
</a><a name="line-2982" data-line="2982">} else if ( document.attachEvent ) {
</a><a name="line-2983" data-line="2983">	DOMContentLoaded = function() {
</a><a name="line-2984" data-line="2984">		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
</a><a name="line-2985" data-line="2985">		if ( document.readyState === &quot;complete&quot; ) {
</a><a name="line-2986" data-line="2986">			document.detachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );
</a><a name="line-2987" data-line="2987">			jQuery.ready();
</a><a name="line-2988" data-line="2988">		}
</a><a name="line-2989" data-line="2989">	};
</a><a name="line-2990" data-line="2990">}
</a><a name="line-2991" data-line="2991">
</a><a name="line-2992" data-line="2992">// The DOM ready check for Internet Explorer
</a><a name="line-2993" data-line="2993">function doScrollCheck() {
</a><a name="line-2994" data-line="2994">	if ( jQuery.isReady ) {
</a><a name="line-2995" data-line="2995">		return;
</a><a name="line-2996" data-line="2996">	}
</a><a name="line-2997" data-line="2997">
</a><a name="line-2998" data-line="2998">	try {
</a><a name="line-2999" data-line="2999">		// If IE is used, use the trick by Diego Perini
</a><a name="line-3000" data-line="3000">		// http://javascript.nwbox.com/IEContentLoaded/
</a><a name="line-3001" data-line="3001">		document.documentElement.doScroll(&quot;left&quot;);
</a><a name="line-3002" data-line="3002">	} catch(e) {
</a><a name="line-3003" data-line="3003">		setTimeout( doScrollCheck, 1 );
</a><a name="line-3004" data-line="3004">		return;
</a><a name="line-3005" data-line="3005">	}
</a><a name="line-3006" data-line="3006">
</a><a name="line-3007" data-line="3007">	// and execute any waiting functions
</a><a name="line-3008" data-line="3008">	jQuery.ready();
</a><a name="line-3009" data-line="3009">}
</a><a name="line-3010" data-line="3010">
</a><a name="line-3011" data-line="3011">return jQuery;
</a><a name="line-3012" data-line="3012">
</a><a name="line-3013" data-line="3013">})();
</a><a name="line-3014" data-line="3014">
</a><a name="line-3015" data-line="3015">
</a><a name="line-3016" data-line="3016">// String to Object flags format cache
</a><a name="line-3017" data-line="3017">var flagsCache = {};
</a><a name="line-3018" data-line="3018">
</a><a name="line-3019" data-line="3019">// Convert String-formatted flags into Object-formatted ones and store in cache
</a><a name="line-3020" data-line="3020">function createFlags( flags ) {
</a><a name="line-3021" data-line="3021">	var object = flagsCache[ flags ] = {},
</a><a name="line-3022" data-line="3022">		i, length;
</a><a name="line-3023" data-line="3023">	flags = flags.split( /\s+/ );
</a><a name="line-3024" data-line="3024">	for ( i = 0, length = flags.length; i &lt; length; i++ ) {
</a><a name="line-3025" data-line="3025">		object[ flags[i] ] = true;
</a><a name="line-3026" data-line="3026">	}
</a><a name="line-3027" data-line="3027">	return object;
</a><a name="line-3028" data-line="3028">}
</a><a name="line-3029" data-line="3029">
</a><a name="line-3030" data-line="3030">/*
</a><a name="line-3031" data-line="3031"> * Create a callback list using the following parameters:
</a><a name="line-3032" data-line="3032"> *
</a><a name="line-3033" data-line="3033"> *	flags:	an optional list of space-separated flags that will change how
</a><a name="line-3034" data-line="3034"> *			the callback list behaves
</a><a name="line-3035" data-line="3035"> *
</a><a name="line-3036" data-line="3036"> * By default a callback list will act like an event callback list and can be
</a><a name="line-3037" data-line="3037"> * &quot;fired&quot; multiple times.
</a><a name="line-3038" data-line="3038"> *
</a><a name="line-3039" data-line="3039"> * Possible flags:
</a><a name="line-3040" data-line="3040"> *
</a><a name="line-3041" data-line="3041"> *	once:			will ensure the callback list can only be fired once (like a Deferred)
</a><a name="line-3042" data-line="3042"> *
</a><a name="line-3043" data-line="3043"> *	memory:			will keep track of previous values and will call any callback added
</a><a name="line-3044" data-line="3044"> *					after the list has been fired right away with the latest &quot;memorized&quot;
</a><a name="line-3045" data-line="3045"> *					values (like a Deferred)
</a><a name="line-3046" data-line="3046"> *
</a><a name="line-3047" data-line="3047"> *	unique:			will ensure a callback can only be added once (no duplicate in the list)
</a><a name="line-3048" data-line="3048"> *
</a><a name="line-3049" data-line="3049"> *	stopOnFalse:	interrupt callings when a callback returns false
</a><a name="line-3050" data-line="3050"> *
</a><a name="line-3051" data-line="3051"> */
</a><a name="line-3052" data-line="3052">jQuery.Callbacks = function( flags ) {
</a><a name="line-3053" data-line="3053">
</a><a name="line-3054" data-line="3054">	// Convert flags from String-formatted to Object-formatted
</a><a name="line-3055" data-line="3055">	// (we check in cache first)
</a><a name="line-3056" data-line="3056">	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};
</a><a name="line-3057" data-line="3057">
</a><a name="line-3058" data-line="3058">	var // Actual callback list
</a><a name="line-3059" data-line="3059">		list = [],
</a><a name="line-3060" data-line="3060">		// Stack of fire calls for repeatable lists
</a><a name="line-3061" data-line="3061">		stack = [],
</a><a name="line-3062" data-line="3062">		// Last fire value (for non-forgettable lists)
</a><a name="line-3063" data-line="3063">		memory,
</a><a name="line-3064" data-line="3064">		// Flag to know if list was already fired
</a><a name="line-3065" data-line="3065">		fired,
</a><a name="line-3066" data-line="3066">		// Flag to know if list is currently firing
</a><a name="line-3067" data-line="3067">		firing,
</a><a name="line-3068" data-line="3068">		// First callback to fire (used internally by add and fireWith)
</a><a name="line-3069" data-line="3069">		firingStart,
</a><a name="line-3070" data-line="3070">		// End of the loop when firing
</a><a name="line-3071" data-line="3071">		firingLength,
</a><a name="line-3072" data-line="3072">		// Index of currently firing callback (modified by remove if needed)
</a><a name="line-3073" data-line="3073">		firingIndex,
</a><a name="line-3074" data-line="3074">		// Add one or several callbacks to the list
</a><a name="line-3075" data-line="3075">		add = function( args ) {
</a><a name="line-3076" data-line="3076">			var i,
</a><a name="line-3077" data-line="3077">				length,
</a><a name="line-3078" data-line="3078">				elem,
</a><a name="line-3079" data-line="3079">				type,
</a><a name="line-3080" data-line="3080">				actual;
</a><a name="line-3081" data-line="3081">			for ( i = 0, length = args.length; i &lt; length; i++ ) {
</a><a name="line-3082" data-line="3082">				elem = args[ i ];
</a><a name="line-3083" data-line="3083">				type = jQuery.type( elem );
</a><a name="line-3084" data-line="3084">				if ( type === &quot;array&quot; ) {
</a><a name="line-3085" data-line="3085">					// Inspect recursively
</a><a name="line-3086" data-line="3086">					add( elem );
</a><a name="line-3087" data-line="3087">				} else if ( type === &quot;function&quot; ) {
</a><a name="line-3088" data-line="3088">					// Add if not in unique mode and callback is not in
</a><a name="line-3089" data-line="3089">					if ( !flags.unique || !self.has( elem ) ) {
</a><a name="line-3090" data-line="3090">						list.push( elem );
</a><a name="line-3091" data-line="3091">					}
</a><a name="line-3092" data-line="3092">				}
</a><a name="line-3093" data-line="3093">			}
</a><a name="line-3094" data-line="3094">		},
</a><a name="line-3095" data-line="3095">		// Fire callbacks
</a><a name="line-3096" data-line="3096">		fire = function( context, args ) {
</a><a name="line-3097" data-line="3097">			args = args || [];
</a><a name="line-3098" data-line="3098">			memory = !flags.memory || [ context, args ];
</a><a name="line-3099" data-line="3099">			fired = true;
</a><a name="line-3100" data-line="3100">			firing = true;
</a><a name="line-3101" data-line="3101">			firingIndex = firingStart || 0;
</a><a name="line-3102" data-line="3102">			firingStart = 0;
</a><a name="line-3103" data-line="3103">			firingLength = list.length;
</a><a name="line-3104" data-line="3104">			for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
</a><a name="line-3105" data-line="3105">				if ( list[ firingIndex ].apply( context, args ) === false &amp;&amp; flags.stopOnFalse ) {
</a><a name="line-3106" data-line="3106">					memory = true; // Mark as halted
</a><a name="line-3107" data-line="3107">					break;
</a><a name="line-3108" data-line="3108">				}
</a><a name="line-3109" data-line="3109">			}
</a><a name="line-3110" data-line="3110">			firing = false;
</a><a name="line-3111" data-line="3111">			if ( list ) {
</a><a name="line-3112" data-line="3112">				if ( !flags.once ) {
</a><a name="line-3113" data-line="3113">					if ( stack &amp;&amp; stack.length ) {
</a><a name="line-3114" data-line="3114">						memory = stack.shift();
</a><a name="line-3115" data-line="3115">						self.fireWith( memory[ 0 ], memory[ 1 ] );
</a><a name="line-3116" data-line="3116">					}
</a><a name="line-3117" data-line="3117">				} else if ( memory === true ) {
</a><a name="line-3118" data-line="3118">					self.disable();
</a><a name="line-3119" data-line="3119">				} else {
</a><a name="line-3120" data-line="3120">					list = [];
</a><a name="line-3121" data-line="3121">				}
</a><a name="line-3122" data-line="3122">			}
</a><a name="line-3123" data-line="3123">		},
</a><a name="line-3124" data-line="3124">		// Actual Callbacks object
</a><a name="line-3125" data-line="3125">		self = {
</a><a name="line-3126" data-line="3126">			// Add a callback or a collection of callbacks to the list
</a><a name="line-3127" data-line="3127">			add: function() {
</a><a name="line-3128" data-line="3128">				if ( list ) {
</a><a name="line-3129" data-line="3129">					var length = list.length;
</a><a name="line-3130" data-line="3130">					add( arguments );
</a><a name="line-3131" data-line="3131">					// Do we need to add the callbacks to the
</a><a name="line-3132" data-line="3132">					// current firing batch?
</a><a name="line-3133" data-line="3133">					if ( firing ) {
</a><a name="line-3134" data-line="3134">						firingLength = list.length;
</a><a name="line-3135" data-line="3135">					// With memory, if we're not firing then
</a><a name="line-3136" data-line="3136">					// we should call right away, unless previous
</a><a name="line-3137" data-line="3137">					// firing was halted (stopOnFalse)
</a><a name="line-3138" data-line="3138">					} else if ( memory &amp;&amp; memory !== true ) {
</a><a name="line-3139" data-line="3139">						firingStart = length;
</a><a name="line-3140" data-line="3140">						fire( memory[ 0 ], memory[ 1 ] );
</a><a name="line-3141" data-line="3141">					}
</a><a name="line-3142" data-line="3142">				}
</a><a name="line-3143" data-line="3143">				return this;
</a><a name="line-3144" data-line="3144">			},
</a><a name="line-3145" data-line="3145">			// Remove a callback from the list
</a><a name="line-3146" data-line="3146">			remove: function() {
</a><a name="line-3147" data-line="3147">				if ( list ) {
</a><a name="line-3148" data-line="3148">					var args = arguments,
</a><a name="line-3149" data-line="3149">						argIndex = 0,
</a><a name="line-3150" data-line="3150">						argLength = args.length;
</a><a name="line-3151" data-line="3151">					for ( ; argIndex &lt; argLength ; argIndex++ ) {
</a><a name="line-3152" data-line="3152">						for ( var i = 0; i &lt; list.length; i++ ) {
</a><a name="line-3153" data-line="3153">							if ( args[ argIndex ] === list[ i ] ) {
</a><a name="line-3154" data-line="3154">								// Handle firingIndex and firingLength
</a><a name="line-3155" data-line="3155">								if ( firing ) {
</a><a name="line-3156" data-line="3156">									if ( i &lt;= firingLength ) {
</a><a name="line-3157" data-line="3157">										firingLength--;
</a><a name="line-3158" data-line="3158">										if ( i &lt;= firingIndex ) {
</a><a name="line-3159" data-line="3159">											firingIndex--;
</a><a name="line-3160" data-line="3160">										}
</a><a name="line-3161" data-line="3161">									}
</a><a name="line-3162" data-line="3162">								}
</a><a name="line-3163" data-line="3163">								// Remove the element
</a><a name="line-3164" data-line="3164">								list.splice( i--, 1 );
</a><a name="line-3165" data-line="3165">								// If we have some unicity property then
</a><a name="line-3166" data-line="3166">								// we only need to do this once
</a><a name="line-3167" data-line="3167">								if ( flags.unique ) {
</a><a name="line-3168" data-line="3168">									break;
</a><a name="line-3169" data-line="3169">								}
</a><a name="line-3170" data-line="3170">							}
</a><a name="line-3171" data-line="3171">						}
</a><a name="line-3172" data-line="3172">					}
</a><a name="line-3173" data-line="3173">				}
</a><a name="line-3174" data-line="3174">				return this;
</a><a name="line-3175" data-line="3175">			},
</a><a name="line-3176" data-line="3176">			// Control if a given callback is in the list
</a><a name="line-3177" data-line="3177">			has: function( fn ) {
</a><a name="line-3178" data-line="3178">				if ( list ) {
</a><a name="line-3179" data-line="3179">					var i = 0,
</a><a name="line-3180" data-line="3180">						length = list.length;
</a><a name="line-3181" data-line="3181">					for ( ; i &lt; length; i++ ) {
</a><a name="line-3182" data-line="3182">						if ( fn === list[ i ] ) {
</a><a name="line-3183" data-line="3183">							return true;
</a><a name="line-3184" data-line="3184">						}
</a><a name="line-3185" data-line="3185">					}
</a><a name="line-3186" data-line="3186">				}
</a><a name="line-3187" data-line="3187">				return false;
</a><a name="line-3188" data-line="3188">			},
</a><a name="line-3189" data-line="3189">			// Remove all callbacks from the list
</a><a name="line-3190" data-line="3190">			empty: function() {
</a><a name="line-3191" data-line="3191">				list = [];
</a><a name="line-3192" data-line="3192">				return this;
</a><a name="line-3193" data-line="3193">			},
</a><a name="line-3194" data-line="3194">			// Have the list do nothing anymore
</a><a name="line-3195" data-line="3195">			disable: function() {
</a><a name="line-3196" data-line="3196">				list = stack = memory = undefined;
</a><a name="line-3197" data-line="3197">				return this;
</a><a name="line-3198" data-line="3198">			},
</a><a name="line-3199" data-line="3199">			// Is it disabled?
</a><a name="line-3200" data-line="3200">			disabled: function() {
</a><a name="line-3201" data-line="3201">				return !list;
</a><a name="line-3202" data-line="3202">			},
</a><a name="line-3203" data-line="3203">			// Lock the list in its current state
</a><a name="line-3204" data-line="3204">			lock: function() {
</a><a name="line-3205" data-line="3205">				stack = undefined;
</a><a name="line-3206" data-line="3206">				if ( !memory || memory === true ) {
</a><a name="line-3207" data-line="3207">					self.disable();
</a><a name="line-3208" data-line="3208">				}
</a><a name="line-3209" data-line="3209">				return this;
</a><a name="line-3210" data-line="3210">			},
</a><a name="line-3211" data-line="3211">			// Is it locked?
</a><a name="line-3212" data-line="3212">			locked: function() {
</a><a name="line-3213" data-line="3213">				return !stack;
</a><a name="line-3214" data-line="3214">			},
</a><a name="line-3215" data-line="3215">			// Call all callbacks with the given context and arguments
</a><a name="line-3216" data-line="3216">			fireWith: function( context, args ) {
</a><a name="line-3217" data-line="3217">				if ( stack ) {
</a><a name="line-3218" data-line="3218">					if ( firing ) {
</a><a name="line-3219" data-line="3219">						if ( !flags.once ) {
</a><a name="line-3220" data-line="3220">							stack.push( [ context, args ] );
</a><a name="line-3221" data-line="3221">						}
</a><a name="line-3222" data-line="3222">					} else if ( !( flags.once &amp;&amp; memory ) ) {
</a><a name="line-3223" data-line="3223">						fire( context, args );
</a><a name="line-3224" data-line="3224">					}
</a><a name="line-3225" data-line="3225">				}
</a><a name="line-3226" data-line="3226">				return this;
</a><a name="line-3227" data-line="3227">			},
</a><a name="line-3228" data-line="3228">			// Call all the callbacks with the given arguments
</a><a name="line-3229" data-line="3229">			fire: function() {
</a><a name="line-3230" data-line="3230">				self.fireWith( this, arguments );
</a><a name="line-3231" data-line="3231">				return this;
</a><a name="line-3232" data-line="3232">			},
</a><a name="line-3233" data-line="3233">			// To know if the callbacks have already been called at least once
</a><a name="line-3234" data-line="3234">			fired: function() {
</a><a name="line-3235" data-line="3235">				return !!fired;
</a><a name="line-3236" data-line="3236">			}
</a><a name="line-3237" data-line="3237">		};
</a><a name="line-3238" data-line="3238">
</a><a name="line-3239" data-line="3239">	return self;
</a><a name="line-3240" data-line="3240">};
</a><a name="line-3241" data-line="3241">
</a><a name="line-3242" data-line="3242">
</a><a name="line-3243" data-line="3243">
</a><a name="line-3244" data-line="3244">
</a><a name="line-3245" data-line="3245">var // Static reference to slice
</a><a name="line-3246" data-line="3246">	sliceDeferred = [].slice;
</a><a name="line-3247" data-line="3247">
</a><a name="line-3248" data-line="3248">jQuery.extend({
</a><a name="line-3249" data-line="3249">
</a><a name="line-3250" data-line="3250">	Deferred: function( func ) {
</a><a name="line-3251" data-line="3251">		var doneList = jQuery.Callbacks( &quot;once memory&quot; ),
</a><a name="line-3252" data-line="3252">			failList = jQuery.Callbacks( &quot;once memory&quot; ),
</a><a name="line-3253" data-line="3253">			progressList = jQuery.Callbacks( &quot;memory&quot; ),
</a><a name="line-3254" data-line="3254">			state = &quot;pending&quot;,
</a><a name="line-3255" data-line="3255">			lists = {
</a><a name="line-3256" data-line="3256">				resolve: doneList,
</a><a name="line-3257" data-line="3257">				reject: failList,
</a><a name="line-3258" data-line="3258">				notify: progressList
</a><a name="line-3259" data-line="3259">			},
</a><a name="line-3260" data-line="3260">			promise = {
</a><a name="line-3261" data-line="3261">				done: doneList.add,
</a><a name="line-3262" data-line="3262">				fail: failList.add,
</a><a name="line-3263" data-line="3263">				progress: progressList.add,
</a><a name="line-3264" data-line="3264">
</a><a name="line-3265" data-line="3265">				state: function() {
</a><a name="line-3266" data-line="3266">					return state;
</a><a name="line-3267" data-line="3267">				},
</a><a name="line-3268" data-line="3268">
</a><a name="line-3269" data-line="3269">				// Deprecated
</a><a name="line-3270" data-line="3270">				isResolved: doneList.fired,
</a><a name="line-3271" data-line="3271">				isRejected: failList.fired,
</a><a name="line-3272" data-line="3272">
</a><a name="line-3273" data-line="3273">				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
</a><a name="line-3274" data-line="3274">					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
</a><a name="line-3275" data-line="3275">					return this;
</a><a name="line-3276" data-line="3276">				},
</a><a name="line-3277" data-line="3277">				always: function() {
</a><a name="line-3278" data-line="3278">					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
</a><a name="line-3279" data-line="3279">					return this;
</a><a name="line-3280" data-line="3280">				},
</a><a name="line-3281" data-line="3281">				pipe: function( fnDone, fnFail, fnProgress ) {
</a><a name="line-3282" data-line="3282">					return jQuery.Deferred(function( newDefer ) {
</a><a name="line-3283" data-line="3283">						jQuery.each( {
</a><a name="line-3284" data-line="3284">							done: [ fnDone, &quot;resolve&quot; ],
</a><a name="line-3285" data-line="3285">							fail: [ fnFail, &quot;reject&quot; ],
</a><a name="line-3286" data-line="3286">							progress: [ fnProgress, &quot;notify&quot; ]
</a><a name="line-3287" data-line="3287">						}, function( handler, data ) {
</a><a name="line-3288" data-line="3288">							var fn = data[ 0 ],
</a><a name="line-3289" data-line="3289">								action = data[ 1 ],
</a><a name="line-3290" data-line="3290">								returned;
</a><a name="line-3291" data-line="3291">							if ( jQuery.isFunction( fn ) ) {
</a><a name="line-3292" data-line="3292">								deferred[ handler ](function() {
</a><a name="line-3293" data-line="3293">									returned = fn.apply( this, arguments );
</a><a name="line-3294" data-line="3294">									if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
</a><a name="line-3295" data-line="3295">										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
</a><a name="line-3296" data-line="3296">									} else {
</a><a name="line-3297" data-line="3297">										newDefer[ action + &quot;With&quot; ]( this === deferred ? newDefer : this, [ returned ] );
</a><a name="line-3298" data-line="3298">									}
</a><a name="line-3299" data-line="3299">								});
</a><a name="line-3300" data-line="3300">							} else {
</a><a name="line-3301" data-line="3301">								deferred[ handler ]( newDefer[ action ] );
</a><a name="line-3302" data-line="3302">							}
</a><a name="line-3303" data-line="3303">						});
</a><a name="line-3304" data-line="3304">					}).promise();
</a><a name="line-3305" data-line="3305">				},
</a><a name="line-3306" data-line="3306">				// Get a promise for this deferred
</a><a name="line-3307" data-line="3307">				// If obj is provided, the promise aspect is added to the object
</a><a name="line-3308" data-line="3308">				promise: function( obj ) {
</a><a name="line-3309" data-line="3309">					if ( obj == null ) {
</a><a name="line-3310" data-line="3310">						obj = promise;
</a><a name="line-3311" data-line="3311">					} else {
</a><a name="line-3312" data-line="3312">						for ( var key in promise ) {
</a><a name="line-3313" data-line="3313">							obj[ key ] = promise[ key ];
</a><a name="line-3314" data-line="3314">						}
</a><a name="line-3315" data-line="3315">					}
</a><a name="line-3316" data-line="3316">					return obj;
</a><a name="line-3317" data-line="3317">				}
</a><a name="line-3318" data-line="3318">			},
</a><a name="line-3319" data-line="3319">			deferred = promise.promise({}),
</a><a name="line-3320" data-line="3320">			key;
</a><a name="line-3321" data-line="3321">
</a><a name="line-3322" data-line="3322">		for ( key in lists ) {
</a><a name="line-3323" data-line="3323">			deferred[ key ] = lists[ key ].fire;
</a><a name="line-3324" data-line="3324">			deferred[ key + &quot;With&quot; ] = lists[ key ].fireWith;
</a><a name="line-3325" data-line="3325">		}
</a><a name="line-3326" data-line="3326">
</a><a name="line-3327" data-line="3327">		// Handle state
</a><a name="line-3328" data-line="3328">		deferred.done( function() {
</a><a name="line-3329" data-line="3329">			state = &quot;resolved&quot;;
</a><a name="line-3330" data-line="3330">		}, failList.disable, progressList.lock ).fail( function() {
</a><a name="line-3331" data-line="3331">			state = &quot;rejected&quot;;
</a><a name="line-3332" data-line="3332">		}, doneList.disable, progressList.lock );
</a><a name="line-3333" data-line="3333">
</a><a name="line-3334" data-line="3334">		// Call given func if any
</a><a name="line-3335" data-line="3335">		if ( func ) {
</a><a name="line-3336" data-line="3336">			func.call( deferred, deferred );
</a><a name="line-3337" data-line="3337">		}
</a><a name="line-3338" data-line="3338">
</a><a name="line-3339" data-line="3339">		// All done!
</a><a name="line-3340" data-line="3340">		return deferred;
</a><a name="line-3341" data-line="3341">	},
</a><a name="line-3342" data-line="3342">
</a><a name="line-3343" data-line="3343">	// Deferred helper
</a><a name="line-3344" data-line="3344">	when: function( firstParam ) {
</a><a name="line-3345" data-line="3345">		var args = sliceDeferred.call( arguments, 0 ),
</a><a name="line-3346" data-line="3346">			i = 0,
</a><a name="line-3347" data-line="3347">			length = args.length,
</a><a name="line-3348" data-line="3348">			pValues = new Array( length ),
</a><a name="line-3349" data-line="3349">			count = length,
</a><a name="line-3350" data-line="3350">			pCount = length,
</a><a name="line-3351" data-line="3351">			deferred = length &lt;= 1 &amp;&amp; firstParam &amp;&amp; jQuery.isFunction( firstParam.promise ) ?
</a><a name="line-3352" data-line="3352">				firstParam :
</a><a name="line-3353" data-line="3353">				jQuery.Deferred(),
</a><a name="line-3354" data-line="3354">			promise = deferred.promise();
</a><a name="line-3355" data-line="3355">		function resolveFunc( i ) {
</a><a name="line-3356" data-line="3356">			return function( value ) {
</a><a name="line-3357" data-line="3357">				args[ i ] = arguments.length &gt; 1 ? sliceDeferred.call( arguments, 0 ) : value;
</a><a name="line-3358" data-line="3358">				if ( !( --count ) ) {
</a><a name="line-3359" data-line="3359">					deferred.resolveWith( deferred, args );
</a><a name="line-3360" data-line="3360">				}
</a><a name="line-3361" data-line="3361">			};
</a><a name="line-3362" data-line="3362">		}
</a><a name="line-3363" data-line="3363">		function progressFunc( i ) {
</a><a name="line-3364" data-line="3364">			return function( value ) {
</a><a name="line-3365" data-line="3365">				pValues[ i ] = arguments.length &gt; 1 ? sliceDeferred.call( arguments, 0 ) : value;
</a><a name="line-3366" data-line="3366">				deferred.notifyWith( promise, pValues );
</a><a name="line-3367" data-line="3367">			};
</a><a name="line-3368" data-line="3368">		}
</a><a name="line-3369" data-line="3369">		if ( length &gt; 1 ) {
</a><a name="line-3370" data-line="3370">			for ( ; i &lt; length; i++ ) {
</a><a name="line-3371" data-line="3371">				if ( args[ i ] &amp;&amp; args[ i ].promise &amp;&amp; jQuery.isFunction( args[ i ].promise ) ) {
</a><a name="line-3372" data-line="3372">					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
</a><a name="line-3373" data-line="3373">				} else {
</a><a name="line-3374" data-line="3374">					--count;
</a><a name="line-3375" data-line="3375">				}
</a><a name="line-3376" data-line="3376">			}
</a><a name="line-3377" data-line="3377">			if ( !count ) {
</a><a name="line-3378" data-line="3378">				deferred.resolveWith( deferred, args );
</a><a name="line-3379" data-line="3379">			}
</a><a name="line-3380" data-line="3380">		} else if ( deferred !== firstParam ) {
</a><a name="line-3381" data-line="3381">			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
</a><a name="line-3382" data-line="3382">		}
</a><a name="line-3383" data-line="3383">		return promise;
</a><a name="line-3384" data-line="3384">	}
</a><a name="line-3385" data-line="3385">});
</a><a name="line-3386" data-line="3386">
</a><a name="line-3387" data-line="3387">
</a><a name="line-3388" data-line="3388">
</a><a name="line-3389" data-line="3389">
</a><a name="line-3390" data-line="3390">jQuery.support = (function() {
</a><a name="line-3391" data-line="3391">
</a><a name="line-3392" data-line="3392">	var support,
</a><a name="line-3393" data-line="3393">		all,
</a><a name="line-3394" data-line="3394">		a,
</a><a name="line-3395" data-line="3395">		select,
</a><a name="line-3396" data-line="3396">		opt,
</a><a name="line-3397" data-line="3397">		input,
</a><a name="line-3398" data-line="3398">		fragment,
</a><a name="line-3399" data-line="3399">		tds,
</a><a name="line-3400" data-line="3400">		events,
</a><a name="line-3401" data-line="3401">		eventName,
</a><a name="line-3402" data-line="3402">		i,
</a><a name="line-3403" data-line="3403">		isSupported,
</a><a name="line-3404" data-line="3404">		div = document.createElement( &quot;div&quot; ),
</a><a name="line-3405" data-line="3405">		documentElement = document.documentElement;
</a><a name="line-3406" data-line="3406">
</a><a name="line-3407" data-line="3407">	// Preliminary tests
</a><a name="line-3408" data-line="3408">	div.setAttribute(&quot;className&quot;, &quot;t&quot;);
</a><a name="line-3409" data-line="3409">	div.innerHTML = &quot;   &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href='/a' style='top:1px;float:left;opacity:.55;'&gt;a&lt;/a&gt;&lt;input type='checkbox'/&gt;&quot;;
</a><a name="line-3410" data-line="3410">
</a><a name="line-3411" data-line="3411">	all = div.getElementsByTagName( &quot;*&quot; );
</a><a name="line-3412" data-line="3412">	a = div.getElementsByTagName( &quot;a&quot; )[ 0 ];
</a><a name="line-3413" data-line="3413">
</a><a name="line-3414" data-line="3414">	// Can't get basic test support
</a><a name="line-3415" data-line="3415">	if ( !all || !all.length || !a ) {
</a><a name="line-3416" data-line="3416">		return {};
</a><a name="line-3417" data-line="3417">	}
</a><a name="line-3418" data-line="3418">
</a><a name="line-3419" data-line="3419">	// First batch of supports tests
</a><a name="line-3420" data-line="3420">	select = document.createElement( &quot;select&quot; );
</a><a name="line-3421" data-line="3421">	opt = select.appendChild( document.createElement(&quot;option&quot;) );
</a><a name="line-3422" data-line="3422">	input = div.getElementsByTagName( &quot;input&quot; )[ 0 ];
</a><a name="line-3423" data-line="3423">
</a><a name="line-3424" data-line="3424">	support = {
</a><a name="line-3425" data-line="3425">		// IE strips leading whitespace when .innerHTML is used
</a><a name="line-3426" data-line="3426">		leadingWhitespace: ( div.firstChild.nodeType === 3 ),
</a><a name="line-3427" data-line="3427">
</a><a name="line-3428" data-line="3428">		// Make sure that tbody elements aren't automatically inserted
</a><a name="line-3429" data-line="3429">		// IE will insert them into empty tables
</a><a name="line-3430" data-line="3430">		tbody: !div.getElementsByTagName(&quot;tbody&quot;).length,
</a><a name="line-3431" data-line="3431">
</a><a name="line-3432" data-line="3432">		// Make sure that link elements get serialized correctly by innerHTML
</a><a name="line-3433" data-line="3433">		// This requires a wrapper element in IE
</a><a name="line-3434" data-line="3434">		htmlSerialize: !!div.getElementsByTagName(&quot;link&quot;).length,
</a><a name="line-3435" data-line="3435">
</a><a name="line-3436" data-line="3436">		// Get the style information from getAttribute
</a><a name="line-3437" data-line="3437">		// (IE uses .cssText instead)
</a><a name="line-3438" data-line="3438">		style: /top/.test( a.getAttribute(&quot;style&quot;) ),
</a><a name="line-3439" data-line="3439">
</a><a name="line-3440" data-line="3440">		// Make sure that URLs aren't manipulated
</a><a name="line-3441" data-line="3441">		// (IE normalizes it by default)
</a><a name="line-3442" data-line="3442">		hrefNormalized: ( a.getAttribute(&quot;href&quot;) === &quot;/a&quot; ),
</a><a name="line-3443" data-line="3443">
</a><a name="line-3444" data-line="3444">		// Make sure that element opacity exists
</a><a name="line-3445" data-line="3445">		// (IE uses filter instead)
</a><a name="line-3446" data-line="3446">		// Use a regex to work around a WebKit issue. See #5145
</a><a name="line-3447" data-line="3447">		opacity: /^0.55/.test( a.style.opacity ),
</a><a name="line-3448" data-line="3448">
</a><a name="line-3449" data-line="3449">		// Verify style float existence
</a><a name="line-3450" data-line="3450">		// (IE uses styleFloat instead of cssFloat)
</a><a name="line-3451" data-line="3451">		cssFloat: !!a.style.cssFloat,
</a><a name="line-3452" data-line="3452">
</a><a name="line-3453" data-line="3453">		// Make sure that if no value is specified for a checkbox
</a><a name="line-3454" data-line="3454">		// that it defaults to &quot;on&quot;.
</a><a name="line-3455" data-line="3455">		// (WebKit defaults to &quot;&quot; instead)
</a><a name="line-3456" data-line="3456">		checkOn: ( input.value === &quot;on&quot; ),
</a><a name="line-3457" data-line="3457">
</a><a name="line-3458" data-line="3458">		// Make sure that a selected-by-default option has a working selected property.
</a><a name="line-3459" data-line="3459">		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
</a><a name="line-3460" data-line="3460">		optSelected: opt.selected,
</a><a name="line-3461" data-line="3461">
</a><a name="line-3462" data-line="3462">		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
</a><a name="line-3463" data-line="3463">		getSetAttribute: div.className !== &quot;t&quot;,
</a><a name="line-3464" data-line="3464">
</a><a name="line-3465" data-line="3465">		// Tests for enctype support on a form(#6743)
</a><a name="line-3466" data-line="3466">		enctype: !!document.createElement(&quot;form&quot;).enctype,
</a><a name="line-3467" data-line="3467">
</a><a name="line-3468" data-line="3468">		// Makes sure cloning an html5 element does not cause problems
</a><a name="line-3469" data-line="3469">		// Where outerHTML is undefined, this still works
</a><a name="line-3470" data-line="3470">		html5Clone: document.createElement(&quot;nav&quot;).cloneNode( true ).outerHTML !== &quot;&lt;:nav&gt;&lt;/:nav&gt;&quot;,
</a><a name="line-3471" data-line="3471">
</a><a name="line-3472" data-line="3472">		// Will be defined later
</a><a name="line-3473" data-line="3473">		submitBubbles: true,
</a><a name="line-3474" data-line="3474">		changeBubbles: true,
</a><a name="line-3475" data-line="3475">		focusinBubbles: false,
</a><a name="line-3476" data-line="3476">		deleteExpando: true,
</a><a name="line-3477" data-line="3477">		noCloneEvent: true,
</a><a name="line-3478" data-line="3478">		inlineBlockNeedsLayout: false,
</a><a name="line-3479" data-line="3479">		shrinkWrapBlocks: false,
</a><a name="line-3480" data-line="3480">		reliableMarginRight: true,
</a><a name="line-3481" data-line="3481">		pixelMargin: true
</a><a name="line-3482" data-line="3482">	};
</a><a name="line-3483" data-line="3483">
</a><a name="line-3484" data-line="3484">	// jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
</a><a name="line-3485" data-line="3485">	jQuery.boxModel = support.boxModel = (document.compatMode === &quot;CSS1Compat&quot;);
</a><a name="line-3486" data-line="3486">
</a><a name="line-3487" data-line="3487">	// Make sure checked status is properly cloned
</a><a name="line-3488" data-line="3488">	input.checked = true;
</a><a name="line-3489" data-line="3489">	support.noCloneChecked = input.cloneNode( true ).checked;
</a><a name="line-3490" data-line="3490">
</a><a name="line-3491" data-line="3491">	// Make sure that the options inside disabled selects aren't marked as disabled
</a><a name="line-3492" data-line="3492">	// (WebKit marks them as disabled)
</a><a name="line-3493" data-line="3493">	select.disabled = true;
</a><a name="line-3494" data-line="3494">	support.optDisabled = !opt.disabled;
</a><a name="line-3495" data-line="3495">
</a><a name="line-3496" data-line="3496">	// Test to see if it's possible to delete an expando from an element
</a><a name="line-3497" data-line="3497">	// Fails in Internet Explorer
</a><a name="line-3498" data-line="3498">	try {
</a><a name="line-3499" data-line="3499">		delete div.test;
</a><a name="line-3500" data-line="3500">	} catch( e ) {
</a><a name="line-3501" data-line="3501">		support.deleteExpando = false;
</a><a name="line-3502" data-line="3502">	}
</a><a name="line-3503" data-line="3503">
</a><a name="line-3504" data-line="3504">	if ( !div.addEventListener &amp;&amp; div.attachEvent &amp;&amp; div.fireEvent ) {
</a><a name="line-3505" data-line="3505">		div.attachEvent( &quot;onclick&quot;, function() {
</a><a name="line-3506" data-line="3506">			// Cloning a node shouldn't copy over any
</a><a name="line-3507" data-line="3507">			// bound event handlers (IE does this)
</a><a name="line-3508" data-line="3508">			support.noCloneEvent = false;
</a><a name="line-3509" data-line="3509">		});
</a><a name="line-3510" data-line="3510">		div.cloneNode( true ).fireEvent( &quot;onclick&quot; );
</a><a name="line-3511" data-line="3511">	}
</a><a name="line-3512" data-line="3512">
</a><a name="line-3513" data-line="3513">	// Check if a radio maintains its value
</a><a name="line-3514" data-line="3514">	// after being appended to the DOM
</a><a name="line-3515" data-line="3515">	input = document.createElement(&quot;input&quot;);
</a><a name="line-3516" data-line="3516">	input.value = &quot;t&quot;;
</a><a name="line-3517" data-line="3517">	input.setAttribute(&quot;type&quot;, &quot;radio&quot;);
</a><a name="line-3518" data-line="3518">	support.radioValue = input.value === &quot;t&quot;;
</a><a name="line-3519" data-line="3519">
</a><a name="line-3520" data-line="3520">	input.setAttribute(&quot;checked&quot;, &quot;checked&quot;);
</a><a name="line-3521" data-line="3521">
</a><a name="line-3522" data-line="3522">	// #11217 - WebKit loses check when the name is after the checked attribute
</a><a name="line-3523" data-line="3523">	input.setAttribute( &quot;name&quot;, &quot;t&quot; );
</a><a name="line-3524" data-line="3524">
</a><a name="line-3525" data-line="3525">	div.appendChild( input );
</a><a name="line-3526" data-line="3526">	fragment = document.createDocumentFragment();
</a><a name="line-3527" data-line="3527">	fragment.appendChild( div.lastChild );
</a><a name="line-3528" data-line="3528">
</a><a name="line-3529" data-line="3529">	// WebKit doesn't clone checked state correctly in fragments
</a><a name="line-3530" data-line="3530">	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;
</a><a name="line-3531" data-line="3531">
</a><a name="line-3532" data-line="3532">	// Check if a disconnected checkbox will retain its checked
</a><a name="line-3533" data-line="3533">	// value of true after appended to the DOM (IE6/7)
</a><a name="line-3534" data-line="3534">	support.appendChecked = input.checked;
</a><a name="line-3535" data-line="3535">
</a><a name="line-3536" data-line="3536">	fragment.removeChild( input );
</a><a name="line-3537" data-line="3537">	fragment.appendChild( div );
</a><a name="line-3538" data-line="3538">
</a><a name="line-3539" data-line="3539">	// Technique from Juriy Zaytsev
</a><a name="line-3540" data-line="3540">	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
</a><a name="line-3541" data-line="3541">	// We only care about the case where non-standard event systems
</a><a name="line-3542" data-line="3542">	// are used, namely in IE. Short-circuiting here helps us to
</a><a name="line-3543" data-line="3543">	// avoid an eval call (in setAttribute) which can cause CSP
</a><a name="line-3544" data-line="3544">	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
</a><a name="line-3545" data-line="3545">	if ( div.attachEvent ) {
</a><a name="line-3546" data-line="3546">		for ( i in {
</a><a name="line-3547" data-line="3547">			submit: 1,
</a><a name="line-3548" data-line="3548">			change: 1,
</a><a name="line-3549" data-line="3549">			focusin: 1
</a><a name="line-3550" data-line="3550">		}) {
</a><a name="line-3551" data-line="3551">			eventName = &quot;on&quot; + i;
</a><a name="line-3552" data-line="3552">			isSupported = ( eventName in div );
</a><a name="line-3553" data-line="3553">			if ( !isSupported ) {
</a><a name="line-3554" data-line="3554">				div.setAttribute( eventName, &quot;return;&quot; );
</a><a name="line-3555" data-line="3555">				isSupported = ( typeof div[ eventName ] === &quot;function&quot; );
</a><a name="line-3556" data-line="3556">			}
</a><a name="line-3557" data-line="3557">			support[ i + &quot;Bubbles&quot; ] = isSupported;
</a><a name="line-3558" data-line="3558">		}
</a><a name="line-3559" data-line="3559">	}
</a><a name="line-3560" data-line="3560">
</a><a name="line-3561" data-line="3561">	fragment.removeChild( div );
</a><a name="line-3562" data-line="3562">
</a><a name="line-3563" data-line="3563">	// Null elements to avoid leaks in IE
</a><a name="line-3564" data-line="3564">	fragment = select = opt = div = input = null;
</a><a name="line-3565" data-line="3565">
</a><a name="line-3566" data-line="3566">	// Run tests that need a body at doc ready
</a><a name="line-3567" data-line="3567">	jQuery(function() {
</a><a name="line-3568" data-line="3568">		var container, outer, inner, table, td, offsetSupport,
</a><a name="line-3569" data-line="3569">			marginDiv, conMarginTop, style, html, positionTopLeftWidthHeight,
</a><a name="line-3570" data-line="3570">			paddingMarginBorderVisibility, paddingMarginBorder,
</a><a name="line-3571" data-line="3571">			body = document.getElementsByTagName(&quot;body&quot;)[0];
</a><a name="line-3572" data-line="3572">
</a><a name="line-3573" data-line="3573">		if ( !body ) {
</a><a name="line-3574" data-line="3574">			// Return for frameset docs that don't have a body
</a><a name="line-3575" data-line="3575">			return;
</a><a name="line-3576" data-line="3576">		}
</a><a name="line-3577" data-line="3577">
</a><a name="line-3578" data-line="3578">		conMarginTop = 1;
</a><a name="line-3579" data-line="3579">		paddingMarginBorder = &quot;padding:0;margin:0;border:&quot;;
</a><a name="line-3580" data-line="3580">		positionTopLeftWidthHeight = &quot;position:absolute;top:0;left:0;width:1px;height:1px;&quot;;
</a><a name="line-3581" data-line="3581">		paddingMarginBorderVisibility = paddingMarginBorder + &quot;0;visibility:hidden;&quot;;
</a><a name="line-3582" data-line="3582">		style = &quot;style='&quot; + positionTopLeftWidthHeight + paddingMarginBorder + &quot;5px solid #000;&quot;;
</a><a name="line-3583" data-line="3583">		html = &quot;&lt;div &quot; + style + &quot;display:block;'&gt;&lt;div style='&quot; + paddingMarginBorder + &quot;0;display:block;overflow:hidden;'&gt;&lt;/div&gt;&lt;/div&gt;&quot; +
</a><a name="line-3584" data-line="3584">			&quot;&lt;table &quot; + style + &quot;' cellpadding='0' cellspacing='0'&gt;&quot; +
</a><a name="line-3585" data-line="3585">			&quot;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;;
</a><a name="line-3586" data-line="3586">
</a><a name="line-3587" data-line="3587">		container = document.createElement(&quot;div&quot;);
</a><a name="line-3588" data-line="3588">		container.style.cssText = paddingMarginBorderVisibility + &quot;width:0;height:0;position:static;top:0;margin-top:&quot; + conMarginTop + &quot;px&quot;;
</a><a name="line-3589" data-line="3589">		body.insertBefore( container, body.firstChild );
</a><a name="line-3590" data-line="3590">
</a><a name="line-3591" data-line="3591">		// Construct the test element
</a><a name="line-3592" data-line="3592">		div = document.createElement(&quot;div&quot;);
</a><a name="line-3593" data-line="3593">		container.appendChild( div );
</a><a name="line-3594" data-line="3594">
</a><a name="line-3595" data-line="3595">		// Check if table cells still have offsetWidth/Height when they are set
</a><a name="line-3596" data-line="3596">		// to display:none and there are still other visible table cells in a
</a><a name="line-3597" data-line="3597">		// table row; if so, offsetWidth/Height are not reliable for use when
</a><a name="line-3598" data-line="3598">		// determining if an element has been hidden directly using
</a><a name="line-3599" data-line="3599">		// display:none (it is still safe to use offsets if a parent element is
</a><a name="line-3600" data-line="3600">		// hidden; don safety goggles and see bug #4512 for more information).
</a><a name="line-3601" data-line="3601">		// (only IE 8 fails this test)
</a><a name="line-3602" data-line="3602">		div.innerHTML = &quot;&lt;table&gt;&lt;tr&gt;&lt;td style='&quot; + paddingMarginBorder + &quot;0;display:none'&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;;
</a><a name="line-3603" data-line="3603">		tds = div.getElementsByTagName( &quot;td&quot; );
</a><a name="line-3604" data-line="3604">		isSupported = ( tds[ 0 ].offsetHeight === 0 );
</a><a name="line-3605" data-line="3605">
</a><a name="line-3606" data-line="3606">		tds[ 0 ].style.display = &quot;&quot;;
</a><a name="line-3607" data-line="3607">		tds[ 1 ].style.display = &quot;none&quot;;
</a><a name="line-3608" data-line="3608">
</a><a name="line-3609" data-line="3609">		// Check if empty table cells still have offsetWidth/Height
</a><a name="line-3610" data-line="3610">		// (IE &lt;= 8 fail this test)
</a><a name="line-3611" data-line="3611">		support.reliableHiddenOffsets = isSupported &amp;&amp; ( tds[ 0 ].offsetHeight === 0 );
</a><a name="line-3612" data-line="3612">
</a><a name="line-3613" data-line="3613">		// Check if div with explicit width and no margin-right incorrectly
</a><a name="line-3614" data-line="3614">		// gets computed margin-right based on width of container. For more
</a><a name="line-3615" data-line="3615">		// info see bug #3333
</a><a name="line-3616" data-line="3616">		// Fails in WebKit before Feb 2011 nightlies
</a><a name="line-3617" data-line="3617">		// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
</a><a name="line-3618" data-line="3618">		if ( window.getComputedStyle ) {
</a><a name="line-3619" data-line="3619">			div.innerHTML = &quot;&quot;;
</a><a name="line-3620" data-line="3620">			marginDiv = document.createElement( &quot;div&quot; );
</a><a name="line-3621" data-line="3621">			marginDiv.style.width = &quot;0&quot;;
</a><a name="line-3622" data-line="3622">			marginDiv.style.marginRight = &quot;0&quot;;
</a><a name="line-3623" data-line="3623">			div.style.width = &quot;2px&quot;;
</a><a name="line-3624" data-line="3624">			div.appendChild( marginDiv );
</a><a name="line-3625" data-line="3625">			support.reliableMarginRight =
</a><a name="line-3626" data-line="3626">				( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
</a><a name="line-3627" data-line="3627">		}
</a><a name="line-3628" data-line="3628">
</a><a name="line-3629" data-line="3629">		if ( typeof div.style.zoom !== &quot;undefined&quot; ) {
</a><a name="line-3630" data-line="3630">			// Check if natively block-level elements act like inline-block
</a><a name="line-3631" data-line="3631">			// elements when setting their display to 'inline' and giving
</a><a name="line-3632" data-line="3632">			// them layout
</a><a name="line-3633" data-line="3633">			// (IE &lt; 8 does this)
</a><a name="line-3634" data-line="3634">			div.innerHTML = &quot;&quot;;
</a><a name="line-3635" data-line="3635">			div.style.width = div.style.padding = &quot;1px&quot;;
</a><a name="line-3636" data-line="3636">			div.style.border = 0;
</a><a name="line-3637" data-line="3637">			div.style.overflow = &quot;hidden&quot;;
</a><a name="line-3638" data-line="3638">			div.style.display = &quot;inline&quot;;
</a><a name="line-3639" data-line="3639">			div.style.zoom = 1;
</a><a name="line-3640" data-line="3640">			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );
</a><a name="line-3641" data-line="3641">
</a><a name="line-3642" data-line="3642">			// Check if elements with layout shrink-wrap their children
</a><a name="line-3643" data-line="3643">			// (IE 6 does this)
</a><a name="line-3644" data-line="3644">			div.style.display = &quot;block&quot;;
</a><a name="line-3645" data-line="3645">			div.style.overflow = &quot;visible&quot;;
</a><a name="line-3646" data-line="3646">			div.innerHTML = &quot;&lt;div style='width:5px;'&gt;&lt;/div&gt;&quot;;
</a><a name="line-3647" data-line="3647">			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );
</a><a name="line-3648" data-line="3648">		}
</a><a name="line-3649" data-line="3649">
</a><a name="line-3650" data-line="3650">		div.style.cssText = positionTopLeftWidthHeight + paddingMarginBorderVisibility;
</a><a name="line-3651" data-line="3651">		div.innerHTML = html;
</a><a name="line-3652" data-line="3652">
</a><a name="line-3653" data-line="3653">		outer = div.firstChild;
</a><a name="line-3654" data-line="3654">		inner = outer.firstChild;
</a><a name="line-3655" data-line="3655">		td = outer.nextSibling.firstChild.firstChild;
</a><a name="line-3656" data-line="3656">
</a><a name="line-3657" data-line="3657">		offsetSupport = {
</a><a name="line-3658" data-line="3658">			doesNotAddBorder: ( inner.offsetTop !== 5 ),
</a><a name="line-3659" data-line="3659">			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
</a><a name="line-3660" data-line="3660">		};
</a><a name="line-3661" data-line="3661">
</a><a name="line-3662" data-line="3662">		inner.style.position = &quot;fixed&quot;;
</a><a name="line-3663" data-line="3663">		inner.style.top = &quot;20px&quot;;
</a><a name="line-3664" data-line="3664">
</a><a name="line-3665" data-line="3665">		// safari subtracts parent border width here which is 5px
</a><a name="line-3666" data-line="3666">		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
</a><a name="line-3667" data-line="3667">		inner.style.position = inner.style.top = &quot;&quot;;
</a><a name="line-3668" data-line="3668">
</a><a name="line-3669" data-line="3669">		outer.style.overflow = &quot;hidden&quot;;
</a><a name="line-3670" data-line="3670">		outer.style.position = &quot;relative&quot;;
</a><a name="line-3671" data-line="3671">
</a><a name="line-3672" data-line="3672">		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
</a><a name="line-3673" data-line="3673">		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );
</a><a name="line-3674" data-line="3674">
</a><a name="line-3675" data-line="3675">		if ( window.getComputedStyle ) {
</a><a name="line-3676" data-line="3676">			div.style.marginTop = &quot;1%&quot;;
</a><a name="line-3677" data-line="3677">			support.pixelMargin = ( window.getComputedStyle( div, null ) || { marginTop: 0 } ).marginTop !== &quot;1%&quot;;
</a><a name="line-3678" data-line="3678">		}
</a><a name="line-3679" data-line="3679">
</a><a name="line-3680" data-line="3680">		if ( typeof container.style.zoom !== &quot;undefined&quot; ) {
</a><a name="line-3681" data-line="3681">			container.style.zoom = 1;
</a><a name="line-3682" data-line="3682">		}
</a><a name="line-3683" data-line="3683">
</a><a name="line-3684" data-line="3684">		body.removeChild( container );
</a><a name="line-3685" data-line="3685">		marginDiv = div = container = null;
</a><a name="line-3686" data-line="3686">
</a><a name="line-3687" data-line="3687">		jQuery.extend( support, offsetSupport );
</a><a name="line-3688" data-line="3688">	});
</a><a name="line-3689" data-line="3689">
</a><a name="line-3690" data-line="3690">	return support;
</a><a name="line-3691" data-line="3691">})();
</a><a name="line-3692" data-line="3692">
</a><a name="line-3693" data-line="3693">
</a><a name="line-3694" data-line="3694">
</a><a name="line-3695" data-line="3695">
</a><a name="line-3696" data-line="3696">var rbrace = /^(?:\{.*\}|\[.*\])$/,
</a><a name="line-3697" data-line="3697">	rmultiDash = /([A-Z])/g;
</a><a name="line-3698" data-line="3698">
</a><a name="line-3699" data-line="3699">jQuery.extend({
</a><a name="line-3700" data-line="3700">	cache: {},
</a><a name="line-3701" data-line="3701">
</a><a name="line-3702" data-line="3702">	// Please use with caution
</a><a name="line-3703" data-line="3703">	uuid: 0,
</a><a name="line-3704" data-line="3704">
</a><a name="line-3705" data-line="3705">	// Unique for each copy of jQuery on the page
</a><a name="line-3706" data-line="3706">	// Non-digits removed to match rinlinejQuery
</a><a name="line-3707" data-line="3707">	expando: &quot;jQuery&quot; + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, &quot;&quot; ),
</a><a name="line-3708" data-line="3708">
</a><a name="line-3709" data-line="3709">	// The following elements throw uncatchable exceptions if you
</a><a name="line-3710" data-line="3710">	// attempt to add expando properties to them.
</a><a name="line-3711" data-line="3711">	noData: {
</a><a name="line-3712" data-line="3712">		&quot;embed&quot;: true,
</a><a name="line-3713" data-line="3713">		// Ban all objects except for Flash (which handle expandos)
</a><a name="line-3714" data-line="3714">		&quot;object&quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;,
</a><a name="line-3715" data-line="3715">		&quot;applet&quot;: true
</a><a name="line-3716" data-line="3716">	},
</a><a name="line-3717" data-line="3717">
</a><a name="line-3718" data-line="3718">	hasData: function( elem ) {
</a><a name="line-3719" data-line="3719">		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
</a><a name="line-3720" data-line="3720">		return !!elem &amp;&amp; !isEmptyDataObject( elem );
</a><a name="line-3721" data-line="3721">	},
</a><a name="line-3722" data-line="3722">
</a><a name="line-3723" data-line="3723">	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
</a><a name="line-3724" data-line="3724">		if ( !jQuery.acceptData( elem ) ) {
</a><a name="line-3725" data-line="3725">			return;
</a><a name="line-3726" data-line="3726">		}
</a><a name="line-3727" data-line="3727">
</a><a name="line-3728" data-line="3728">		var privateCache, thisCache, ret,
</a><a name="line-3729" data-line="3729">			internalKey = jQuery.expando,
</a><a name="line-3730" data-line="3730">			getByName = typeof name === &quot;string&quot;,
</a><a name="line-3731" data-line="3731">
</a><a name="line-3732" data-line="3732">			// We have to handle DOM nodes and JS objects differently because IE6-7
</a><a name="line-3733" data-line="3733">			// can't GC object references properly across the DOM-JS boundary
</a><a name="line-3734" data-line="3734">			isNode = elem.nodeType,
</a><a name="line-3735" data-line="3735">
</a><a name="line-3736" data-line="3736">			// Only DOM nodes need the global jQuery cache; JS object data is
</a><a name="line-3737" data-line="3737">			// attached directly to the object so GC can occur automatically
</a><a name="line-3738" data-line="3738">			cache = isNode ? jQuery.cache : elem,
</a><a name="line-3739" data-line="3739">
</a><a name="line-3740" data-line="3740">			// Only defining an ID for JS objects if its cache already exists allows
</a><a name="line-3741" data-line="3741">			// the code to shortcut on the same path as a DOM node with no cache
</a><a name="line-3742" data-line="3742">			id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;&amp; internalKey,
</a><a name="line-3743" data-line="3743">			isEvents = name === &quot;events&quot;;
</a><a name="line-3744" data-line="3744">
</a><a name="line-3745" data-line="3745">		// Avoid doing any more work than we need to when trying to get data on an
</a><a name="line-3746" data-line="3746">		// object that has no data at all
</a><a name="line-3747" data-line="3747">		if ( (!id || !cache[id] || (!isEvents &amp;&amp; !pvt &amp;&amp; !cache[id].data)) &amp;&amp; getByName &amp;&amp; data === undefined ) {
</a><a name="line-3748" data-line="3748">			return;
</a><a name="line-3749" data-line="3749">		}
</a><a name="line-3750" data-line="3750">
</a><a name="line-3751" data-line="3751">		if ( !id ) {
</a><a name="line-3752" data-line="3752">			// Only DOM nodes need a new unique ID for each element since their data
</a><a name="line-3753" data-line="3753">			// ends up in the global cache
</a><a name="line-3754" data-line="3754">			if ( isNode ) {
</a><a name="line-3755" data-line="3755">				elem[ internalKey ] = id = ++jQuery.uuid;
</a><a name="line-3756" data-line="3756">			} else {
</a><a name="line-3757" data-line="3757">				id = internalKey;
</a><a name="line-3758" data-line="3758">			}
</a><a name="line-3759" data-line="3759">		}
</a><a name="line-3760" data-line="3760">
</a><a name="line-3761" data-line="3761">		if ( !cache[ id ] ) {
</a><a name="line-3762" data-line="3762">			cache[ id ] = {};
</a><a name="line-3763" data-line="3763">
</a><a name="line-3764" data-line="3764">			// Avoids exposing jQuery metadata on plain JS objects when the object
</a><a name="line-3765" data-line="3765">			// is serialized using JSON.stringify
</a><a name="line-3766" data-line="3766">			if ( !isNode ) {
</a><a name="line-3767" data-line="3767">				cache[ id ].toJSON = jQuery.noop;
</a><a name="line-3768" data-line="3768">			}
</a><a name="line-3769" data-line="3769">		}
</a><a name="line-3770" data-line="3770">
</a><a name="line-3771" data-line="3771">		// An object can be passed to jQuery.data instead of a key/value pair; this gets
</a><a name="line-3772" data-line="3772">		// shallow copied over onto the existing cache
</a><a name="line-3773" data-line="3773">		if ( typeof name === &quot;object&quot; || typeof name === &quot;function&quot; ) {
</a><a name="line-3774" data-line="3774">			if ( pvt ) {
</a><a name="line-3775" data-line="3775">				cache[ id ] = jQuery.extend( cache[ id ], name );
</a><a name="line-3776" data-line="3776">			} else {
</a><a name="line-3777" data-line="3777">				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
</a><a name="line-3778" data-line="3778">			}
</a><a name="line-3779" data-line="3779">		}
</a><a name="line-3780" data-line="3780">
</a><a name="line-3781" data-line="3781">		privateCache = thisCache = cache[ id ];
</a><a name="line-3782" data-line="3782">
</a><a name="line-3783" data-line="3783">		// jQuery data() is stored in a separate object inside the object's internal data
</a><a name="line-3784" data-line="3784">		// cache in order to avoid key collisions between internal data and user-defined
</a><a name="line-3785" data-line="3785">		// data.
</a><a name="line-3786" data-line="3786">		if ( !pvt ) {
</a><a name="line-3787" data-line="3787">			if ( !thisCache.data ) {
</a><a name="line-3788" data-line="3788">				thisCache.data = {};
</a><a name="line-3789" data-line="3789">			}
</a><a name="line-3790" data-line="3790">
</a><a name="line-3791" data-line="3791">			thisCache = thisCache.data;
</a><a name="line-3792" data-line="3792">		}
</a><a name="line-3793" data-line="3793">
</a><a name="line-3794" data-line="3794">		if ( data !== undefined ) {
</a><a name="line-3795" data-line="3795">			thisCache[ jQuery.camelCase( name ) ] = data;
</a><a name="line-3796" data-line="3796">		}
</a><a name="line-3797" data-line="3797">
</a><a name="line-3798" data-line="3798">		// Users should not attempt to inspect the internal events object using jQuery.data,
</a><a name="line-3799" data-line="3799">		// it is undocumented and subject to change. But does anyone listen? No.
</a><a name="line-3800" data-line="3800">		if ( isEvents &amp;&amp; !thisCache[ name ] ) {
</a><a name="line-3801" data-line="3801">			return privateCache.events;
</a><a name="line-3802" data-line="3802">		}
</a><a name="line-3803" data-line="3803">
</a><a name="line-3804" data-line="3804">		// Check for both converted-to-camel and non-converted data property names
</a><a name="line-3805" data-line="3805">		// If a data property was specified
</a><a name="line-3806" data-line="3806">		if ( getByName ) {
</a><a name="line-3807" data-line="3807">
</a><a name="line-3808" data-line="3808">			// First Try to find as-is property data
</a><a name="line-3809" data-line="3809">			ret = thisCache[ name ];
</a><a name="line-3810" data-line="3810">
</a><a name="line-3811" data-line="3811">			// Test for null|undefined property data
</a><a name="line-3812" data-line="3812">			if ( ret == null ) {
</a><a name="line-3813" data-line="3813">
</a><a name="line-3814" data-line="3814">				// Try to find the camelCased property
</a><a name="line-3815" data-line="3815">				ret = thisCache[ jQuery.camelCase( name ) ];
</a><a name="line-3816" data-line="3816">			}
</a><a name="line-3817" data-line="3817">		} else {
</a><a name="line-3818" data-line="3818">			ret = thisCache;
</a><a name="line-3819" data-line="3819">		}
</a><a name="line-3820" data-line="3820">
</a><a name="line-3821" data-line="3821">		return ret;
</a><a name="line-3822" data-line="3822">	},
</a><a name="line-3823" data-line="3823">
</a><a name="line-3824" data-line="3824">	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
</a><a name="line-3825" data-line="3825">		if ( !jQuery.acceptData( elem ) ) {
</a><a name="line-3826" data-line="3826">			return;
</a><a name="line-3827" data-line="3827">		}
</a><a name="line-3828" data-line="3828">
</a><a name="line-3829" data-line="3829">		var thisCache, i, l,
</a><a name="line-3830" data-line="3830">
</a><a name="line-3831" data-line="3831">			// Reference to internal data cache key
</a><a name="line-3832" data-line="3832">			internalKey = jQuery.expando,
</a><a name="line-3833" data-line="3833">
</a><a name="line-3834" data-line="3834">			isNode = elem.nodeType,
</a><a name="line-3835" data-line="3835">
</a><a name="line-3836" data-line="3836">			// See jQuery.data for more information
</a><a name="line-3837" data-line="3837">			cache = isNode ? jQuery.cache : elem,
</a><a name="line-3838" data-line="3838">
</a><a name="line-3839" data-line="3839">			// See jQuery.data for more information
</a><a name="line-3840" data-line="3840">			id = isNode ? elem[ internalKey ] : internalKey;
</a><a name="line-3841" data-line="3841">
</a><a name="line-3842" data-line="3842">		// If there is already no cache entry for this object, there is no
</a><a name="line-3843" data-line="3843">		// purpose in continuing
</a><a name="line-3844" data-line="3844">		if ( !cache[ id ] ) {
</a><a name="line-3845" data-line="3845">			return;
</a><a name="line-3846" data-line="3846">		}
</a><a name="line-3847" data-line="3847">
</a><a name="line-3848" data-line="3848">		if ( name ) {
</a><a name="line-3849" data-line="3849">
</a><a name="line-3850" data-line="3850">			thisCache = pvt ? cache[ id ] : cache[ id ].data;
</a><a name="line-3851" data-line="3851">
</a><a name="line-3852" data-line="3852">			if ( thisCache ) {
</a><a name="line-3853" data-line="3853">
</a><a name="line-3854" data-line="3854">				// Support array or space separated string names for data keys
</a><a name="line-3855" data-line="3855">				if ( !jQuery.isArray( name ) ) {
</a><a name="line-3856" data-line="3856">
</a><a name="line-3857" data-line="3857">					// try the string as a key before any manipulation
</a><a name="line-3858" data-line="3858">					if ( name in thisCache ) {
</a><a name="line-3859" data-line="3859">						name = [ name ];
</a><a name="line-3860" data-line="3860">					} else {
</a><a name="line-3861" data-line="3861">
</a><a name="line-3862" data-line="3862">						// split the camel cased version by spaces unless a key with the spaces exists
</a><a name="line-3863" data-line="3863">						name = jQuery.camelCase( name );
</a><a name="line-3864" data-line="3864">						if ( name in thisCache ) {
</a><a name="line-3865" data-line="3865">							name = [ name ];
</a><a name="line-3866" data-line="3866">						} else {
</a><a name="line-3867" data-line="3867">							name = name.split( &quot; &quot; );
</a><a name="line-3868" data-line="3868">						}
</a><a name="line-3869" data-line="3869">					}
</a><a name="line-3870" data-line="3870">				}
</a><a name="line-3871" data-line="3871">
</a><a name="line-3872" data-line="3872">				for ( i = 0, l = name.length; i &lt; l; i++ ) {
</a><a name="line-3873" data-line="3873">					delete thisCache[ name[i] ];
</a><a name="line-3874" data-line="3874">				}
</a><a name="line-3875" data-line="3875">
</a><a name="line-3876" data-line="3876">				// If there is no data left in the cache, we want to continue
</a><a name="line-3877" data-line="3877">				// and let the cache object itself get destroyed
</a><a name="line-3878" data-line="3878">				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
</a><a name="line-3879" data-line="3879">					return;
</a><a name="line-3880" data-line="3880">				}
</a><a name="line-3881" data-line="3881">			}
</a><a name="line-3882" data-line="3882">		}
</a><a name="line-3883" data-line="3883">
</a><a name="line-3884" data-line="3884">		// See jQuery.data for more information
</a><a name="line-3885" data-line="3885">		if ( !pvt ) {
</a><a name="line-3886" data-line="3886">			delete cache[ id ].data;
</a><a name="line-3887" data-line="3887">
</a><a name="line-3888" data-line="3888">			// Don't destroy the parent cache unless the internal data object
</a><a name="line-3889" data-line="3889">			// had been the only thing left in it
</a><a name="line-3890" data-line="3890">			if ( !isEmptyDataObject(cache[ id ]) ) {
</a><a name="line-3891" data-line="3891">				return;
</a><a name="line-3892" data-line="3892">			}
</a><a name="line-3893" data-line="3893">		}
</a><a name="line-3894" data-line="3894">
</a><a name="line-3895" data-line="3895">		// Browsers that fail expando deletion also refuse to delete expandos on
</a><a name="line-3896" data-line="3896">		// the window, but it will allow it on all other JS objects; other browsers
</a><a name="line-3897" data-line="3897">		// don't care
</a><a name="line-3898" data-line="3898">		// Ensure that `cache` is not a window object #10080
</a><a name="line-3899" data-line="3899">		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
</a><a name="line-3900" data-line="3900">			delete cache[ id ];
</a><a name="line-3901" data-line="3901">		} else {
</a><a name="line-3902" data-line="3902">			cache[ id ] = null;
</a><a name="line-3903" data-line="3903">		}
</a><a name="line-3904" data-line="3904">
</a><a name="line-3905" data-line="3905">		// We destroyed the cache and need to eliminate the expando on the node to avoid
</a><a name="line-3906" data-line="3906">		// false lookups in the cache for entries that no longer exist
</a><a name="line-3907" data-line="3907">		if ( isNode ) {
</a><a name="line-3908" data-line="3908">			// IE does not allow us to delete expando properties from nodes,
</a><a name="line-3909" data-line="3909">			// nor does it have a removeAttribute function on Document nodes;
</a><a name="line-3910" data-line="3910">			// we must handle all of these cases
</a><a name="line-3911" data-line="3911">			if ( jQuery.support.deleteExpando ) {
</a><a name="line-3912" data-line="3912">				delete elem[ internalKey ];
</a><a name="line-3913" data-line="3913">			} else if ( elem.removeAttribute ) {
</a><a name="line-3914" data-line="3914">				elem.removeAttribute( internalKey );
</a><a name="line-3915" data-line="3915">			} else {
</a><a name="line-3916" data-line="3916">				elem[ internalKey ] = null;
</a><a name="line-3917" data-line="3917">			}
</a><a name="line-3918" data-line="3918">		}
</a><a name="line-3919" data-line="3919">	},
</a><a name="line-3920" data-line="3920">
</a><a name="line-3921" data-line="3921">	// For internal use only.
</a><a name="line-3922" data-line="3922">	_data: function( elem, name, data ) {
</a><a name="line-3923" data-line="3923">		return jQuery.data( elem, name, data, true );
</a><a name="line-3924" data-line="3924">	},
</a><a name="line-3925" data-line="3925">
</a><a name="line-3926" data-line="3926">	// A method for determining if a DOM node can handle the data expando
</a><a name="line-3927" data-line="3927">	acceptData: function( elem ) {
</a><a name="line-3928" data-line="3928">		if ( elem.nodeName ) {
</a><a name="line-3929" data-line="3929">			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];
</a><a name="line-3930" data-line="3930">
</a><a name="line-3931" data-line="3931">			if ( match ) {
</a><a name="line-3932" data-line="3932">				return !(match === true || elem.getAttribute(&quot;classid&quot;) !== match);
</a><a name="line-3933" data-line="3933">			}
</a><a name="line-3934" data-line="3934">		}
</a><a name="line-3935" data-line="3935">
</a><a name="line-3936" data-line="3936">		return true;
</a><a name="line-3937" data-line="3937">	}
</a><a name="line-3938" data-line="3938">});
</a><a name="line-3939" data-line="3939">
</a><a name="line-3940" data-line="3940">jQuery.fn.extend({
</a><a name="line-3941" data-line="3941">	data: function( key, value ) {
</a><a name="line-3942" data-line="3942">		var parts, part, attr, name, l,
</a><a name="line-3943" data-line="3943">			elem = this[0],
</a><a name="line-3944" data-line="3944">			i = 0,
</a><a name="line-3945" data-line="3945">			data = null;
</a><a name="line-3946" data-line="3946">
</a><a name="line-3947" data-line="3947">		// Gets all values
</a><a name="line-3948" data-line="3948">		if ( key === undefined ) {
</a><a name="line-3949" data-line="3949">			if ( this.length ) {
</a><a name="line-3950" data-line="3950">				data = jQuery.data( elem );
</a><a name="line-3951" data-line="3951">
</a><a name="line-3952" data-line="3952">				if ( elem.nodeType === 1 &amp;&amp; !jQuery._data( elem, &quot;parsedAttrs&quot; ) ) {
</a><a name="line-3953" data-line="3953">					attr = elem.attributes;
</a><a name="line-3954" data-line="3954">					for ( l = attr.length; i &lt; l; i++ ) {
</a><a name="line-3955" data-line="3955">						name = attr[i].name;
</a><a name="line-3956" data-line="3956">
</a><a name="line-3957" data-line="3957">						if ( name.indexOf( &quot;data-&quot; ) === 0 ) {
</a><a name="line-3958" data-line="3958">							name = jQuery.camelCase( name.substring(5) );
</a><a name="line-3959" data-line="3959">
</a><a name="line-3960" data-line="3960">							dataAttr( elem, name, data[ name ] );
</a><a name="line-3961" data-line="3961">						}
</a><a name="line-3962" data-line="3962">					}
</a><a name="line-3963" data-line="3963">					jQuery._data( elem, &quot;parsedAttrs&quot;, true );
</a><a name="line-3964" data-line="3964">				}
</a><a name="line-3965" data-line="3965">			}
</a><a name="line-3966" data-line="3966">
</a><a name="line-3967" data-line="3967">			return data;
</a><a name="line-3968" data-line="3968">		}
</a><a name="line-3969" data-line="3969">
</a><a name="line-3970" data-line="3970">		// Sets multiple values
</a><a name="line-3971" data-line="3971">		if ( typeof key === &quot;object&quot; ) {
</a><a name="line-3972" data-line="3972">			return this.each(function() {
</a><a name="line-3973" data-line="3973">				jQuery.data( this, key );
</a><a name="line-3974" data-line="3974">			});
</a><a name="line-3975" data-line="3975">		}
</a><a name="line-3976" data-line="3976">
</a><a name="line-3977" data-line="3977">		parts = key.split( &quot;.&quot;, 2 );
</a><a name="line-3978" data-line="3978">		parts[1] = parts[1] ? &quot;.&quot; + parts[1] : &quot;&quot;;
</a><a name="line-3979" data-line="3979">		part = parts[1] + &quot;!&quot;;
</a><a name="line-3980" data-line="3980">
</a><a name="line-3981" data-line="3981">		return jQuery.access( this, function( value ) {
</a><a name="line-3982" data-line="3982">
</a><a name="line-3983" data-line="3983">			if ( value === undefined ) {
</a><a name="line-3984" data-line="3984">				data = this.triggerHandler( &quot;getData&quot; + part, [ parts[0] ] );
</a><a name="line-3985" data-line="3985">
</a><a name="line-3986" data-line="3986">				// Try to fetch any internally stored data first
</a><a name="line-3987" data-line="3987">				if ( data === undefined &amp;&amp; elem ) {
</a><a name="line-3988" data-line="3988">					data = jQuery.data( elem, key );
</a><a name="line-3989" data-line="3989">					data = dataAttr( elem, key, data );
</a><a name="line-3990" data-line="3990">				}
</a><a name="line-3991" data-line="3991">
</a><a name="line-3992" data-line="3992">				return data === undefined &amp;&amp; parts[1] ?
</a><a name="line-3993" data-line="3993">					this.data( parts[0] ) :
</a><a name="line-3994" data-line="3994">					data;
</a><a name="line-3995" data-line="3995">			}
</a><a name="line-3996" data-line="3996">
</a><a name="line-3997" data-line="3997">			parts[1] = value;
</a><a name="line-3998" data-line="3998">			this.each(function() {
</a><a name="line-3999" data-line="3999">				var self = jQuery( this );
</a><a name="line-4000" data-line="4000">
</a><a name="line-4001" data-line="4001">				self.triggerHandler( &quot;setData&quot; + part, parts );
</a><a name="line-4002" data-line="4002">				jQuery.data( this, key, value );
</a><a name="line-4003" data-line="4003">				self.triggerHandler( &quot;changeData&quot; + part, parts );
</a><a name="line-4004" data-line="4004">			});
</a><a name="line-4005" data-line="4005">		}, null, value, arguments.length &gt; 1, null, false );
</a><a name="line-4006" data-line="4006">	},
</a><a name="line-4007" data-line="4007">
</a><a name="line-4008" data-line="4008">	removeData: function( key ) {
</a><a name="line-4009" data-line="4009">		return this.each(function() {
</a><a name="line-4010" data-line="4010">			jQuery.removeData( this, key );
</a><a name="line-4011" data-line="4011">		});
</a><a name="line-4012" data-line="4012">	}
</a><a name="line-4013" data-line="4013">});
</a><a name="line-4014" data-line="4014">
</a><a name="line-4015" data-line="4015">function dataAttr( elem, key, data ) {
</a><a name="line-4016" data-line="4016">	// If nothing was found internally, try to fetch any
</a><a name="line-4017" data-line="4017">	// data from the HTML5 data-* attribute
</a><a name="line-4018" data-line="4018">	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {
</a><a name="line-4019" data-line="4019">
</a><a name="line-4020" data-line="4020">		var name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$1&quot; ).toLowerCase();
</a><a name="line-4021" data-line="4021">
</a><a name="line-4022" data-line="4022">		data = elem.getAttribute( name );
</a><a name="line-4023" data-line="4023">
</a><a name="line-4024" data-line="4024">		if ( typeof data === &quot;string&quot; ) {
</a><a name="line-4025" data-line="4025">			try {
</a><a name="line-4026" data-line="4026">				data = data === &quot;true&quot; ? true :
</a><a name="line-4027" data-line="4027">				data === &quot;false&quot; ? false :
</a><a name="line-4028" data-line="4028">				data === &quot;null&quot; ? null :
</a><a name="line-4029" data-line="4029">				jQuery.isNumeric( data ) ? +data :
</a><a name="line-4030" data-line="4030">					rbrace.test( data ) ? jQuery.parseJSON( data ) :
</a><a name="line-4031" data-line="4031">					data;
</a><a name="line-4032" data-line="4032">			} catch( e ) {}
</a><a name="line-4033" data-line="4033">
</a><a name="line-4034" data-line="4034">			// Make sure we set the data so it isn't changed later
</a><a name="line-4035" data-line="4035">			jQuery.data( elem, key, data );
</a><a name="line-4036" data-line="4036">
</a><a name="line-4037" data-line="4037">		} else {
</a><a name="line-4038" data-line="4038">			data = undefined;
</a><a name="line-4039" data-line="4039">		}
</a><a name="line-4040" data-line="4040">	}
</a><a name="line-4041" data-line="4041">
</a><a name="line-4042" data-line="4042">	return data;
</a><a name="line-4043" data-line="4043">}
</a><a name="line-4044" data-line="4044">
</a><a name="line-4045" data-line="4045">// checks a cache object for emptiness
</a><a name="line-4046" data-line="4046">function isEmptyDataObject( obj ) {
</a><a name="line-4047" data-line="4047">	for ( var name in obj ) {
</a><a name="line-4048" data-line="4048">
</a><a name="line-4049" data-line="4049">		// if the public data object is empty, the private is still empty
</a><a name="line-4050" data-line="4050">		if ( name === &quot;data&quot; &amp;&amp; jQuery.isEmptyObject( obj[name] ) ) {
</a><a name="line-4051" data-line="4051">			continue;
</a><a name="line-4052" data-line="4052">		}
</a><a name="line-4053" data-line="4053">		if ( name !== &quot;toJSON&quot; ) {
</a><a name="line-4054" data-line="4054">			return false;
</a><a name="line-4055" data-line="4055">		}
</a><a name="line-4056" data-line="4056">	}
</a><a name="line-4057" data-line="4057">
</a><a name="line-4058" data-line="4058">	return true;
</a><a name="line-4059" data-line="4059">}
</a><a name="line-4060" data-line="4060">
</a><a name="line-4061" data-line="4061">
</a><a name="line-4062" data-line="4062">
</a><a name="line-4063" data-line="4063">
</a><a name="line-4064" data-line="4064">function handleQueueMarkDefer( elem, type, src ) {
</a><a name="line-4065" data-line="4065">	var deferDataKey = type + &quot;defer&quot;,
</a><a name="line-4066" data-line="4066">		queueDataKey = type + &quot;queue&quot;,
</a><a name="line-4067" data-line="4067">		markDataKey = type + &quot;mark&quot;,
</a><a name="line-4068" data-line="4068">		defer = jQuery._data( elem, deferDataKey );
</a><a name="line-4069" data-line="4069">	if ( defer &amp;&amp;
</a><a name="line-4070" data-line="4070">		( src === &quot;queue&quot; || !jQuery._data(elem, queueDataKey) ) &amp;&amp;
</a><a name="line-4071" data-line="4071">		( src === &quot;mark&quot; || !jQuery._data(elem, markDataKey) ) ) {
</a><a name="line-4072" data-line="4072">		// Give room for hard-coded callbacks to fire first
</a><a name="line-4073" data-line="4073">		// and eventually mark/queue something else on the element
</a><a name="line-4074" data-line="4074">		setTimeout( function() {
</a><a name="line-4075" data-line="4075">			if ( !jQuery._data( elem, queueDataKey ) &amp;&amp;
</a><a name="line-4076" data-line="4076">				!jQuery._data( elem, markDataKey ) ) {
</a><a name="line-4077" data-line="4077">				jQuery.removeData( elem, deferDataKey, true );
</a><a name="line-4078" data-line="4078">				defer.fire();
</a><a name="line-4079" data-line="4079">			}
</a><a name="line-4080" data-line="4080">		}, 0 );
</a><a name="line-4081" data-line="4081">	}
</a><a name="line-4082" data-line="4082">}
</a><a name="line-4083" data-line="4083">
</a><a name="line-4084" data-line="4084">jQuery.extend({
</a><a name="line-4085" data-line="4085">
</a><a name="line-4086" data-line="4086">	_mark: function( elem, type ) {
</a><a name="line-4087" data-line="4087">		if ( elem ) {
</a><a name="line-4088" data-line="4088">			type = ( type || &quot;fx&quot; ) + &quot;mark&quot;;
</a><a name="line-4089" data-line="4089">			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
</a><a name="line-4090" data-line="4090">		}
</a><a name="line-4091" data-line="4091">	},
</a><a name="line-4092" data-line="4092">
</a><a name="line-4093" data-line="4093">	_unmark: function( force, elem, type ) {
</a><a name="line-4094" data-line="4094">		if ( force !== true ) {
</a><a name="line-4095" data-line="4095">			type = elem;
</a><a name="line-4096" data-line="4096">			elem = force;
</a><a name="line-4097" data-line="4097">			force = false;
</a><a name="line-4098" data-line="4098">		}
</a><a name="line-4099" data-line="4099">		if ( elem ) {
</a><a name="line-4100" data-line="4100">			type = type || &quot;fx&quot;;
</a><a name="line-4101" data-line="4101">			var key = type + &quot;mark&quot;,
</a><a name="line-4102" data-line="4102">				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
</a><a name="line-4103" data-line="4103">			if ( count ) {
</a><a name="line-4104" data-line="4104">				jQuery._data( elem, key, count );
</a><a name="line-4105" data-line="4105">			} else {
</a><a name="line-4106" data-line="4106">				jQuery.removeData( elem, key, true );
</a><a name="line-4107" data-line="4107">				handleQueueMarkDefer( elem, type, &quot;mark&quot; );
</a><a name="line-4108" data-line="4108">			}
</a><a name="line-4109" data-line="4109">		}
</a><a name="line-4110" data-line="4110">	},
</a><a name="line-4111" data-line="4111">
</a><a name="line-4112" data-line="4112">	queue: function( elem, type, data ) {
</a><a name="line-4113" data-line="4113">		var q;
</a><a name="line-4114" data-line="4114">		if ( elem ) {
</a><a name="line-4115" data-line="4115">			type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
</a><a name="line-4116" data-line="4116">			q = jQuery._data( elem, type );
</a><a name="line-4117" data-line="4117">
</a><a name="line-4118" data-line="4118">			// Speed up dequeue by getting out quickly if this is just a lookup
</a><a name="line-4119" data-line="4119">			if ( data ) {
</a><a name="line-4120" data-line="4120">				if ( !q || jQuery.isArray(data) ) {
</a><a name="line-4121" data-line="4121">					q = jQuery._data( elem, type, jQuery.makeArray(data) );
</a><a name="line-4122" data-line="4122">				} else {
</a><a name="line-4123" data-line="4123">					q.push( data );
</a><a name="line-4124" data-line="4124">				}
</a><a name="line-4125" data-line="4125">			}
</a><a name="line-4126" data-line="4126">			return q || [];
</a><a name="line-4127" data-line="4127">		}
</a><a name="line-4128" data-line="4128">	},
</a><a name="line-4129" data-line="4129">
</a><a name="line-4130" data-line="4130">	dequeue: function( elem, type ) {
</a><a name="line-4131" data-line="4131">		type = type || &quot;fx&quot;;
</a><a name="line-4132" data-line="4132">
</a><a name="line-4133" data-line="4133">		var queue = jQuery.queue( elem, type ),
</a><a name="line-4134" data-line="4134">			fn = queue.shift(),
</a><a name="line-4135" data-line="4135">			hooks = {};
</a><a name="line-4136" data-line="4136">
</a><a name="line-4137" data-line="4137">		// If the fx queue is dequeued, always remove the progress sentinel
</a><a name="line-4138" data-line="4138">		if ( fn === &quot;inprogress&quot; ) {
</a><a name="line-4139" data-line="4139">			fn = queue.shift();
</a><a name="line-4140" data-line="4140">		}
</a><a name="line-4141" data-line="4141">
</a><a name="line-4142" data-line="4142">		if ( fn ) {
</a><a name="line-4143" data-line="4143">			// Add a progress sentinel to prevent the fx queue from being
</a><a name="line-4144" data-line="4144">			// automatically dequeued
</a><a name="line-4145" data-line="4145">			if ( type === &quot;fx&quot; ) {
</a><a name="line-4146" data-line="4146">				queue.unshift( &quot;inprogress&quot; );
</a><a name="line-4147" data-line="4147">			}
</a><a name="line-4148" data-line="4148">
</a><a name="line-4149" data-line="4149">			jQuery._data( elem, type + &quot;.run&quot;, hooks );
</a><a name="line-4150" data-line="4150">			fn.call( elem, function() {
</a><a name="line-4151" data-line="4151">				jQuery.dequeue( elem, type );
</a><a name="line-4152" data-line="4152">			}, hooks );
</a><a name="line-4153" data-line="4153">		}
</a><a name="line-4154" data-line="4154">
</a><a name="line-4155" data-line="4155">		if ( !queue.length ) {
</a><a name="line-4156" data-line="4156">			jQuery.removeData( elem, type + &quot;queue &quot; + type + &quot;.run&quot;, true );
</a><a name="line-4157" data-line="4157">			handleQueueMarkDefer( elem, type, &quot;queue&quot; );
</a><a name="line-4158" data-line="4158">		}
</a><a name="line-4159" data-line="4159">	}
</a><a name="line-4160" data-line="4160">});
</a><a name="line-4161" data-line="4161">
</a><a name="line-4162" data-line="4162">jQuery.fn.extend({
</a><a name="line-4163" data-line="4163">	queue: function( type, data ) {
</a><a name="line-4164" data-line="4164">		var setter = 2;
</a><a name="line-4165" data-line="4165">
</a><a name="line-4166" data-line="4166">		if ( typeof type !== &quot;string&quot; ) {
</a><a name="line-4167" data-line="4167">			data = type;
</a><a name="line-4168" data-line="4168">			type = &quot;fx&quot;;
</a><a name="line-4169" data-line="4169">			setter--;
</a><a name="line-4170" data-line="4170">		}
</a><a name="line-4171" data-line="4171">
</a><a name="line-4172" data-line="4172">		if ( arguments.length &lt; setter ) {
</a><a name="line-4173" data-line="4173">			return jQuery.queue( this[0], type );
</a><a name="line-4174" data-line="4174">		}
</a><a name="line-4175" data-line="4175">
</a><a name="line-4176" data-line="4176">		return data === undefined ?
</a><a name="line-4177" data-line="4177">			this :
</a><a name="line-4178" data-line="4178">			this.each(function() {
</a><a name="line-4179" data-line="4179">				var queue = jQuery.queue( this, type, data );
</a><a name="line-4180" data-line="4180">
</a><a name="line-4181" data-line="4181">				if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {
</a><a name="line-4182" data-line="4182">					jQuery.dequeue( this, type );
</a><a name="line-4183" data-line="4183">				}
</a><a name="line-4184" data-line="4184">			});
</a><a name="line-4185" data-line="4185">	},
</a><a name="line-4186" data-line="4186">	dequeue: function( type ) {
</a><a name="line-4187" data-line="4187">		return this.each(function() {
</a><a name="line-4188" data-line="4188">			jQuery.dequeue( this, type );
</a><a name="line-4189" data-line="4189">		});
</a><a name="line-4190" data-line="4190">	},
</a><a name="line-4191" data-line="4191">	// Based off of the plugin by Clint Helfers, with permission.
</a><a name="line-4192" data-line="4192">	// http://blindsignals.com/index.php/2009/07/jquery-delay/
</a><a name="line-4193" data-line="4193">	delay: function( time, type ) {
</a><a name="line-4194" data-line="4194">		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
</a><a name="line-4195" data-line="4195">		type = type || &quot;fx&quot;;
</a><a name="line-4196" data-line="4196">
</a><a name="line-4197" data-line="4197">		return this.queue( type, function( next, hooks ) {
</a><a name="line-4198" data-line="4198">			var timeout = setTimeout( next, time );
</a><a name="line-4199" data-line="4199">			hooks.stop = function() {
</a><a name="line-4200" data-line="4200">				clearTimeout( timeout );
</a><a name="line-4201" data-line="4201">			};
</a><a name="line-4202" data-line="4202">		});
</a><a name="line-4203" data-line="4203">	},
</a><a name="line-4204" data-line="4204">	clearQueue: function( type ) {
</a><a name="line-4205" data-line="4205">		return this.queue( type || &quot;fx&quot;, [] );
</a><a name="line-4206" data-line="4206">	},
</a><a name="line-4207" data-line="4207">	// Get a promise resolved when queues of a certain type
</a><a name="line-4208" data-line="4208">	// are emptied (fx is the type by default)
</a><a name="line-4209" data-line="4209">	promise: function( type, object ) {
</a><a name="line-4210" data-line="4210">		if ( typeof type !== &quot;string&quot; ) {
</a><a name="line-4211" data-line="4211">			object = type;
</a><a name="line-4212" data-line="4212">			type = undefined;
</a><a name="line-4213" data-line="4213">		}
</a><a name="line-4214" data-line="4214">		type = type || &quot;fx&quot;;
</a><a name="line-4215" data-line="4215">		var defer = jQuery.Deferred(),
</a><a name="line-4216" data-line="4216">			elements = this,
</a><a name="line-4217" data-line="4217">			i = elements.length,
</a><a name="line-4218" data-line="4218">			count = 1,
</a><a name="line-4219" data-line="4219">			deferDataKey = type + &quot;defer&quot;,
</a><a name="line-4220" data-line="4220">			queueDataKey = type + &quot;queue&quot;,
</a><a name="line-4221" data-line="4221">			markDataKey = type + &quot;mark&quot;,
</a><a name="line-4222" data-line="4222">			tmp;
</a><a name="line-4223" data-line="4223">		function resolve() {
</a><a name="line-4224" data-line="4224">			if ( !( --count ) ) {
</a><a name="line-4225" data-line="4225">				defer.resolveWith( elements, [ elements ] );
</a><a name="line-4226" data-line="4226">			}
</a><a name="line-4227" data-line="4227">		}
</a><a name="line-4228" data-line="4228">		while( i-- ) {
</a><a name="line-4229" data-line="4229">			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
</a><a name="line-4230" data-line="4230">					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
</a><a name="line-4231" data-line="4231">						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &amp;&amp;
</a><a name="line-4232" data-line="4232">					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( &quot;once memory&quot; ), true ) )) {
</a><a name="line-4233" data-line="4233">				count++;
</a><a name="line-4234" data-line="4234">				tmp.add( resolve );
</a><a name="line-4235" data-line="4235">			}
</a><a name="line-4236" data-line="4236">		}
</a><a name="line-4237" data-line="4237">		resolve();
</a><a name="line-4238" data-line="4238">		return defer.promise( object );
</a><a name="line-4239" data-line="4239">	}
</a><a name="line-4240" data-line="4240">});
</a><a name="line-4241" data-line="4241">
</a><a name="line-4242" data-line="4242">
</a><a name="line-4243" data-line="4243">
</a><a name="line-4244" data-line="4244">
</a><a name="line-4245" data-line="4245">var rclass = /[\n\t\r]/g,
</a><a name="line-4246" data-line="4246">	rspace = /\s+/,
</a><a name="line-4247" data-line="4247">	rreturn = /\r/g,
</a><a name="line-4248" data-line="4248">	rtype = /^(?:button|input)$/i,
</a><a name="line-4249" data-line="4249">	rfocusable = /^(?:button|input|object|select|textarea)$/i,
</a><a name="line-4250" data-line="4250">	rclickable = /^a(?:rea)?$/i,
</a><a name="line-4251" data-line="4251">	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
</a><a name="line-4252" data-line="4252">	getSetAttribute = jQuery.support.getSetAttribute,
</a><a name="line-4253" data-line="4253">	nodeHook, boolHook, fixSpecified;
</a><a name="line-4254" data-line="4254">
</a><a name="line-4255" data-line="4255">jQuery.fn.extend({
</a><a name="line-4256" data-line="4256">	attr: function( name, value ) {
</a><a name="line-4257" data-line="4257">		return jQuery.access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
</a><a name="line-4258" data-line="4258">	},
</a><a name="line-4259" data-line="4259">
</a><a name="line-4260" data-line="4260">	removeAttr: function( name ) {
</a><a name="line-4261" data-line="4261">		return this.each(function() {
</a><a name="line-4262" data-line="4262">			jQuery.removeAttr( this, name );
</a><a name="line-4263" data-line="4263">		});
</a><a name="line-4264" data-line="4264">	},
</a><a name="line-4265" data-line="4265">
</a><a name="line-4266" data-line="4266">	prop: function( name, value ) {
</a><a name="line-4267" data-line="4267">		return jQuery.access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
</a><a name="line-4268" data-line="4268">	},
</a><a name="line-4269" data-line="4269">
</a><a name="line-4270" data-line="4270">	removeProp: function( name ) {
</a><a name="line-4271" data-line="4271">		name = jQuery.propFix[ name ] || name;
</a><a name="line-4272" data-line="4272">		return this.each(function() {
</a><a name="line-4273" data-line="4273">			// try/catch handles cases where IE balks (such as removing a property on window)
</a><a name="line-4274" data-line="4274">			try {
</a><a name="line-4275" data-line="4275">				this[ name ] = undefined;
</a><a name="line-4276" data-line="4276">				delete this[ name ];
</a><a name="line-4277" data-line="4277">			} catch( e ) {}
</a><a name="line-4278" data-line="4278">		});
</a><a name="line-4279" data-line="4279">	},
</a><a name="line-4280" data-line="4280">
</a><a name="line-4281" data-line="4281">	addClass: function( value ) {
</a><a name="line-4282" data-line="4282">		var classNames, i, l, elem,
</a><a name="line-4283" data-line="4283">			setClass, c, cl;
</a><a name="line-4284" data-line="4284">
</a><a name="line-4285" data-line="4285">		if ( jQuery.isFunction( value ) ) {
</a><a name="line-4286" data-line="4286">			return this.each(function( j ) {
</a><a name="line-4287" data-line="4287">				jQuery( this ).addClass( value.call(this, j, this.className) );
</a><a name="line-4288" data-line="4288">			});
</a><a name="line-4289" data-line="4289">		}
</a><a name="line-4290" data-line="4290">
</a><a name="line-4291" data-line="4291">		if ( value &amp;&amp; typeof value === &quot;string&quot; ) {
</a><a name="line-4292" data-line="4292">			classNames = value.split( rspace );
</a><a name="line-4293" data-line="4293">
</a><a name="line-4294" data-line="4294">			for ( i = 0, l = this.length; i &lt; l; i++ ) {
</a><a name="line-4295" data-line="4295">				elem = this[ i ];
</a><a name="line-4296" data-line="4296">
</a><a name="line-4297" data-line="4297">				if ( elem.nodeType === 1 ) {
</a><a name="line-4298" data-line="4298">					if ( !elem.className &amp;&amp; classNames.length === 1 ) {
</a><a name="line-4299" data-line="4299">						elem.className = value;
</a><a name="line-4300" data-line="4300">
</a><a name="line-4301" data-line="4301">					} else {
</a><a name="line-4302" data-line="4302">						setClass = &quot; &quot; + elem.className + &quot; &quot;;
</a><a name="line-4303" data-line="4303">
</a><a name="line-4304" data-line="4304">						for ( c = 0, cl = classNames.length; c &lt; cl; c++ ) {
</a><a name="line-4305" data-line="4305">							if ( !~setClass.indexOf( &quot; &quot; + classNames[ c ] + &quot; &quot; ) ) {
</a><a name="line-4306" data-line="4306">								setClass += classNames[ c ] + &quot; &quot;;
</a><a name="line-4307" data-line="4307">							}
</a><a name="line-4308" data-line="4308">						}
</a><a name="line-4309" data-line="4309">						elem.className = jQuery.trim( setClass );
</a><a name="line-4310" data-line="4310">					}
</a><a name="line-4311" data-line="4311">				}
</a><a name="line-4312" data-line="4312">			}
</a><a name="line-4313" data-line="4313">		}
</a><a name="line-4314" data-line="4314">
</a><a name="line-4315" data-line="4315">		return this;
</a><a name="line-4316" data-line="4316">	},
</a><a name="line-4317" data-line="4317">
</a><a name="line-4318" data-line="4318">	removeClass: function( value ) {
</a><a name="line-4319" data-line="4319">		var classNames, i, l, elem, className, c, cl;
</a><a name="line-4320" data-line="4320">
</a><a name="line-4321" data-line="4321">		if ( jQuery.isFunction( value ) ) {
</a><a name="line-4322" data-line="4322">			return this.each(function( j ) {
</a><a name="line-4323" data-line="4323">				jQuery( this ).removeClass( value.call(this, j, this.className) );
</a><a name="line-4324" data-line="4324">			});
</a><a name="line-4325" data-line="4325">		}
</a><a name="line-4326" data-line="4326">
</a><a name="line-4327" data-line="4327">		if ( (value &amp;&amp; typeof value === &quot;string&quot;) || value === undefined ) {
</a><a name="line-4328" data-line="4328">			classNames = ( value || &quot;&quot; ).split( rspace );
</a><a name="line-4329" data-line="4329">
</a><a name="line-4330" data-line="4330">			for ( i = 0, l = this.length; i &lt; l; i++ ) {
</a><a name="line-4331" data-line="4331">				elem = this[ i ];
</a><a name="line-4332" data-line="4332">
</a><a name="line-4333" data-line="4333">				if ( elem.nodeType === 1 &amp;&amp; elem.className ) {
</a><a name="line-4334" data-line="4334">					if ( value ) {
</a><a name="line-4335" data-line="4335">						className = (&quot; &quot; + elem.className + &quot; &quot;).replace( rclass, &quot; &quot; );
</a><a name="line-4336" data-line="4336">						for ( c = 0, cl = classNames.length; c &lt; cl; c++ ) {
</a><a name="line-4337" data-line="4337">							className = className.replace(&quot; &quot; + classNames[ c ] + &quot; &quot;, &quot; &quot;);
</a><a name="line-4338" data-line="4338">						}
</a><a name="line-4339" data-line="4339">						elem.className = jQuery.trim( className );
</a><a name="line-4340" data-line="4340">
</a><a name="line-4341" data-line="4341">					} else {
</a><a name="line-4342" data-line="4342">						elem.className = &quot;&quot;;
</a><a name="line-4343" data-line="4343">					}
</a><a name="line-4344" data-line="4344">				}
</a><a name="line-4345" data-line="4345">			}
</a><a name="line-4346" data-line="4346">		}
</a><a name="line-4347" data-line="4347">
</a><a name="line-4348" data-line="4348">		return this;
</a><a name="line-4349" data-line="4349">	},
</a><a name="line-4350" data-line="4350">
</a><a name="line-4351" data-line="4351">	toggleClass: function( value, stateVal ) {
</a><a name="line-4352" data-line="4352">		var type = typeof value,
</a><a name="line-4353" data-line="4353">			isBool = typeof stateVal === &quot;boolean&quot;;
</a><a name="line-4354" data-line="4354">
</a><a name="line-4355" data-line="4355">		if ( jQuery.isFunction( value ) ) {
</a><a name="line-4356" data-line="4356">			return this.each(function( i ) {
</a><a name="line-4357" data-line="4357">				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
</a><a name="line-4358" data-line="4358">			});
</a><a name="line-4359" data-line="4359">		}
</a><a name="line-4360" data-line="4360">
</a><a name="line-4361" data-line="4361">		return this.each(function() {
</a><a name="line-4362" data-line="4362">			if ( type === &quot;string&quot; ) {
</a><a name="line-4363" data-line="4363">				// toggle individual class names
</a><a name="line-4364" data-line="4364">				var className,
</a><a name="line-4365" data-line="4365">					i = 0,
</a><a name="line-4366" data-line="4366">					self = jQuery( this ),
</a><a name="line-4367" data-line="4367">					state = stateVal,
</a><a name="line-4368" data-line="4368">					classNames = value.split( rspace );
</a><a name="line-4369" data-line="4369">
</a><a name="line-4370" data-line="4370">				while ( (className = classNames[ i++ ]) ) {
</a><a name="line-4371" data-line="4371">					// check each className given, space seperated list
</a><a name="line-4372" data-line="4372">					state = isBool ? state : !self.hasClass( className );
</a><a name="line-4373" data-line="4373">					self[ state ? &quot;addClass&quot; : &quot;removeClass&quot; ]( className );
</a><a name="line-4374" data-line="4374">				}
</a><a name="line-4375" data-line="4375">
</a><a name="line-4376" data-line="4376">			} else if ( type === &quot;undefined&quot; || type === &quot;boolean&quot; ) {
</a><a name="line-4377" data-line="4377">				if ( this.className ) {
</a><a name="line-4378" data-line="4378">					// store className if set
</a><a name="line-4379" data-line="4379">					jQuery._data( this, &quot;__className__&quot;, this.className );
</a><a name="line-4380" data-line="4380">				}
</a><a name="line-4381" data-line="4381">
</a><a name="line-4382" data-line="4382">				// toggle whole className
</a><a name="line-4383" data-line="4383">				this.className = this.className || value === false ? &quot;&quot; : jQuery._data( this, &quot;__className__&quot; ) || &quot;&quot;;
</a><a name="line-4384" data-line="4384">			}
</a><a name="line-4385" data-line="4385">		});
</a><a name="line-4386" data-line="4386">	},
</a><a name="line-4387" data-line="4387">
</a><a name="line-4388" data-line="4388">	hasClass: function( selector ) {
</a><a name="line-4389" data-line="4389">		var className = &quot; &quot; + selector + &quot; &quot;,
</a><a name="line-4390" data-line="4390">			i = 0,
</a><a name="line-4391" data-line="4391">			l = this.length;
</a><a name="line-4392" data-line="4392">		for ( ; i &lt; l; i++ ) {
</a><a name="line-4393" data-line="4393">			if ( this[i].nodeType === 1 &amp;&amp; (&quot; &quot; + this[i].className + &quot; &quot;).replace(rclass, &quot; &quot;).indexOf( className ) &gt; -1 ) {
</a><a name="line-4394" data-line="4394">				return true;
</a><a name="line-4395" data-line="4395">			}
</a><a name="line-4396" data-line="4396">		}
</a><a name="line-4397" data-line="4397">
</a><a name="line-4398" data-line="4398">		return false;
</a><a name="line-4399" data-line="4399">	},
</a><a name="line-4400" data-line="4400">
</a><a name="line-4401" data-line="4401">	val: function( value ) {
</a><a name="line-4402" data-line="4402">		var hooks, ret, isFunction,
</a><a name="line-4403" data-line="4403">			elem = this[0];
</a><a name="line-4404" data-line="4404">
</a><a name="line-4405" data-line="4405">		if ( !arguments.length ) {
</a><a name="line-4406" data-line="4406">			if ( elem ) {
</a><a name="line-4407" data-line="4407">				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
</a><a name="line-4408" data-line="4408">
</a><a name="line-4409" data-line="4409">				if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, &quot;value&quot; )) !== undefined ) {
</a><a name="line-4410" data-line="4410">					return ret;
</a><a name="line-4411" data-line="4411">				}
</a><a name="line-4412" data-line="4412">
</a><a name="line-4413" data-line="4413">				ret = elem.value;
</a><a name="line-4414" data-line="4414">
</a><a name="line-4415" data-line="4415">				return typeof ret === &quot;string&quot; ?
</a><a name="line-4416" data-line="4416">					// handle most common string cases
</a><a name="line-4417" data-line="4417">					ret.replace(rreturn, &quot;&quot;) :
</a><a name="line-4418" data-line="4418">					// handle cases where value is null/undef or number
</a><a name="line-4419" data-line="4419">					ret == null ? &quot;&quot; : ret;
</a><a name="line-4420" data-line="4420">			}
</a><a name="line-4421" data-line="4421">
</a><a name="line-4422" data-line="4422">			return;
</a><a name="line-4423" data-line="4423">		}
</a><a name="line-4424" data-line="4424">
</a><a name="line-4425" data-line="4425">		isFunction = jQuery.isFunction( value );
</a><a name="line-4426" data-line="4426">
</a><a name="line-4427" data-line="4427">		return this.each(function( i ) {
</a><a name="line-4428" data-line="4428">			var self = jQuery(this), val;
</a><a name="line-4429" data-line="4429">
</a><a name="line-4430" data-line="4430">			if ( this.nodeType !== 1 ) {
</a><a name="line-4431" data-line="4431">				return;
</a><a name="line-4432" data-line="4432">			}
</a><a name="line-4433" data-line="4433">
</a><a name="line-4434" data-line="4434">			if ( isFunction ) {
</a><a name="line-4435" data-line="4435">				val = value.call( this, i, self.val() );
</a><a name="line-4436" data-line="4436">			} else {
</a><a name="line-4437" data-line="4437">				val = value;
</a><a name="line-4438" data-line="4438">			}
</a><a name="line-4439" data-line="4439">
</a><a name="line-4440" data-line="4440">			// Treat null/undefined as &quot;&quot;; convert numbers to string
</a><a name="line-4441" data-line="4441">			if ( val == null ) {
</a><a name="line-4442" data-line="4442">				val = &quot;&quot;;
</a><a name="line-4443" data-line="4443">			} else if ( typeof val === &quot;number&quot; ) {
</a><a name="line-4444" data-line="4444">				val += &quot;&quot;;
</a><a name="line-4445" data-line="4445">			} else if ( jQuery.isArray( val ) ) {
</a><a name="line-4446" data-line="4446">				val = jQuery.map(val, function ( value ) {
</a><a name="line-4447" data-line="4447">					return value == null ? &quot;&quot; : value + &quot;&quot;;
</a><a name="line-4448" data-line="4448">				});
</a><a name="line-4449" data-line="4449">			}
</a><a name="line-4450" data-line="4450">
</a><a name="line-4451" data-line="4451">			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
</a><a name="line-4452" data-line="4452">
</a><a name="line-4453" data-line="4453">			// If set returns undefined, fall back to normal setting
</a><a name="line-4454" data-line="4454">			if ( !hooks || !(&quot;set&quot; in hooks) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
</a><a name="line-4455" data-line="4455">				this.value = val;
</a><a name="line-4456" data-line="4456">			}
</a><a name="line-4457" data-line="4457">		});
</a><a name="line-4458" data-line="4458">	}
</a><a name="line-4459" data-line="4459">});
</a><a name="line-4460" data-line="4460">
</a><a name="line-4461" data-line="4461">jQuery.extend({
</a><a name="line-4462" data-line="4462">	valHooks: {
</a><a name="line-4463" data-line="4463">		option: {
</a><a name="line-4464" data-line="4464">			get: function( elem ) {
</a><a name="line-4465" data-line="4465">				// attributes.value is undefined in Blackberry 4.7 but
</a><a name="line-4466" data-line="4466">				// uses .value. See #6932
</a><a name="line-4467" data-line="4467">				var val = elem.attributes.value;
</a><a name="line-4468" data-line="4468">				return !val || val.specified ? elem.value : elem.text;
</a><a name="line-4469" data-line="4469">			}
</a><a name="line-4470" data-line="4470">		},
</a><a name="line-4471" data-line="4471">		select: {
</a><a name="line-4472" data-line="4472">			get: function( elem ) {
</a><a name="line-4473" data-line="4473">				var value, i, max, option,
</a><a name="line-4474" data-line="4474">					index = elem.selectedIndex,
</a><a name="line-4475" data-line="4475">					values = [],
</a><a name="line-4476" data-line="4476">					options = elem.options,
</a><a name="line-4477" data-line="4477">					one = elem.type === &quot;select-one&quot;;
</a><a name="line-4478" data-line="4478">
</a><a name="line-4479" data-line="4479">				// Nothing was selected
</a><a name="line-4480" data-line="4480">				if ( index &lt; 0 ) {
</a><a name="line-4481" data-line="4481">					return null;
</a><a name="line-4482" data-line="4482">				}
</a><a name="line-4483" data-line="4483">
</a><a name="line-4484" data-line="4484">				// Loop through all the selected options
</a><a name="line-4485" data-line="4485">				i = one ? index : 0;
</a><a name="line-4486" data-line="4486">				max = one ? index + 1 : options.length;
</a><a name="line-4487" data-line="4487">				for ( ; i &lt; max; i++ ) {
</a><a name="line-4488" data-line="4488">					option = options[ i ];
</a><a name="line-4489" data-line="4489">
</a><a name="line-4490" data-line="4490">					// Don't return options that are disabled or in a disabled optgroup
</a><a name="line-4491" data-line="4491">					if ( option.selected &amp;&amp; (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(&quot;disabled&quot;) === null) &amp;&amp;
</a><a name="line-4492" data-line="4492">							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, &quot;optgroup&quot; )) ) {
</a><a name="line-4493" data-line="4493">
</a><a name="line-4494" data-line="4494">						// Get the specific value for the option
</a><a name="line-4495" data-line="4495">						value = jQuery( option ).val();
</a><a name="line-4496" data-line="4496">
</a><a name="line-4497" data-line="4497">						// We don't need an array for one selects
</a><a name="line-4498" data-line="4498">						if ( one ) {
</a><a name="line-4499" data-line="4499">							return value;
</a><a name="line-4500" data-line="4500">						}
</a><a name="line-4501" data-line="4501">
</a><a name="line-4502" data-line="4502">						// Multi-Selects return an array
</a><a name="line-4503" data-line="4503">						values.push( value );
</a><a name="line-4504" data-line="4504">					}
</a><a name="line-4505" data-line="4505">				}
</a><a name="line-4506" data-line="4506">
</a><a name="line-4507" data-line="4507">				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
</a><a name="line-4508" data-line="4508">				if ( one &amp;&amp; !values.length &amp;&amp; options.length ) {
</a><a name="line-4509" data-line="4509">					return jQuery( options[ index ] ).val();
</a><a name="line-4510" data-line="4510">				}
</a><a name="line-4511" data-line="4511">
</a><a name="line-4512" data-line="4512">				return values;
</a><a name="line-4513" data-line="4513">			},
</a><a name="line-4514" data-line="4514">
</a><a name="line-4515" data-line="4515">			set: function( elem, value ) {
</a><a name="line-4516" data-line="4516">				var values = jQuery.makeArray( value );
</a><a name="line-4517" data-line="4517">
</a><a name="line-4518" data-line="4518">				jQuery(elem).find(&quot;option&quot;).each(function() {
</a><a name="line-4519" data-line="4519">					this.selected = jQuery.inArray( jQuery(this).val(), values ) &gt;= 0;
</a><a name="line-4520" data-line="4520">				});
</a><a name="line-4521" data-line="4521">
</a><a name="line-4522" data-line="4522">				if ( !values.length ) {
</a><a name="line-4523" data-line="4523">					elem.selectedIndex = -1;
</a><a name="line-4524" data-line="4524">				}
</a><a name="line-4525" data-line="4525">				return values;
</a><a name="line-4526" data-line="4526">			}
</a><a name="line-4527" data-line="4527">		}
</a><a name="line-4528" data-line="4528">	},
</a><a name="line-4529" data-line="4529">
</a><a name="line-4530" data-line="4530">	attrFn: {
</a><a name="line-4531" data-line="4531">		val: true,
</a><a name="line-4532" data-line="4532">		css: true,
</a><a name="line-4533" data-line="4533">		html: true,
</a><a name="line-4534" data-line="4534">		text: true,
</a><a name="line-4535" data-line="4535">		data: true,
</a><a name="line-4536" data-line="4536">		width: true,
</a><a name="line-4537" data-line="4537">		height: true,
</a><a name="line-4538" data-line="4538">		offset: true
</a><a name="line-4539" data-line="4539">	},
</a><a name="line-4540" data-line="4540">
</a><a name="line-4541" data-line="4541">	attr: function( elem, name, value, pass ) {
</a><a name="line-4542" data-line="4542">		var ret, hooks, notxml,
</a><a name="line-4543" data-line="4543">			nType = elem.nodeType;
</a><a name="line-4544" data-line="4544">
</a><a name="line-4545" data-line="4545">		// don't get/set attributes on text, comment and attribute nodes
</a><a name="line-4546" data-line="4546">		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
</a><a name="line-4547" data-line="4547">			return;
</a><a name="line-4548" data-line="4548">		}
</a><a name="line-4549" data-line="4549">
</a><a name="line-4550" data-line="4550">		if ( pass &amp;&amp; name in jQuery.attrFn ) {
</a><a name="line-4551" data-line="4551">			return jQuery( elem )[ name ]( value );
</a><a name="line-4552" data-line="4552">		}
</a><a name="line-4553" data-line="4553">
</a><a name="line-4554" data-line="4554">		// Fallback to prop when attributes are not supported
</a><a name="line-4555" data-line="4555">		if ( typeof elem.getAttribute === &quot;undefined&quot; ) {
</a><a name="line-4556" data-line="4556">			return jQuery.prop( elem, name, value );
</a><a name="line-4557" data-line="4557">		}
</a><a name="line-4558" data-line="4558">
</a><a name="line-4559" data-line="4559">		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
</a><a name="line-4560" data-line="4560">
</a><a name="line-4561" data-line="4561">		// All attributes are lowercase
</a><a name="line-4562" data-line="4562">		// Grab necessary hook if one is defined
</a><a name="line-4563" data-line="4563">		if ( notxml ) {
</a><a name="line-4564" data-line="4564">			name = name.toLowerCase();
</a><a name="line-4565" data-line="4565">			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
</a><a name="line-4566" data-line="4566">		}
</a><a name="line-4567" data-line="4567">
</a><a name="line-4568" data-line="4568">		if ( value !== undefined ) {
</a><a name="line-4569" data-line="4569">
</a><a name="line-4570" data-line="4570">			if ( value === null ) {
</a><a name="line-4571" data-line="4571">				jQuery.removeAttr( elem, name );
</a><a name="line-4572" data-line="4572">				return;
</a><a name="line-4573" data-line="4573">
</a><a name="line-4574" data-line="4574">			} else if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; notxml &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {
</a><a name="line-4575" data-line="4575">				return ret;
</a><a name="line-4576" data-line="4576">
</a><a name="line-4577" data-line="4577">			} else {
</a><a name="line-4578" data-line="4578">				elem.setAttribute( name, &quot;&quot; + value );
</a><a name="line-4579" data-line="4579">				return value;
</a><a name="line-4580" data-line="4580">			}
</a><a name="line-4581" data-line="4581">
</a><a name="line-4582" data-line="4582">		} else if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; notxml &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {
</a><a name="line-4583" data-line="4583">			return ret;
</a><a name="line-4584" data-line="4584">
</a><a name="line-4585" data-line="4585">		} else {
</a><a name="line-4586" data-line="4586">
</a><a name="line-4587" data-line="4587">			ret = elem.getAttribute( name );
</a><a name="line-4588" data-line="4588">
</a><a name="line-4589" data-line="4589">			// Non-existent attributes return null, we normalize to undefined
</a><a name="line-4590" data-line="4590">			return ret === null ?
</a><a name="line-4591" data-line="4591">				undefined :
</a><a name="line-4592" data-line="4592">				ret;
</a><a name="line-4593" data-line="4593">		}
</a><a name="line-4594" data-line="4594">	},
</a><a name="line-4595" data-line="4595">
</a><a name="line-4596" data-line="4596">	removeAttr: function( elem, value ) {
</a><a name="line-4597" data-line="4597">		var propName, attrNames, name, l, isBool,
</a><a name="line-4598" data-line="4598">			i = 0;
</a><a name="line-4599" data-line="4599">
</a><a name="line-4600" data-line="4600">		if ( value &amp;&amp; elem.nodeType === 1 ) {
</a><a name="line-4601" data-line="4601">			attrNames = value.toLowerCase().split( rspace );
</a><a name="line-4602" data-line="4602">			l = attrNames.length;
</a><a name="line-4603" data-line="4603">
</a><a name="line-4604" data-line="4604">			for ( ; i &lt; l; i++ ) {
</a><a name="line-4605" data-line="4605">				name = attrNames[ i ];
</a><a name="line-4606" data-line="4606">
</a><a name="line-4607" data-line="4607">				if ( name ) {
</a><a name="line-4608" data-line="4608">					propName = jQuery.propFix[ name ] || name;
</a><a name="line-4609" data-line="4609">					isBool = rboolean.test( name );
</a><a name="line-4610" data-line="4610">
</a><a name="line-4611" data-line="4611">					// See #9699 for explanation of this approach (setting first, then removal)
</a><a name="line-4612" data-line="4612">					// Do not do this for boolean attributes (see #10870)
</a><a name="line-4613" data-line="4613">					if ( !isBool ) {
</a><a name="line-4614" data-line="4614">						jQuery.attr( elem, name, &quot;&quot; );
</a><a name="line-4615" data-line="4615">					}
</a><a name="line-4616" data-line="4616">					elem.removeAttribute( getSetAttribute ? name : propName );
</a><a name="line-4617" data-line="4617">
</a><a name="line-4618" data-line="4618">					// Set corresponding property to false for boolean attributes
</a><a name="line-4619" data-line="4619">					if ( isBool &amp;&amp; propName in elem ) {
</a><a name="line-4620" data-line="4620">						elem[ propName ] = false;
</a><a name="line-4621" data-line="4621">					}
</a><a name="line-4622" data-line="4622">				}
</a><a name="line-4623" data-line="4623">			}
</a><a name="line-4624" data-line="4624">		}
</a><a name="line-4625" data-line="4625">	},
</a><a name="line-4626" data-line="4626">
</a><a name="line-4627" data-line="4627">	attrHooks: {
</a><a name="line-4628" data-line="4628">		type: {
</a><a name="line-4629" data-line="4629">			set: function( elem, value ) {
</a><a name="line-4630" data-line="4630">				// We can't allow the type property to be changed (since it causes problems in IE)
</a><a name="line-4631" data-line="4631">				if ( rtype.test( elem.nodeName ) &amp;&amp; elem.parentNode ) {
</a><a name="line-4632" data-line="4632">					jQuery.error( &quot;type property can't be changed&quot; );
</a><a name="line-4633" data-line="4633">				} else if ( !jQuery.support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; jQuery.nodeName(elem, &quot;input&quot;) ) {
</a><a name="line-4634" data-line="4634">					// Setting the type on a radio button after the value resets the value in IE6-9
</a><a name="line-4635" data-line="4635">					// Reset value to it's default in case type is set after value
</a><a name="line-4636" data-line="4636">					// This is for element creation
</a><a name="line-4637" data-line="4637">					var val = elem.value;
</a><a name="line-4638" data-line="4638">					elem.setAttribute( &quot;type&quot;, value );
</a><a name="line-4639" data-line="4639">					if ( val ) {
</a><a name="line-4640" data-line="4640">						elem.value = val;
</a><a name="line-4641" data-line="4641">					}
</a><a name="line-4642" data-line="4642">					return value;
</a><a name="line-4643" data-line="4643">				}
</a><a name="line-4644" data-line="4644">			}
</a><a name="line-4645" data-line="4645">		},
</a><a name="line-4646" data-line="4646">		// Use the value property for back compat
</a><a name="line-4647" data-line="4647">		// Use the nodeHook for button elements in IE6/7 (#1954)
</a><a name="line-4648" data-line="4648">		value: {
</a><a name="line-4649" data-line="4649">			get: function( elem, name ) {
</a><a name="line-4650" data-line="4650">				if ( nodeHook &amp;&amp; jQuery.nodeName( elem, &quot;button&quot; ) ) {
</a><a name="line-4651" data-line="4651">					return nodeHook.get( elem, name );
</a><a name="line-4652" data-line="4652">				}
</a><a name="line-4653" data-line="4653">				return name in elem ?
</a><a name="line-4654" data-line="4654">					elem.value :
</a><a name="line-4655" data-line="4655">					null;
</a><a name="line-4656" data-line="4656">			},
</a><a name="line-4657" data-line="4657">			set: function( elem, value, name ) {
</a><a name="line-4658" data-line="4658">				if ( nodeHook &amp;&amp; jQuery.nodeName( elem, &quot;button&quot; ) ) {
</a><a name="line-4659" data-line="4659">					return nodeHook.set( elem, value, name );
</a><a name="line-4660" data-line="4660">				}
</a><a name="line-4661" data-line="4661">				// Does not return so that setAttribute is also used
</a><a name="line-4662" data-line="4662">				elem.value = value;
</a><a name="line-4663" data-line="4663">			}
</a><a name="line-4664" data-line="4664">		}
</a><a name="line-4665" data-line="4665">	},
</a><a name="line-4666" data-line="4666">
</a><a name="line-4667" data-line="4667">	propFix: {
</a><a name="line-4668" data-line="4668">		tabindex: &quot;tabIndex&quot;,
</a><a name="line-4669" data-line="4669">		readonly: &quot;readOnly&quot;,
</a><a name="line-4670" data-line="4670">		&quot;for&quot;: &quot;htmlFor&quot;,
</a><a name="line-4671" data-line="4671">		&quot;class&quot;: &quot;className&quot;,
</a><a name="line-4672" data-line="4672">		maxlength: &quot;maxLength&quot;,
</a><a name="line-4673" data-line="4673">		cellspacing: &quot;cellSpacing&quot;,
</a><a name="line-4674" data-line="4674">		cellpadding: &quot;cellPadding&quot;,
</a><a name="line-4675" data-line="4675">		rowspan: &quot;rowSpan&quot;,
</a><a name="line-4676" data-line="4676">		colspan: &quot;colSpan&quot;,
</a><a name="line-4677" data-line="4677">		usemap: &quot;useMap&quot;,
</a><a name="line-4678" data-line="4678">		frameborder: &quot;frameBorder&quot;,
</a><a name="line-4679" data-line="4679">		contenteditable: &quot;contentEditable&quot;
</a><a name="line-4680" data-line="4680">	},
</a><a name="line-4681" data-line="4681">
</a><a name="line-4682" data-line="4682">	prop: function( elem, name, value ) {
</a><a name="line-4683" data-line="4683">		var ret, hooks, notxml,
</a><a name="line-4684" data-line="4684">			nType = elem.nodeType;
</a><a name="line-4685" data-line="4685">
</a><a name="line-4686" data-line="4686">		// don't get/set properties on text, comment and attribute nodes
</a><a name="line-4687" data-line="4687">		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
</a><a name="line-4688" data-line="4688">			return;
</a><a name="line-4689" data-line="4689">		}
</a><a name="line-4690" data-line="4690">
</a><a name="line-4691" data-line="4691">		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
</a><a name="line-4692" data-line="4692">
</a><a name="line-4693" data-line="4693">		if ( notxml ) {
</a><a name="line-4694" data-line="4694">			// Fix name and attach hooks
</a><a name="line-4695" data-line="4695">			name = jQuery.propFix[ name ] || name;
</a><a name="line-4696" data-line="4696">			hooks = jQuery.propHooks[ name ];
</a><a name="line-4697" data-line="4697">		}
</a><a name="line-4698" data-line="4698">
</a><a name="line-4699" data-line="4699">		if ( value !== undefined ) {
</a><a name="line-4700" data-line="4700">			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {
</a><a name="line-4701" data-line="4701">				return ret;
</a><a name="line-4702" data-line="4702">
</a><a name="line-4703" data-line="4703">			} else {
</a><a name="line-4704" data-line="4704">				return ( elem[ name ] = value );
</a><a name="line-4705" data-line="4705">			}
</a><a name="line-4706" data-line="4706">
</a><a name="line-4707" data-line="4707">		} else {
</a><a name="line-4708" data-line="4708">			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {
</a><a name="line-4709" data-line="4709">				return ret;
</a><a name="line-4710" data-line="4710">
</a><a name="line-4711" data-line="4711">			} else {
</a><a name="line-4712" data-line="4712">				return elem[ name ];
</a><a name="line-4713" data-line="4713">			}
</a><a name="line-4714" data-line="4714">		}
</a><a name="line-4715" data-line="4715">	},
</a><a name="line-4716" data-line="4716">
</a><a name="line-4717" data-line="4717">	propHooks: {
</a><a name="line-4718" data-line="4718">		tabIndex: {
</a><a name="line-4719" data-line="4719">			get: function( elem ) {
</a><a name="line-4720" data-line="4720">				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
</a><a name="line-4721" data-line="4721">				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
</a><a name="line-4722" data-line="4722">				var attributeNode = elem.getAttributeNode(&quot;tabindex&quot;);
</a><a name="line-4723" data-line="4723">
</a><a name="line-4724" data-line="4724">				return attributeNode &amp;&amp; attributeNode.specified ?
</a><a name="line-4725" data-line="4725">					parseInt( attributeNode.value, 10 ) :
</a><a name="line-4726" data-line="4726">					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ?
</a><a name="line-4727" data-line="4727">						0 :
</a><a name="line-4728" data-line="4728">						undefined;
</a><a name="line-4729" data-line="4729">			}
</a><a name="line-4730" data-line="4730">		}
</a><a name="line-4731" data-line="4731">	}
</a><a name="line-4732" data-line="4732">});
</a><a name="line-4733" data-line="4733">
</a><a name="line-4734" data-line="4734">// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
</a><a name="line-4735" data-line="4735">jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;
</a><a name="line-4736" data-line="4736">
</a><a name="line-4737" data-line="4737">// Hook for boolean attributes
</a><a name="line-4738" data-line="4738">boolHook = {
</a><a name="line-4739" data-line="4739">	get: function( elem, name ) {
</a><a name="line-4740" data-line="4740">		// Align boolean attributes with corresponding properties
</a><a name="line-4741" data-line="4741">		// Fall back to attribute presence where some booleans are not supported
</a><a name="line-4742" data-line="4742">		var attrNode,
</a><a name="line-4743" data-line="4743">			property = jQuery.prop( elem, name );
</a><a name="line-4744" data-line="4744">		return property === true || typeof property !== &quot;boolean&quot; &amp;&amp; ( attrNode = elem.getAttributeNode(name) ) &amp;&amp; attrNode.nodeValue !== false ?
</a><a name="line-4745" data-line="4745">			name.toLowerCase() :
</a><a name="line-4746" data-line="4746">			undefined;
</a><a name="line-4747" data-line="4747">	},
</a><a name="line-4748" data-line="4748">	set: function( elem, value, name ) {
</a><a name="line-4749" data-line="4749">		var propName;
</a><a name="line-4750" data-line="4750">		if ( value === false ) {
</a><a name="line-4751" data-line="4751">			// Remove boolean attributes when set to false
</a><a name="line-4752" data-line="4752">			jQuery.removeAttr( elem, name );
</a><a name="line-4753" data-line="4753">		} else {
</a><a name="line-4754" data-line="4754">			// value is true since we know at this point it's type boolean and not false
</a><a name="line-4755" data-line="4755">			// Set boolean attributes to the same name and set the DOM property
</a><a name="line-4756" data-line="4756">			propName = jQuery.propFix[ name ] || name;
</a><a name="line-4757" data-line="4757">			if ( propName in elem ) {
</a><a name="line-4758" data-line="4758">				// Only set the IDL specifically if it already exists on the element
</a><a name="line-4759" data-line="4759">				elem[ propName ] = true;
</a><a name="line-4760" data-line="4760">			}
</a><a name="line-4761" data-line="4761">
</a><a name="line-4762" data-line="4762">			elem.setAttribute( name, name.toLowerCase() );
</a><a name="line-4763" data-line="4763">		}
</a><a name="line-4764" data-line="4764">		return name;
</a><a name="line-4765" data-line="4765">	}
</a><a name="line-4766" data-line="4766">};
</a><a name="line-4767" data-line="4767">
</a><a name="line-4768" data-line="4768">// IE6/7 do not support getting/setting some attributes with get/setAttribute
</a><a name="line-4769" data-line="4769">if ( !getSetAttribute ) {
</a><a name="line-4770" data-line="4770">
</a><a name="line-4771" data-line="4771">	fixSpecified = {
</a><a name="line-4772" data-line="4772">		name: true,
</a><a name="line-4773" data-line="4773">		id: true,
</a><a name="line-4774" data-line="4774">		coords: true
</a><a name="line-4775" data-line="4775">	};
</a><a name="line-4776" data-line="4776">
</a><a name="line-4777" data-line="4777">	// Use this for any attribute in IE6/7
</a><a name="line-4778" data-line="4778">	// This fixes almost every IE6/7 issue
</a><a name="line-4779" data-line="4779">	nodeHook = jQuery.valHooks.button = {
</a><a name="line-4780" data-line="4780">		get: function( elem, name ) {
</a><a name="line-4781" data-line="4781">			var ret;
</a><a name="line-4782" data-line="4782">			ret = elem.getAttributeNode( name );
</a><a name="line-4783" data-line="4783">			return ret &amp;&amp; ( fixSpecified[ name ] ? ret.nodeValue !== &quot;&quot; : ret.specified ) ?
</a><a name="line-4784" data-line="4784">				ret.nodeValue :
</a><a name="line-4785" data-line="4785">				undefined;
</a><a name="line-4786" data-line="4786">		},
</a><a name="line-4787" data-line="4787">		set: function( elem, value, name ) {
</a><a name="line-4788" data-line="4788">			// Set the existing or create a new attribute node
</a><a name="line-4789" data-line="4789">			var ret = elem.getAttributeNode( name );
</a><a name="line-4790" data-line="4790">			if ( !ret ) {
</a><a name="line-4791" data-line="4791">				ret = document.createAttribute( name );
</a><a name="line-4792" data-line="4792">				elem.setAttributeNode( ret );
</a><a name="line-4793" data-line="4793">			}
</a><a name="line-4794" data-line="4794">			return ( ret.nodeValue = value + &quot;&quot; );
</a><a name="line-4795" data-line="4795">		}
</a><a name="line-4796" data-line="4796">	};
</a><a name="line-4797" data-line="4797">
</a><a name="line-4798" data-line="4798">	// Apply the nodeHook to tabindex
</a><a name="line-4799" data-line="4799">	jQuery.attrHooks.tabindex.set = nodeHook.set;
</a><a name="line-4800" data-line="4800">
</a><a name="line-4801" data-line="4801">	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
</a><a name="line-4802" data-line="4802">	// This is for removals
</a><a name="line-4803" data-line="4803">	jQuery.each([ &quot;width&quot;, &quot;height&quot; ], function( i, name ) {
</a><a name="line-4804" data-line="4804">		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
</a><a name="line-4805" data-line="4805">			set: function( elem, value ) {
</a><a name="line-4806" data-line="4806">				if ( value === &quot;&quot; ) {
</a><a name="line-4807" data-line="4807">					elem.setAttribute( name, &quot;auto&quot; );
</a><a name="line-4808" data-line="4808">					return value;
</a><a name="line-4809" data-line="4809">				}
</a><a name="line-4810" data-line="4810">			}
</a><a name="line-4811" data-line="4811">		});
</a><a name="line-4812" data-line="4812">	});
</a><a name="line-4813" data-line="4813">
</a><a name="line-4814" data-line="4814">	// Set contenteditable to false on removals(#10429)
</a><a name="line-4815" data-line="4815">	// Setting to empty string throws an error as an invalid value
</a><a name="line-4816" data-line="4816">	jQuery.attrHooks.contenteditable = {
</a><a name="line-4817" data-line="4817">		get: nodeHook.get,
</a><a name="line-4818" data-line="4818">		set: function( elem, value, name ) {
</a><a name="line-4819" data-line="4819">			if ( value === &quot;&quot; ) {
</a><a name="line-4820" data-line="4820">				value = &quot;false&quot;;
</a><a name="line-4821" data-line="4821">			}
</a><a name="line-4822" data-line="4822">			nodeHook.set( elem, value, name );
</a><a name="line-4823" data-line="4823">		}
</a><a name="line-4824" data-line="4824">	};
</a><a name="line-4825" data-line="4825">}
</a><a name="line-4826" data-line="4826">
</a><a name="line-4827" data-line="4827">
</a><a name="line-4828" data-line="4828">// Some attributes require a special call on IE
</a><a name="line-4829" data-line="4829">if ( !jQuery.support.hrefNormalized ) {
</a><a name="line-4830" data-line="4830">	jQuery.each([ &quot;href&quot;, &quot;src&quot;, &quot;width&quot;, &quot;height&quot; ], function( i, name ) {
</a><a name="line-4831" data-line="4831">		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
</a><a name="line-4832" data-line="4832">			get: function( elem ) {
</a><a name="line-4833" data-line="4833">				var ret = elem.getAttribute( name, 2 );
</a><a name="line-4834" data-line="4834">				return ret === null ? undefined : ret;
</a><a name="line-4835" data-line="4835">			}
</a><a name="line-4836" data-line="4836">		});
</a><a name="line-4837" data-line="4837">	});
</a><a name="line-4838" data-line="4838">}
</a><a name="line-4839" data-line="4839">
</a><a name="line-4840" data-line="4840">if ( !jQuery.support.style ) {
</a><a name="line-4841" data-line="4841">	jQuery.attrHooks.style = {
</a><a name="line-4842" data-line="4842">		get: function( elem ) {
</a><a name="line-4843" data-line="4843">			// Return undefined in the case of empty string
</a><a name="line-4844" data-line="4844">			// Normalize to lowercase since IE uppercases css property names
</a><a name="line-4845" data-line="4845">			return elem.style.cssText.toLowerCase() || undefined;
</a><a name="line-4846" data-line="4846">		},
</a><a name="line-4847" data-line="4847">		set: function( elem, value ) {
</a><a name="line-4848" data-line="4848">			return ( elem.style.cssText = &quot;&quot; + value );
</a><a name="line-4849" data-line="4849">		}
</a><a name="line-4850" data-line="4850">	};
</a><a name="line-4851" data-line="4851">}
</a><a name="line-4852" data-line="4852">
</a><a name="line-4853" data-line="4853">// Safari mis-reports the default selected property of an option
</a><a name="line-4854" data-line="4854">// Accessing the parent's selectedIndex property fixes it
</a><a name="line-4855" data-line="4855">if ( !jQuery.support.optSelected ) {
</a><a name="line-4856" data-line="4856">	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
</a><a name="line-4857" data-line="4857">		get: function( elem ) {
</a><a name="line-4858" data-line="4858">			var parent = elem.parentNode;
</a><a name="line-4859" data-line="4859">
</a><a name="line-4860" data-line="4860">			if ( parent ) {
</a><a name="line-4861" data-line="4861">				parent.selectedIndex;
</a><a name="line-4862" data-line="4862">
</a><a name="line-4863" data-line="4863">				// Make sure that it also works with optgroups, see #5701
</a><a name="line-4864" data-line="4864">				if ( parent.parentNode ) {
</a><a name="line-4865" data-line="4865">					parent.parentNode.selectedIndex;
</a><a name="line-4866" data-line="4866">				}
</a><a name="line-4867" data-line="4867">			}
</a><a name="line-4868" data-line="4868">			return null;
</a><a name="line-4869" data-line="4869">		}
</a><a name="line-4870" data-line="4870">	});
</a><a name="line-4871" data-line="4871">}
</a><a name="line-4872" data-line="4872">
</a><a name="line-4873" data-line="4873">// IE6/7 call enctype encoding
</a><a name="line-4874" data-line="4874">if ( !jQuery.support.enctype ) {
</a><a name="line-4875" data-line="4875">	jQuery.propFix.enctype = &quot;encoding&quot;;
</a><a name="line-4876" data-line="4876">}
</a><a name="line-4877" data-line="4877">
</a><a name="line-4878" data-line="4878">// Radios and checkboxes getter/setter
</a><a name="line-4879" data-line="4879">if ( !jQuery.support.checkOn ) {
</a><a name="line-4880" data-line="4880">	jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
</a><a name="line-4881" data-line="4881">		jQuery.valHooks[ this ] = {
</a><a name="line-4882" data-line="4882">			get: function( elem ) {
</a><a name="line-4883" data-line="4883">				// Handle the case where in Webkit &quot;&quot; is returned instead of &quot;on&quot; if a value isn't specified
</a><a name="line-4884" data-line="4884">				return elem.getAttribute(&quot;value&quot;) === null ? &quot;on&quot; : elem.value;
</a><a name="line-4885" data-line="4885">			}
</a><a name="line-4886" data-line="4886">		};
</a><a name="line-4887" data-line="4887">	});
</a><a name="line-4888" data-line="4888">}
</a><a name="line-4889" data-line="4889">jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
</a><a name="line-4890" data-line="4890">	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
</a><a name="line-4891" data-line="4891">		set: function( elem, value ) {
</a><a name="line-4892" data-line="4892">			if ( jQuery.isArray( value ) ) {
</a><a name="line-4893" data-line="4893">				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 );
</a><a name="line-4894" data-line="4894">			}
</a><a name="line-4895" data-line="4895">		}
</a><a name="line-4896" data-line="4896">	});
</a><a name="line-4897" data-line="4897">});
</a><a name="line-4898" data-line="4898">
</a><a name="line-4899" data-line="4899">
</a><a name="line-4900" data-line="4900">
</a><a name="line-4901" data-line="4901">
</a><a name="line-4902" data-line="4902">var rformElems = /^(?:textarea|input|select)$/i,
</a><a name="line-4903" data-line="4903">	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
</a><a name="line-4904" data-line="4904">	rhoverHack = /(?:^|\s)hover(\.\S+)?\b/,
</a><a name="line-4905" data-line="4905">	rkeyEvent = /^key/,
</a><a name="line-4906" data-line="4906">	rmouseEvent = /^(?:mouse|contextmenu)|click/,
</a><a name="line-4907" data-line="4907">	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
</a><a name="line-4908" data-line="4908">	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
</a><a name="line-4909" data-line="4909">	quickParse = function( selector ) {
</a><a name="line-4910" data-line="4910">		var quick = rquickIs.exec( selector );
</a><a name="line-4911" data-line="4911">		if ( quick ) {
</a><a name="line-4912" data-line="4912">			//   0  1    2   3
</a><a name="line-4913" data-line="4913">			// [ _, tag, id, class ]
</a><a name="line-4914" data-line="4914">			quick[1] = ( quick[1] || &quot;&quot; ).toLowerCase();
</a><a name="line-4915" data-line="4915">			quick[3] = quick[3] &amp;&amp; new RegExp( &quot;(?:^|\\s)&quot; + quick[3] + &quot;(?:\\s|$)&quot; );
</a><a name="line-4916" data-line="4916">		}
</a><a name="line-4917" data-line="4917">		return quick;
</a><a name="line-4918" data-line="4918">	},
</a><a name="line-4919" data-line="4919">	quickIs = function( elem, m ) {
</a><a name="line-4920" data-line="4920">		var attrs = elem.attributes || {};
</a><a name="line-4921" data-line="4921">		return (
</a><a name="line-4922" data-line="4922">			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &amp;&amp;
</a><a name="line-4923" data-line="4923">			(!m[2] || (attrs.id || {}).value === m[2]) &amp;&amp;
</a><a name="line-4924" data-line="4924">			(!m[3] || m[3].test( (attrs[ &quot;class&quot; ] || {}).value ))
</a><a name="line-4925" data-line="4925">		);
</a><a name="line-4926" data-line="4926">	},
</a><a name="line-4927" data-line="4927">	hoverHack = function( events ) {
</a><a name="line-4928" data-line="4928">		return jQuery.event.special.hover ? events : events.replace( rhoverHack, &quot;mouseenter$1 mouseleave$1&quot; );
</a><a name="line-4929" data-line="4929">	};
</a><a name="line-4930" data-line="4930">
</a><a name="line-4931" data-line="4931">/*
</a><a name="line-4932" data-line="4932"> * Helper functions for managing events -- not part of the public interface.
</a><a name="line-4933" data-line="4933"> * Props to Dean Edwards' addEvent library for many of the ideas.
</a><a name="line-4934" data-line="4934"> */
</a><a name="line-4935" data-line="4935">jQuery.event = {
</a><a name="line-4936" data-line="4936">
</a><a name="line-4937" data-line="4937">	add: function( elem, types, handler, data, selector ) {
</a><a name="line-4938" data-line="4938">
</a><a name="line-4939" data-line="4939">		var elemData, eventHandle, events,
</a><a name="line-4940" data-line="4940">			t, tns, type, namespaces, handleObj,
</a><a name="line-4941" data-line="4941">			handleObjIn, quick, handlers, special;
</a><a name="line-4942" data-line="4942">
</a><a name="line-4943" data-line="4943">		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
</a><a name="line-4944" data-line="4944">		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
</a><a name="line-4945" data-line="4945">			return;
</a><a name="line-4946" data-line="4946">		}
</a><a name="line-4947" data-line="4947">
</a><a name="line-4948" data-line="4948">		// Caller can pass in an object of custom data in lieu of the handler
</a><a name="line-4949" data-line="4949">		if ( handler.handler ) {
</a><a name="line-4950" data-line="4950">			handleObjIn = handler;
</a><a name="line-4951" data-line="4951">			handler = handleObjIn.handler;
</a><a name="line-4952" data-line="4952">			selector = handleObjIn.selector;
</a><a name="line-4953" data-line="4953">		}
</a><a name="line-4954" data-line="4954">
</a><a name="line-4955" data-line="4955">		// Make sure that the handler has a unique ID, used to find/remove it later
</a><a name="line-4956" data-line="4956">		if ( !handler.guid ) {
</a><a name="line-4957" data-line="4957">			handler.guid = jQuery.guid++;
</a><a name="line-4958" data-line="4958">		}
</a><a name="line-4959" data-line="4959">
</a><a name="line-4960" data-line="4960">		// Init the element's event structure and main handler, if this is the first
</a><a name="line-4961" data-line="4961">		events = elemData.events;
</a><a name="line-4962" data-line="4962">		if ( !events ) {
</a><a name="line-4963" data-line="4963">			elemData.events = events = {};
</a><a name="line-4964" data-line="4964">		}
</a><a name="line-4965" data-line="4965">		eventHandle = elemData.handle;
</a><a name="line-4966" data-line="4966">		if ( !eventHandle ) {
</a><a name="line-4967" data-line="4967">			elemData.handle = eventHandle = function( e ) {
</a><a name="line-4968" data-line="4968">				// Discard the second event of a jQuery.event.trigger() and
</a><a name="line-4969" data-line="4969">				// when an event is called after a page has unloaded
</a><a name="line-4970" data-line="4970">				return typeof jQuery !== &quot;undefined&quot; &amp;&amp; (!e || jQuery.event.triggered !== e.type) ?
</a><a name="line-4971" data-line="4971">					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
</a><a name="line-4972" data-line="4972">					undefined;
</a><a name="line-4973" data-line="4973">			};
</a><a name="line-4974" data-line="4974">			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
</a><a name="line-4975" data-line="4975">			eventHandle.elem = elem;
</a><a name="line-4976" data-line="4976">		}
</a><a name="line-4977" data-line="4977">
</a><a name="line-4978" data-line="4978">		// Handle multiple events separated by a space
</a><a name="line-4979" data-line="4979">		// jQuery(...).bind(&quot;mouseover mouseout&quot;, fn);
</a><a name="line-4980" data-line="4980">		types = jQuery.trim( hoverHack(types) ).split( &quot; &quot; );
</a><a name="line-4981" data-line="4981">		for ( t = 0; t &lt; types.length; t++ ) {
</a><a name="line-4982" data-line="4982">
</a><a name="line-4983" data-line="4983">			tns = rtypenamespace.exec( types[t] ) || [];
</a><a name="line-4984" data-line="4984">			type = tns[1];
</a><a name="line-4985" data-line="4985">			namespaces = ( tns[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();
</a><a name="line-4986" data-line="4986">
</a><a name="line-4987" data-line="4987">			// If event changes its type, use the special event handlers for the changed type
</a><a name="line-4988" data-line="4988">			special = jQuery.event.special[ type ] || {};
</a><a name="line-4989" data-line="4989">
</a><a name="line-4990" data-line="4990">			// If selector defined, determine special event api type, otherwise given type
</a><a name="line-4991" data-line="4991">			type = ( selector ? special.delegateType : special.bindType ) || type;
</a><a name="line-4992" data-line="4992">
</a><a name="line-4993" data-line="4993">			// Update special based on newly reset type
</a><a name="line-4994" data-line="4994">			special = jQuery.event.special[ type ] || {};
</a><a name="line-4995" data-line="4995">
</a><a name="line-4996" data-line="4996">			// handleObj is passed to all event handlers
</a><a name="line-4997" data-line="4997">			handleObj = jQuery.extend({
</a><a name="line-4998" data-line="4998">				type: type,
</a><a name="line-4999" data-line="4999">				origType: tns[1],
</a><a name="line-5000" data-line="5000">				data: data,
</a><a name="line-5001" data-line="5001">				handler: handler,
</a><a name="line-5002" data-line="5002">				guid: handler.guid,
</a><a name="line-5003" data-line="5003">				selector: selector,
</a><a name="line-5004" data-line="5004">				quick: selector &amp;&amp; quickParse( selector ),
</a><a name="line-5005" data-line="5005">				namespace: namespaces.join(&quot;.&quot;)
</a><a name="line-5006" data-line="5006">			}, handleObjIn );
</a><a name="line-5007" data-line="5007">
</a><a name="line-5008" data-line="5008">			// Init the event handler queue if we're the first
</a><a name="line-5009" data-line="5009">			handlers = events[ type ];
</a><a name="line-5010" data-line="5010">			if ( !handlers ) {
</a><a name="line-5011" data-line="5011">				handlers = events[ type ] = [];
</a><a name="line-5012" data-line="5012">				handlers.delegateCount = 0;
</a><a name="line-5013" data-line="5013">
</a><a name="line-5014" data-line="5014">				// Only use addEventListener/attachEvent if the special events handler returns false
</a><a name="line-5015" data-line="5015">				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
</a><a name="line-5016" data-line="5016">					// Bind the global event handler to the element
</a><a name="line-5017" data-line="5017">					if ( elem.addEventListener ) {
</a><a name="line-5018" data-line="5018">						elem.addEventListener( type, eventHandle, false );
</a><a name="line-5019" data-line="5019">
</a><a name="line-5020" data-line="5020">					} else if ( elem.attachEvent ) {
</a><a name="line-5021" data-line="5021">						elem.attachEvent( &quot;on&quot; + type, eventHandle );
</a><a name="line-5022" data-line="5022">					}
</a><a name="line-5023" data-line="5023">				}
</a><a name="line-5024" data-line="5024">			}
</a><a name="line-5025" data-line="5025">
</a><a name="line-5026" data-line="5026">			if ( special.add ) {
</a><a name="line-5027" data-line="5027">				special.add.call( elem, handleObj );
</a><a name="line-5028" data-line="5028">
</a><a name="line-5029" data-line="5029">				if ( !handleObj.handler.guid ) {
</a><a name="line-5030" data-line="5030">					handleObj.handler.guid = handler.guid;
</a><a name="line-5031" data-line="5031">				}
</a><a name="line-5032" data-line="5032">			}
</a><a name="line-5033" data-line="5033">
</a><a name="line-5034" data-line="5034">			// Add to the element's handler list, delegates in front
</a><a name="line-5035" data-line="5035">			if ( selector ) {
</a><a name="line-5036" data-line="5036">				handlers.splice( handlers.delegateCount++, 0, handleObj );
</a><a name="line-5037" data-line="5037">			} else {
</a><a name="line-5038" data-line="5038">				handlers.push( handleObj );
</a><a name="line-5039" data-line="5039">			}
</a><a name="line-5040" data-line="5040">
</a><a name="line-5041" data-line="5041">			// Keep track of which events have ever been used, for event optimization
</a><a name="line-5042" data-line="5042">			jQuery.event.global[ type ] = true;
</a><a name="line-5043" data-line="5043">		}
</a><a name="line-5044" data-line="5044">
</a><a name="line-5045" data-line="5045">		// Nullify elem to prevent memory leaks in IE
</a><a name="line-5046" data-line="5046">		elem = null;
</a><a name="line-5047" data-line="5047">	},
</a><a name="line-5048" data-line="5048">
</a><a name="line-5049" data-line="5049">	global: {},
</a><a name="line-5050" data-line="5050">
</a><a name="line-5051" data-line="5051">	// Detach an event or set of events from an element
</a><a name="line-5052" data-line="5052">	remove: function( elem, types, handler, selector, mappedTypes ) {
</a><a name="line-5053" data-line="5053">
</a><a name="line-5054" data-line="5054">		var elemData = jQuery.hasData( elem ) &amp;&amp; jQuery._data( elem ),
</a><a name="line-5055" data-line="5055">			t, tns, type, origType, namespaces, origCount,
</a><a name="line-5056" data-line="5056">			j, events, special, handle, eventType, handleObj;
</a><a name="line-5057" data-line="5057">
</a><a name="line-5058" data-line="5058">		if ( !elemData || !(events = elemData.events) ) {
</a><a name="line-5059" data-line="5059">			return;
</a><a name="line-5060" data-line="5060">		}
</a><a name="line-5061" data-line="5061">
</a><a name="line-5062" data-line="5062">		// Once for each type.namespace in types; type may be omitted
</a><a name="line-5063" data-line="5063">		types = jQuery.trim( hoverHack( types || &quot;&quot; ) ).split(&quot; &quot;);
</a><a name="line-5064" data-line="5064">		for ( t = 0; t &lt; types.length; t++ ) {
</a><a name="line-5065" data-line="5065">			tns = rtypenamespace.exec( types[t] ) || [];
</a><a name="line-5066" data-line="5066">			type = origType = tns[1];
</a><a name="line-5067" data-line="5067">			namespaces = tns[2];
</a><a name="line-5068" data-line="5068">
</a><a name="line-5069" data-line="5069">			// Unbind all events (on this namespace, if provided) for the element
</a><a name="line-5070" data-line="5070">			if ( !type ) {
</a><a name="line-5071" data-line="5071">				for ( type in events ) {
</a><a name="line-5072" data-line="5072">					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
</a><a name="line-5073" data-line="5073">				}
</a><a name="line-5074" data-line="5074">				continue;
</a><a name="line-5075" data-line="5075">			}
</a><a name="line-5076" data-line="5076">
</a><a name="line-5077" data-line="5077">			special = jQuery.event.special[ type ] || {};
</a><a name="line-5078" data-line="5078">			type = ( selector? special.delegateType : special.bindType ) || type;
</a><a name="line-5079" data-line="5079">			eventType = events[ type ] || [];
</a><a name="line-5080" data-line="5080">			origCount = eventType.length;
</a><a name="line-5081" data-line="5081">			namespaces = namespaces ? new RegExp(&quot;(^|\\.)&quot; + namespaces.split(&quot;.&quot;).sort().join(&quot;\\.(?:.*\\.)?&quot;) + &quot;(\\.|$)&quot;) : null;
</a><a name="line-5082" data-line="5082">
</a><a name="line-5083" data-line="5083">			// Remove matching events
</a><a name="line-5084" data-line="5084">			for ( j = 0; j &lt; eventType.length; j++ ) {
</a><a name="line-5085" data-line="5085">				handleObj = eventType[ j ];
</a><a name="line-5086" data-line="5086">
</a><a name="line-5087" data-line="5087">				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
</a><a name="line-5088" data-line="5088">					 ( !handler || handler.guid === handleObj.guid ) &amp;&amp;
</a><a name="line-5089" data-line="5089">					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &amp;&amp;
</a><a name="line-5090" data-line="5090">					 ( !selector || selector === handleObj.selector || selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
</a><a name="line-5091" data-line="5091">					eventType.splice( j--, 1 );
</a><a name="line-5092" data-line="5092">
</a><a name="line-5093" data-line="5093">					if ( handleObj.selector ) {
</a><a name="line-5094" data-line="5094">						eventType.delegateCount--;
</a><a name="line-5095" data-line="5095">					}
</a><a name="line-5096" data-line="5096">					if ( special.remove ) {
</a><a name="line-5097" data-line="5097">						special.remove.call( elem, handleObj );
</a><a name="line-5098" data-line="5098">					}
</a><a name="line-5099" data-line="5099">				}
</a><a name="line-5100" data-line="5100">			}
</a><a name="line-5101" data-line="5101">
</a><a name="line-5102" data-line="5102">			// Remove generic event handler if we removed something and no more handlers exist
</a><a name="line-5103" data-line="5103">			// (avoids potential for endless recursion during removal of special event handlers)
</a><a name="line-5104" data-line="5104">			if ( eventType.length === 0 &amp;&amp; origCount !== eventType.length ) {
</a><a name="line-5105" data-line="5105">				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
</a><a name="line-5106" data-line="5106">					jQuery.removeEvent( elem, type, elemData.handle );
</a><a name="line-5107" data-line="5107">				}
</a><a name="line-5108" data-line="5108">
</a><a name="line-5109" data-line="5109">				delete events[ type ];
</a><a name="line-5110" data-line="5110">			}
</a><a name="line-5111" data-line="5111">		}
</a><a name="line-5112" data-line="5112">
</a><a name="line-5113" data-line="5113">		// Remove the expando if it's no longer used
</a><a name="line-5114" data-line="5114">		if ( jQuery.isEmptyObject( events ) ) {
</a><a name="line-5115" data-line="5115">			handle = elemData.handle;
</a><a name="line-5116" data-line="5116">			if ( handle ) {
</a><a name="line-5117" data-line="5117">				handle.elem = null;
</a><a name="line-5118" data-line="5118">			}
</a><a name="line-5119" data-line="5119">
</a><a name="line-5120" data-line="5120">			// removeData also checks for emptiness and clears the expando if empty
</a><a name="line-5121" data-line="5121">			// so use it instead of delete
</a><a name="line-5122" data-line="5122">			jQuery.removeData( elem, [ &quot;events&quot;, &quot;handle&quot; ], true );
</a><a name="line-5123" data-line="5123">		}
</a><a name="line-5124" data-line="5124">	},
</a><a name="line-5125" data-line="5125">
</a><a name="line-5126" data-line="5126">	// Events that are safe to short-circuit if no handlers are attached.
</a><a name="line-5127" data-line="5127">	// Native DOM events should not be added, they may have inline handlers.
</a><a name="line-5128" data-line="5128">	customEvent: {
</a><a name="line-5129" data-line="5129">		&quot;getData&quot;: true,
</a><a name="line-5130" data-line="5130">		&quot;setData&quot;: true,
</a><a name="line-5131" data-line="5131">		&quot;changeData&quot;: true
</a><a name="line-5132" data-line="5132">	},
</a><a name="line-5133" data-line="5133">
</a><a name="line-5134" data-line="5134">	trigger: function( event, data, elem, onlyHandlers ) {
</a><a name="line-5135" data-line="5135">		// Don't do events on text and comment nodes
</a><a name="line-5136" data-line="5136">		if ( elem &amp;&amp; (elem.nodeType === 3 || elem.nodeType === 8) ) {
</a><a name="line-5137" data-line="5137">			return;
</a><a name="line-5138" data-line="5138">		}
</a><a name="line-5139" data-line="5139">
</a><a name="line-5140" data-line="5140">		// Event object or event type
</a><a name="line-5141" data-line="5141">		var type = event.type || event,
</a><a name="line-5142" data-line="5142">			namespaces = [],
</a><a name="line-5143" data-line="5143">			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;
</a><a name="line-5144" data-line="5144">
</a><a name="line-5145" data-line="5145">		// focus/blur morphs to focusin/out; ensure we're not firing them right now
</a><a name="line-5146" data-line="5146">		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
</a><a name="line-5147" data-line="5147">			return;
</a><a name="line-5148" data-line="5148">		}
</a><a name="line-5149" data-line="5149">
</a><a name="line-5150" data-line="5150">		if ( type.indexOf( &quot;!&quot; ) &gt;= 0 ) {
</a><a name="line-5151" data-line="5151">			// Exclusive events trigger only for the exact event (no namespaces)
</a><a name="line-5152" data-line="5152">			type = type.slice(0, -1);
</a><a name="line-5153" data-line="5153">			exclusive = true;
</a><a name="line-5154" data-line="5154">		}
</a><a name="line-5155" data-line="5155">
</a><a name="line-5156" data-line="5156">		if ( type.indexOf( &quot;.&quot; ) &gt;= 0 ) {
</a><a name="line-5157" data-line="5157">			// Namespaced trigger; create a regexp to match event type in handle()
</a><a name="line-5158" data-line="5158">			namespaces = type.split(&quot;.&quot;);
</a><a name="line-5159" data-line="5159">			type = namespaces.shift();
</a><a name="line-5160" data-line="5160">			namespaces.sort();
</a><a name="line-5161" data-line="5161">		}
</a><a name="line-5162" data-line="5162">
</a><a name="line-5163" data-line="5163">		if ( (!elem || jQuery.event.customEvent[ type ]) &amp;&amp; !jQuery.event.global[ type ] ) {
</a><a name="line-5164" data-line="5164">			// No jQuery handlers for this event type, and it can't have inline handlers
</a><a name="line-5165" data-line="5165">			return;
</a><a name="line-5166" data-line="5166">		}
</a><a name="line-5167" data-line="5167">
</a><a name="line-5168" data-line="5168">		// Caller can pass in an Event, Object, or just an event type string
</a><a name="line-5169" data-line="5169">		event = typeof event === &quot;object&quot; ?
</a><a name="line-5170" data-line="5170">			// jQuery.Event object
</a><a name="line-5171" data-line="5171">			event[ jQuery.expando ] ? event :
</a><a name="line-5172" data-line="5172">			// Object literal
</a><a name="line-5173" data-line="5173">			new jQuery.Event( type, event ) :
</a><a name="line-5174" data-line="5174">			// Just the event type (string)
</a><a name="line-5175" data-line="5175">			new jQuery.Event( type );
</a><a name="line-5176" data-line="5176">
</a><a name="line-5177" data-line="5177">		event.type = type;
</a><a name="line-5178" data-line="5178">		event.isTrigger = true;
</a><a name="line-5179" data-line="5179">		event.exclusive = exclusive;
</a><a name="line-5180" data-line="5180">		event.namespace = namespaces.join( &quot;.&quot; );
</a><a name="line-5181" data-line="5181">		event.namespace_re = event.namespace? new RegExp(&quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.)?&quot;) + &quot;(\\.|$)&quot;) : null;
</a><a name="line-5182" data-line="5182">		ontype = type.indexOf( &quot;:&quot; ) &lt; 0 ? &quot;on&quot; + type : &quot;&quot;;
</a><a name="line-5183" data-line="5183">
</a><a name="line-5184" data-line="5184">		// Handle a global trigger
</a><a name="line-5185" data-line="5185">		if ( !elem ) {
</a><a name="line-5186" data-line="5186">
</a><a name="line-5187" data-line="5187">			// TODO: Stop taunting the data cache; remove global events and always attach to document
</a><a name="line-5188" data-line="5188">			cache = jQuery.cache;
</a><a name="line-5189" data-line="5189">			for ( i in cache ) {
</a><a name="line-5190" data-line="5190">				if ( cache[ i ].events &amp;&amp; cache[ i ].events[ type ] ) {
</a><a name="line-5191" data-line="5191">					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
</a><a name="line-5192" data-line="5192">				}
</a><a name="line-5193" data-line="5193">			}
</a><a name="line-5194" data-line="5194">			return;
</a><a name="line-5195" data-line="5195">		}
</a><a name="line-5196" data-line="5196">
</a><a name="line-5197" data-line="5197">		// Clean up the event in case it is being reused
</a><a name="line-5198" data-line="5198">		event.result = undefined;
</a><a name="line-5199" data-line="5199">		if ( !event.target ) {
</a><a name="line-5200" data-line="5200">			event.target = elem;
</a><a name="line-5201" data-line="5201">		}
</a><a name="line-5202" data-line="5202">
</a><a name="line-5203" data-line="5203">		// Clone any incoming data and prepend the event, creating the handler arg list
</a><a name="line-5204" data-line="5204">		data = data != null ? jQuery.makeArray( data ) : [];
</a><a name="line-5205" data-line="5205">		data.unshift( event );
</a><a name="line-5206" data-line="5206">
</a><a name="line-5207" data-line="5207">		// Allow special events to draw outside the lines
</a><a name="line-5208" data-line="5208">		special = jQuery.event.special[ type ] || {};
</a><a name="line-5209" data-line="5209">		if ( special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
</a><a name="line-5210" data-line="5210">			return;
</a><a name="line-5211" data-line="5211">		}
</a><a name="line-5212" data-line="5212">
</a><a name="line-5213" data-line="5213">		// Determine event propagation path in advance, per W3C events spec (#9951)
</a><a name="line-5214" data-line="5214">		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
</a><a name="line-5215" data-line="5215">		eventPath = [[ elem, special.bindType || type ]];
</a><a name="line-5216" data-line="5216">		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {
</a><a name="line-5217" data-line="5217">
</a><a name="line-5218" data-line="5218">			bubbleType = special.delegateType || type;
</a><a name="line-5219" data-line="5219">			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
</a><a name="line-5220" data-line="5220">			old = null;
</a><a name="line-5221" data-line="5221">			for ( ; cur; cur = cur.parentNode ) {
</a><a name="line-5222" data-line="5222">				eventPath.push([ cur, bubbleType ]);
</a><a name="line-5223" data-line="5223">				old = cur;
</a><a name="line-5224" data-line="5224">			}
</a><a name="line-5225" data-line="5225">
</a><a name="line-5226" data-line="5226">			// Only add window if we got to document (e.g., not plain obj or detached DOM)
</a><a name="line-5227" data-line="5227">			if ( old &amp;&amp; old === elem.ownerDocument ) {
</a><a name="line-5228" data-line="5228">				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
</a><a name="line-5229" data-line="5229">			}
</a><a name="line-5230" data-line="5230">		}
</a><a name="line-5231" data-line="5231">
</a><a name="line-5232" data-line="5232">		// Fire handlers on the event path
</a><a name="line-5233" data-line="5233">		for ( i = 0; i &lt; eventPath.length &amp;&amp; !event.isPropagationStopped(); i++ ) {
</a><a name="line-5234" data-line="5234">
</a><a name="line-5235" data-line="5235">			cur = eventPath[i][0];
</a><a name="line-5236" data-line="5236">			event.type = eventPath[i][1];
</a><a name="line-5237" data-line="5237">
</a><a name="line-5238" data-line="5238">			handle = ( jQuery._data( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp; jQuery._data( cur, &quot;handle&quot; );
</a><a name="line-5239" data-line="5239">			if ( handle ) {
</a><a name="line-5240" data-line="5240">				handle.apply( cur, data );
</a><a name="line-5241" data-line="5241">			}
</a><a name="line-5242" data-line="5242">			// Note that this is a bare JS function and not a jQuery handler
</a><a name="line-5243" data-line="5243">			handle = ontype &amp;&amp; cur[ ontype ];
</a><a name="line-5244" data-line="5244">			if ( handle &amp;&amp; jQuery.acceptData( cur ) &amp;&amp; handle.apply( cur, data ) === false ) {
</a><a name="line-5245" data-line="5245">				event.preventDefault();
</a><a name="line-5246" data-line="5246">			}
</a><a name="line-5247" data-line="5247">		}
</a><a name="line-5248" data-line="5248">		event.type = type;
</a><a name="line-5249" data-line="5249">
</a><a name="line-5250" data-line="5250">		// If nobody prevented the default action, do it now
</a><a name="line-5251" data-line="5251">		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {
</a><a name="line-5252" data-line="5252">
</a><a name="line-5253" data-line="5253">			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &amp;&amp;
</a><a name="line-5254" data-line="5254">				!(type === &quot;click&quot; &amp;&amp; jQuery.nodeName( elem, &quot;a&quot; )) &amp;&amp; jQuery.acceptData( elem ) ) {
</a><a name="line-5255" data-line="5255">
</a><a name="line-5256" data-line="5256">				// Call a native DOM method on the target with the same name name as the event.
</a><a name="line-5257" data-line="5257">				// Can't use an .isFunction() check here because IE6/7 fails that test.
</a><a name="line-5258" data-line="5258">				// Don't do default actions on window, that's where global variables be (#6170)
</a><a name="line-5259" data-line="5259">				// IE&lt;9 dies on focus/blur to hidden element (#1486)
</a><a name="line-5260" data-line="5260">				if ( ontype &amp;&amp; elem[ type ] &amp;&amp; ((type !== &quot;focus&quot; &amp;&amp; type !== &quot;blur&quot;) || event.target.offsetWidth !== 0) &amp;&amp; !jQuery.isWindow( elem ) ) {
</a><a name="line-5261" data-line="5261">
</a><a name="line-5262" data-line="5262">					// Don't re-trigger an onFOO event when we call its FOO() method
</a><a name="line-5263" data-line="5263">					old = elem[ ontype ];
</a><a name="line-5264" data-line="5264">
</a><a name="line-5265" data-line="5265">					if ( old ) {
</a><a name="line-5266" data-line="5266">						elem[ ontype ] = null;
</a><a name="line-5267" data-line="5267">					}
</a><a name="line-5268" data-line="5268">
</a><a name="line-5269" data-line="5269">					// Prevent re-triggering of the same event, since we already bubbled it above
</a><a name="line-5270" data-line="5270">					jQuery.event.triggered = type;
</a><a name="line-5271" data-line="5271">					elem[ type ]();
</a><a name="line-5272" data-line="5272">					jQuery.event.triggered = undefined;
</a><a name="line-5273" data-line="5273">
</a><a name="line-5274" data-line="5274">					if ( old ) {
</a><a name="line-5275" data-line="5275">						elem[ ontype ] = old;
</a><a name="line-5276" data-line="5276">					}
</a><a name="line-5277" data-line="5277">				}
</a><a name="line-5278" data-line="5278">			}
</a><a name="line-5279" data-line="5279">		}
</a><a name="line-5280" data-line="5280">
</a><a name="line-5281" data-line="5281">		return event.result;
</a><a name="line-5282" data-line="5282">	},
</a><a name="line-5283" data-line="5283">
</a><a name="line-5284" data-line="5284">	dispatch: function( event ) {
</a><a name="line-5285" data-line="5285">
</a><a name="line-5286" data-line="5286">		// Make a writable jQuery.Event from the native event object
</a><a name="line-5287" data-line="5287">		event = jQuery.event.fix( event || window.event );
</a><a name="line-5288" data-line="5288">
</a><a name="line-5289" data-line="5289">		var handlers = ( (jQuery._data( this, &quot;events&quot; ) || {} )[ event.type ] || []),
</a><a name="line-5290" data-line="5290">			delegateCount = handlers.delegateCount,
</a><a name="line-5291" data-line="5291">			args = [].slice.call( arguments, 0 ),
</a><a name="line-5292" data-line="5292">			run_all = !event.exclusive &amp;&amp; !event.namespace,
</a><a name="line-5293" data-line="5293">			special = jQuery.event.special[ event.type ] || {},
</a><a name="line-5294" data-line="5294">			handlerQueue = [],
</a><a name="line-5295" data-line="5295">			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;
</a><a name="line-5296" data-line="5296">
</a><a name="line-5297" data-line="5297">		// Use the fix-ed jQuery.Event rather than the (read-only) native event
</a><a name="line-5298" data-line="5298">		args[0] = event;
</a><a name="line-5299" data-line="5299">		event.delegateTarget = this;
</a><a name="line-5300" data-line="5300">
</a><a name="line-5301" data-line="5301">		// Call the preDispatch hook for the mapped type, and let it bail if desired
</a><a name="line-5302" data-line="5302">		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
</a><a name="line-5303" data-line="5303">			return;
</a><a name="line-5304" data-line="5304">		}
</a><a name="line-5305" data-line="5305">
</a><a name="line-5306" data-line="5306">		// Determine handlers that should run if there are delegated events
</a><a name="line-5307" data-line="5307">		// Avoid non-left-click bubbling in Firefox (#3861)
</a><a name="line-5308" data-line="5308">		if ( delegateCount &amp;&amp; !(event.button &amp;&amp; event.type === &quot;click&quot;) ) {
</a><a name="line-5309" data-line="5309">
</a><a name="line-5310" data-line="5310">			// Pregenerate a single jQuery object for reuse with .is()
</a><a name="line-5311" data-line="5311">			jqcur = jQuery(this);
</a><a name="line-5312" data-line="5312">			jqcur.context = this.ownerDocument || this;
</a><a name="line-5313" data-line="5313">
</a><a name="line-5314" data-line="5314">			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
</a><a name="line-5315" data-line="5315">
</a><a name="line-5316" data-line="5316">				// Don't process events on disabled elements (#6911, #8165)
</a><a name="line-5317" data-line="5317">				if ( cur.disabled !== true ) {
</a><a name="line-5318" data-line="5318">					selMatch = {};
</a><a name="line-5319" data-line="5319">					matches = [];
</a><a name="line-5320" data-line="5320">					jqcur[0] = cur;
</a><a name="line-5321" data-line="5321">					for ( i = 0; i &lt; delegateCount; i++ ) {
</a><a name="line-5322" data-line="5322">						handleObj = handlers[ i ];
</a><a name="line-5323" data-line="5323">						sel = handleObj.selector;
</a><a name="line-5324" data-line="5324">
</a><a name="line-5325" data-line="5325">						if ( selMatch[ sel ] === undefined ) {
</a><a name="line-5326" data-line="5326">							selMatch[ sel ] = (
</a><a name="line-5327" data-line="5327">								handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
</a><a name="line-5328" data-line="5328">							);
</a><a name="line-5329" data-line="5329">						}
</a><a name="line-5330" data-line="5330">						if ( selMatch[ sel ] ) {
</a><a name="line-5331" data-line="5331">							matches.push( handleObj );
</a><a name="line-5332" data-line="5332">						}
</a><a name="line-5333" data-line="5333">					}
</a><a name="line-5334" data-line="5334">					if ( matches.length ) {
</a><a name="line-5335" data-line="5335">						handlerQueue.push({ elem: cur, matches: matches });
</a><a name="line-5336" data-line="5336">					}
</a><a name="line-5337" data-line="5337">				}
</a><a name="line-5338" data-line="5338">			}
</a><a name="line-5339" data-line="5339">		}
</a><a name="line-5340" data-line="5340">
</a><a name="line-5341" data-line="5341">		// Add the remaining (directly-bound) handlers
</a><a name="line-5342" data-line="5342">		if ( handlers.length &gt; delegateCount ) {
</a><a name="line-5343" data-line="5343">			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
</a><a name="line-5344" data-line="5344">		}
</a><a name="line-5345" data-line="5345">
</a><a name="line-5346" data-line="5346">		// Run delegates first; they may want to stop propagation beneath us
</a><a name="line-5347" data-line="5347">		for ( i = 0; i &lt; handlerQueue.length &amp;&amp; !event.isPropagationStopped(); i++ ) {
</a><a name="line-5348" data-line="5348">			matched = handlerQueue[ i ];
</a><a name="line-5349" data-line="5349">			event.currentTarget = matched.elem;
</a><a name="line-5350" data-line="5350">
</a><a name="line-5351" data-line="5351">			for ( j = 0; j &lt; matched.matches.length &amp;&amp; !event.isImmediatePropagationStopped(); j++ ) {
</a><a name="line-5352" data-line="5352">				handleObj = matched.matches[ j ];
</a><a name="line-5353" data-line="5353">
</a><a name="line-5354" data-line="5354">				// Triggered event must either 1) be non-exclusive and have no namespace, or
</a><a name="line-5355" data-line="5355">				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
</a><a name="line-5356" data-line="5356">				if ( run_all || (!event.namespace &amp;&amp; !handleObj.namespace) || event.namespace_re &amp;&amp; event.namespace_re.test( handleObj.namespace ) ) {
</a><a name="line-5357" data-line="5357">
</a><a name="line-5358" data-line="5358">					event.data = handleObj.data;
</a><a name="line-5359" data-line="5359">					event.handleObj = handleObj;
</a><a name="line-5360" data-line="5360">
</a><a name="line-5361" data-line="5361">					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
</a><a name="line-5362" data-line="5362">							.apply( matched.elem, args );
</a><a name="line-5363" data-line="5363">
</a><a name="line-5364" data-line="5364">					if ( ret !== undefined ) {
</a><a name="line-5365" data-line="5365">						event.result = ret;
</a><a name="line-5366" data-line="5366">						if ( ret === false ) {
</a><a name="line-5367" data-line="5367">							event.preventDefault();
</a><a name="line-5368" data-line="5368">							event.stopPropagation();
</a><a name="line-5369" data-line="5369">						}
</a><a name="line-5370" data-line="5370">					}
</a><a name="line-5371" data-line="5371">				}
</a><a name="line-5372" data-line="5372">			}
</a><a name="line-5373" data-line="5373">		}
</a><a name="line-5374" data-line="5374">
</a><a name="line-5375" data-line="5375">		// Call the postDispatch hook for the mapped type
</a><a name="line-5376" data-line="5376">		if ( special.postDispatch ) {
</a><a name="line-5377" data-line="5377">			special.postDispatch.call( this, event );
</a><a name="line-5378" data-line="5378">		}
</a><a name="line-5379" data-line="5379">
</a><a name="line-5380" data-line="5380">		return event.result;
</a><a name="line-5381" data-line="5381">	},
</a><a name="line-5382" data-line="5382">
</a><a name="line-5383" data-line="5383">	// Includes some event props shared by KeyEvent and MouseEvent
</a><a name="line-5384" data-line="5384">	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
</a><a name="line-5385" data-line="5385">	props: &quot;attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;),
</a><a name="line-5386" data-line="5386">
</a><a name="line-5387" data-line="5387">	fixHooks: {},
</a><a name="line-5388" data-line="5388">
</a><a name="line-5389" data-line="5389">	keyHooks: {
</a><a name="line-5390" data-line="5390">		props: &quot;char charCode key keyCode&quot;.split(&quot; &quot;),
</a><a name="line-5391" data-line="5391">		filter: function( event, original ) {
</a><a name="line-5392" data-line="5392">
</a><a name="line-5393" data-line="5393">			// Add which for key events
</a><a name="line-5394" data-line="5394">			if ( event.which == null ) {
</a><a name="line-5395" data-line="5395">				event.which = original.charCode != null ? original.charCode : original.keyCode;
</a><a name="line-5396" data-line="5396">			}
</a><a name="line-5397" data-line="5397">
</a><a name="line-5398" data-line="5398">			return event;
</a><a name="line-5399" data-line="5399">		}
</a><a name="line-5400" data-line="5400">	},
</a><a name="line-5401" data-line="5401">
</a><a name="line-5402" data-line="5402">	mouseHooks: {
</a><a name="line-5403" data-line="5403">		props: &quot;button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement&quot;.split(&quot; &quot;),
</a><a name="line-5404" data-line="5404">		filter: function( event, original ) {
</a><a name="line-5405" data-line="5405">			var eventDoc, doc, body,
</a><a name="line-5406" data-line="5406">				button = original.button,
</a><a name="line-5407" data-line="5407">				fromElement = original.fromElement;
</a><a name="line-5408" data-line="5408">
</a><a name="line-5409" data-line="5409">			// Calculate pageX/Y if missing and clientX/Y available
</a><a name="line-5410" data-line="5410">			if ( event.pageX == null &amp;&amp; original.clientX != null ) {
</a><a name="line-5411" data-line="5411">				eventDoc = event.target.ownerDocument || document;
</a><a name="line-5412" data-line="5412">				doc = eventDoc.documentElement;
</a><a name="line-5413" data-line="5413">				body = eventDoc.body;
</a><a name="line-5414" data-line="5414">
</a><a name="line-5415" data-line="5415">				event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );
</a><a name="line-5416" data-line="5416">				event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );
</a><a name="line-5417" data-line="5417">			}
</a><a name="line-5418" data-line="5418">
</a><a name="line-5419" data-line="5419">			// Add relatedTarget, if necessary
</a><a name="line-5420" data-line="5420">			if ( !event.relatedTarget &amp;&amp; fromElement ) {
</a><a name="line-5421" data-line="5421">				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
</a><a name="line-5422" data-line="5422">			}
</a><a name="line-5423" data-line="5423">
</a><a name="line-5424" data-line="5424">			// Add which for click: 1 === left; 2 === middle; 3 === right
</a><a name="line-5425" data-line="5425">			// Note: button is not normalized, so don't use it
</a><a name="line-5426" data-line="5426">			if ( !event.which &amp;&amp; button !== undefined ) {
</a><a name="line-5427" data-line="5427">				event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );
</a><a name="line-5428" data-line="5428">			}
</a><a name="line-5429" data-line="5429">
</a><a name="line-5430" data-line="5430">			return event;
</a><a name="line-5431" data-line="5431">		}
</a><a name="line-5432" data-line="5432">	},
</a><a name="line-5433" data-line="5433">
</a><a name="line-5434" data-line="5434">	fix: function( event ) {
</a><a name="line-5435" data-line="5435">		if ( event[ jQuery.expando ] ) {
</a><a name="line-5436" data-line="5436">			return event;
</a><a name="line-5437" data-line="5437">		}
</a><a name="line-5438" data-line="5438">
</a><a name="line-5439" data-line="5439">		// Create a writable copy of the event object and normalize some properties
</a><a name="line-5440" data-line="5440">		var i, prop,
</a><a name="line-5441" data-line="5441">			originalEvent = event,
</a><a name="line-5442" data-line="5442">			fixHook = jQuery.event.fixHooks[ event.type ] || {},
</a><a name="line-5443" data-line="5443">			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
</a><a name="line-5444" data-line="5444">
</a><a name="line-5445" data-line="5445">		event = jQuery.Event( originalEvent );
</a><a name="line-5446" data-line="5446">
</a><a name="line-5447" data-line="5447">		for ( i = copy.length; i; ) {
</a><a name="line-5448" data-line="5448">			prop = copy[ --i ];
</a><a name="line-5449" data-line="5449">			event[ prop ] = originalEvent[ prop ];
</a><a name="line-5450" data-line="5450">		}
</a><a name="line-5451" data-line="5451">
</a><a name="line-5452" data-line="5452">		// Fix target property, if necessary (#1925, IE 6/7/8 &amp; Safari2)
</a><a name="line-5453" data-line="5453">		if ( !event.target ) {
</a><a name="line-5454" data-line="5454">			event.target = originalEvent.srcElement || document;
</a><a name="line-5455" data-line="5455">		}
</a><a name="line-5456" data-line="5456">
</a><a name="line-5457" data-line="5457">		// Target should not be a text node (#504, Safari)
</a><a name="line-5458" data-line="5458">		if ( event.target.nodeType === 3 ) {
</a><a name="line-5459" data-line="5459">			event.target = event.target.parentNode;
</a><a name="line-5460" data-line="5460">		}
</a><a name="line-5461" data-line="5461">
</a><a name="line-5462" data-line="5462">		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
</a><a name="line-5463" data-line="5463">		if ( event.metaKey === undefined ) {
</a><a name="line-5464" data-line="5464">			event.metaKey = event.ctrlKey;
</a><a name="line-5465" data-line="5465">		}
</a><a name="line-5466" data-line="5466">
</a><a name="line-5467" data-line="5467">		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
</a><a name="line-5468" data-line="5468">	},
</a><a name="line-5469" data-line="5469">
</a><a name="line-5470" data-line="5470">	special: {
</a><a name="line-5471" data-line="5471">		ready: {
</a><a name="line-5472" data-line="5472">			// Make sure the ready event is setup
</a><a name="line-5473" data-line="5473">			setup: jQuery.bindReady
</a><a name="line-5474" data-line="5474">		},
</a><a name="line-5475" data-line="5475">
</a><a name="line-5476" data-line="5476">		load: {
</a><a name="line-5477" data-line="5477">			// Prevent triggered image.load events from bubbling to window.load
</a><a name="line-5478" data-line="5478">			noBubble: true
</a><a name="line-5479" data-line="5479">		},
</a><a name="line-5480" data-line="5480">
</a><a name="line-5481" data-line="5481">		focus: {
</a><a name="line-5482" data-line="5482">			delegateType: &quot;focusin&quot;
</a><a name="line-5483" data-line="5483">		},
</a><a name="line-5484" data-line="5484">		blur: {
</a><a name="line-5485" data-line="5485">			delegateType: &quot;focusout&quot;
</a><a name="line-5486" data-line="5486">		},
</a><a name="line-5487" data-line="5487">
</a><a name="line-5488" data-line="5488">		beforeunload: {
</a><a name="line-5489" data-line="5489">			setup: function( data, namespaces, eventHandle ) {
</a><a name="line-5490" data-line="5490">				// We only want to do this special case on windows
</a><a name="line-5491" data-line="5491">				if ( jQuery.isWindow( this ) ) {
</a><a name="line-5492" data-line="5492">					this.onbeforeunload = eventHandle;
</a><a name="line-5493" data-line="5493">				}
</a><a name="line-5494" data-line="5494">			},
</a><a name="line-5495" data-line="5495">
</a><a name="line-5496" data-line="5496">			teardown: function( namespaces, eventHandle ) {
</a><a name="line-5497" data-line="5497">				if ( this.onbeforeunload === eventHandle ) {
</a><a name="line-5498" data-line="5498">					this.onbeforeunload = null;
</a><a name="line-5499" data-line="5499">				}
</a><a name="line-5500" data-line="5500">			}
</a><a name="line-5501" data-line="5501">		}
</a><a name="line-5502" data-line="5502">	},
</a><a name="line-5503" data-line="5503">
</a><a name="line-5504" data-line="5504">	simulate: function( type, elem, event, bubble ) {
</a><a name="line-5505" data-line="5505">		// Piggyback on a donor event to simulate a different one.
</a><a name="line-5506" data-line="5506">		// Fake originalEvent to avoid donor's stopPropagation, but if the
</a><a name="line-5507" data-line="5507">		// simulated event prevents default then we do the same on the donor.
</a><a name="line-5508" data-line="5508">		var e = jQuery.extend(
</a><a name="line-5509" data-line="5509">			new jQuery.Event(),
</a><a name="line-5510" data-line="5510">			event,
</a><a name="line-5511" data-line="5511">			{ type: type,
</a><a name="line-5512" data-line="5512">				isSimulated: true,
</a><a name="line-5513" data-line="5513">				originalEvent: {}
</a><a name="line-5514" data-line="5514">			}
</a><a name="line-5515" data-line="5515">		);
</a><a name="line-5516" data-line="5516">		if ( bubble ) {
</a><a name="line-5517" data-line="5517">			jQuery.event.trigger( e, null, elem );
</a><a name="line-5518" data-line="5518">		} else {
</a><a name="line-5519" data-line="5519">			jQuery.event.dispatch.call( elem, e );
</a><a name="line-5520" data-line="5520">		}
</a><a name="line-5521" data-line="5521">		if ( e.isDefaultPrevented() ) {
</a><a name="line-5522" data-line="5522">			event.preventDefault();
</a><a name="line-5523" data-line="5523">		}
</a><a name="line-5524" data-line="5524">	}
</a><a name="line-5525" data-line="5525">};
</a><a name="line-5526" data-line="5526">
</a><a name="line-5527" data-line="5527">// Some plugins are using, but it's undocumented/deprecated and will be removed.
</a><a name="line-5528" data-line="5528">// The 1.7 special event interface should provide all the hooks needed now.
</a><a name="line-5529" data-line="5529">jQuery.event.handle = jQuery.event.dispatch;
</a><a name="line-5530" data-line="5530">
</a><a name="line-5531" data-line="5531">jQuery.removeEvent = document.removeEventListener ?
</a><a name="line-5532" data-line="5532">	function( elem, type, handle ) {
</a><a name="line-5533" data-line="5533">		if ( elem.removeEventListener ) {
</a><a name="line-5534" data-line="5534">			elem.removeEventListener( type, handle, false );
</a><a name="line-5535" data-line="5535">		}
</a><a name="line-5536" data-line="5536">	} :
</a><a name="line-5537" data-line="5537">	function( elem, type, handle ) {
</a><a name="line-5538" data-line="5538">		if ( elem.detachEvent ) {
</a><a name="line-5539" data-line="5539">			elem.detachEvent( &quot;on&quot; + type, handle );
</a><a name="line-5540" data-line="5540">		}
</a><a name="line-5541" data-line="5541">	};
</a><a name="line-5542" data-line="5542">
</a><a name="line-5543" data-line="5543">jQuery.Event = function( src, props ) {
</a><a name="line-5544" data-line="5544">	// Allow instantiation without the 'new' keyword
</a><a name="line-5545" data-line="5545">	if ( !(this instanceof jQuery.Event) ) {
</a><a name="line-5546" data-line="5546">		return new jQuery.Event( src, props );
</a><a name="line-5547" data-line="5547">	}
</a><a name="line-5548" data-line="5548">
</a><a name="line-5549" data-line="5549">	// Event object
</a><a name="line-5550" data-line="5550">	if ( src &amp;&amp; src.type ) {
</a><a name="line-5551" data-line="5551">		this.originalEvent = src;
</a><a name="line-5552" data-line="5552">		this.type = src.type;
</a><a name="line-5553" data-line="5553">
</a><a name="line-5554" data-line="5554">		// Events bubbling up the document may have been marked as prevented
</a><a name="line-5555" data-line="5555">		// by a handler lower down the tree; reflect the correct value.
</a><a name="line-5556" data-line="5556">		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
</a><a name="line-5557" data-line="5557">			src.getPreventDefault &amp;&amp; src.getPreventDefault() ) ? returnTrue : returnFalse;
</a><a name="line-5558" data-line="5558">
</a><a name="line-5559" data-line="5559">	// Event type
</a><a name="line-5560" data-line="5560">	} else {
</a><a name="line-5561" data-line="5561">		this.type = src;
</a><a name="line-5562" data-line="5562">	}
</a><a name="line-5563" data-line="5563">
</a><a name="line-5564" data-line="5564">	// Put explicitly provided properties onto the event object
</a><a name="line-5565" data-line="5565">	if ( props ) {
</a><a name="line-5566" data-line="5566">		jQuery.extend( this, props );
</a><a name="line-5567" data-line="5567">	}
</a><a name="line-5568" data-line="5568">
</a><a name="line-5569" data-line="5569">	// Create a timestamp if incoming event doesn't have one
</a><a name="line-5570" data-line="5570">	this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();
</a><a name="line-5571" data-line="5571">
</a><a name="line-5572" data-line="5572">	// Mark it as fixed
</a><a name="line-5573" data-line="5573">	this[ jQuery.expando ] = true;
</a><a name="line-5574" data-line="5574">};
</a><a name="line-5575" data-line="5575">
</a><a name="line-5576" data-line="5576">function returnFalse() {
</a><a name="line-5577" data-line="5577">	return false;
</a><a name="line-5578" data-line="5578">}
</a><a name="line-5579" data-line="5579">function returnTrue() {
</a><a name="line-5580" data-line="5580">	return true;
</a><a name="line-5581" data-line="5581">}
</a><a name="line-5582" data-line="5582">
</a><a name="line-5583" data-line="5583">// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
</a><a name="line-5584" data-line="5584">// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
</a><a name="line-5585" data-line="5585">jQuery.Event.prototype = {
</a><a name="line-5586" data-line="5586">	preventDefault: function() {
</a><a name="line-5587" data-line="5587">		this.isDefaultPrevented = returnTrue;
</a><a name="line-5588" data-line="5588">
</a><a name="line-5589" data-line="5589">		var e = this.originalEvent;
</a><a name="line-5590" data-line="5590">		if ( !e ) {
</a><a name="line-5591" data-line="5591">			return;
</a><a name="line-5592" data-line="5592">		}
</a><a name="line-5593" data-line="5593">
</a><a name="line-5594" data-line="5594">		// if preventDefault exists run it on the original event
</a><a name="line-5595" data-line="5595">		if ( e.preventDefault ) {
</a><a name="line-5596" data-line="5596">			e.preventDefault();
</a><a name="line-5597" data-line="5597">
</a><a name="line-5598" data-line="5598">		// otherwise set the returnValue property of the original event to false (IE)
</a><a name="line-5599" data-line="5599">		} else {
</a><a name="line-5600" data-line="5600">			e.returnValue = false;
</a><a name="line-5601" data-line="5601">		}
</a><a name="line-5602" data-line="5602">	},
</a><a name="line-5603" data-line="5603">	stopPropagation: function() {
</a><a name="line-5604" data-line="5604">		this.isPropagationStopped = returnTrue;
</a><a name="line-5605" data-line="5605">
</a><a name="line-5606" data-line="5606">		var e = this.originalEvent;
</a><a name="line-5607" data-line="5607">		if ( !e ) {
</a><a name="line-5608" data-line="5608">			return;
</a><a name="line-5609" data-line="5609">		}
</a><a name="line-5610" data-line="5610">		// if stopPropagation exists run it on the original event
</a><a name="line-5611" data-line="5611">		if ( e.stopPropagation ) {
</a><a name="line-5612" data-line="5612">			e.stopPropagation();
</a><a name="line-5613" data-line="5613">		}
</a><a name="line-5614" data-line="5614">		// otherwise set the cancelBubble property of the original event to true (IE)
</a><a name="line-5615" data-line="5615">		e.cancelBubble = true;
</a><a name="line-5616" data-line="5616">	},
</a><a name="line-5617" data-line="5617">	stopImmediatePropagation: function() {
</a><a name="line-5618" data-line="5618">		this.isImmediatePropagationStopped = returnTrue;
</a><a name="line-5619" data-line="5619">		this.stopPropagation();
</a><a name="line-5620" data-line="5620">	},
</a><a name="line-5621" data-line="5621">	isDefaultPrevented: returnFalse,
</a><a name="line-5622" data-line="5622">	isPropagationStopped: returnFalse,
</a><a name="line-5623" data-line="5623">	isImmediatePropagationStopped: returnFalse
</a><a name="line-5624" data-line="5624">};
</a><a name="line-5625" data-line="5625">
</a><a name="line-5626" data-line="5626">// Create mouseenter/leave events using mouseover/out and event-time checks
</a><a name="line-5627" data-line="5627">jQuery.each({
</a><a name="line-5628" data-line="5628">	mouseenter: &quot;mouseover&quot;,
</a><a name="line-5629" data-line="5629">	mouseleave: &quot;mouseout&quot;
</a><a name="line-5630" data-line="5630">}, function( orig, fix ) {
</a><a name="line-5631" data-line="5631">	jQuery.event.special[ orig ] = {
</a><a name="line-5632" data-line="5632">		delegateType: fix,
</a><a name="line-5633" data-line="5633">		bindType: fix,
</a><a name="line-5634" data-line="5634">
</a><a name="line-5635" data-line="5635">		handle: function( event ) {
</a><a name="line-5636" data-line="5636">			var target = this,
</a><a name="line-5637" data-line="5637">				related = event.relatedTarget,
</a><a name="line-5638" data-line="5638">				handleObj = event.handleObj,
</a><a name="line-5639" data-line="5639">				selector = handleObj.selector,
</a><a name="line-5640" data-line="5640">				ret;
</a><a name="line-5641" data-line="5641">
</a><a name="line-5642" data-line="5642">			// For mousenter/leave call the handler if related is outside the target.
</a><a name="line-5643" data-line="5643">			// NB: No relatedTarget if the mouse left/entered the browser window
</a><a name="line-5644" data-line="5644">			if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {
</a><a name="line-5645" data-line="5645">				event.type = handleObj.origType;
</a><a name="line-5646" data-line="5646">				ret = handleObj.handler.apply( this, arguments );
</a><a name="line-5647" data-line="5647">				event.type = fix;
</a><a name="line-5648" data-line="5648">			}
</a><a name="line-5649" data-line="5649">			return ret;
</a><a name="line-5650" data-line="5650">		}
</a><a name="line-5651" data-line="5651">	};
</a><a name="line-5652" data-line="5652">});
</a><a name="line-5653" data-line="5653">
</a><a name="line-5654" data-line="5654">// IE submit delegation
</a><a name="line-5655" data-line="5655">if ( !jQuery.support.submitBubbles ) {
</a><a name="line-5656" data-line="5656">
</a><a name="line-5657" data-line="5657">	jQuery.event.special.submit = {
</a><a name="line-5658" data-line="5658">		setup: function() {
</a><a name="line-5659" data-line="5659">			// Only need this for delegated form submit events
</a><a name="line-5660" data-line="5660">			if ( jQuery.nodeName( this, &quot;form&quot; ) ) {
</a><a name="line-5661" data-line="5661">				return false;
</a><a name="line-5662" data-line="5662">			}
</a><a name="line-5663" data-line="5663">
</a><a name="line-5664" data-line="5664">			// Lazy-add a submit handler when a descendant form may potentially be submitted
</a><a name="line-5665" data-line="5665">			jQuery.event.add( this, &quot;click._submit keypress._submit&quot;, function( e ) {
</a><a name="line-5666" data-line="5666">				// Node name check avoids a VML-related crash in IE (#9807)
</a><a name="line-5667" data-line="5667">				var elem = e.target,
</a><a name="line-5668" data-line="5668">					form = jQuery.nodeName( elem, &quot;input&quot; ) || jQuery.nodeName( elem, &quot;button&quot; ) ? elem.form : undefined;
</a><a name="line-5669" data-line="5669">				if ( form &amp;&amp; !form._submit_attached ) {
</a><a name="line-5670" data-line="5670">					jQuery.event.add( form, &quot;submit._submit&quot;, function( event ) {
</a><a name="line-5671" data-line="5671">						event._submit_bubble = true;
</a><a name="line-5672" data-line="5672">					});
</a><a name="line-5673" data-line="5673">					form._submit_attached = true;
</a><a name="line-5674" data-line="5674">				}
</a><a name="line-5675" data-line="5675">			});
</a><a name="line-5676" data-line="5676">			// return undefined since we don't need an event listener
</a><a name="line-5677" data-line="5677">		},
</a><a name="line-5678" data-line="5678">		
</a><a name="line-5679" data-line="5679">		postDispatch: function( event ) {
</a><a name="line-5680" data-line="5680">			// If form was submitted by the user, bubble the event up the tree
</a><a name="line-5681" data-line="5681">			if ( event._submit_bubble ) {
</a><a name="line-5682" data-line="5682">				delete event._submit_bubble;
</a><a name="line-5683" data-line="5683">				if ( this.parentNode &amp;&amp; !event.isTrigger ) {
</a><a name="line-5684" data-line="5684">					jQuery.event.simulate( &quot;submit&quot;, this.parentNode, event, true );
</a><a name="line-5685" data-line="5685">				}
</a><a name="line-5686" data-line="5686">			}
</a><a name="line-5687" data-line="5687">		},
</a><a name="line-5688" data-line="5688">
</a><a name="line-5689" data-line="5689">		teardown: function() {
</a><a name="line-5690" data-line="5690">			// Only need this for delegated form submit events
</a><a name="line-5691" data-line="5691">			if ( jQuery.nodeName( this, &quot;form&quot; ) ) {
</a><a name="line-5692" data-line="5692">				return false;
</a><a name="line-5693" data-line="5693">			}
</a><a name="line-5694" data-line="5694">
</a><a name="line-5695" data-line="5695">			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
</a><a name="line-5696" data-line="5696">			jQuery.event.remove( this, &quot;._submit&quot; );
</a><a name="line-5697" data-line="5697">		}
</a><a name="line-5698" data-line="5698">	};
</a><a name="line-5699" data-line="5699">}
</a><a name="line-5700" data-line="5700">
</a><a name="line-5701" data-line="5701">// IE change delegation and checkbox/radio fix
</a><a name="line-5702" data-line="5702">if ( !jQuery.support.changeBubbles ) {
</a><a name="line-5703" data-line="5703">
</a><a name="line-5704" data-line="5704">	jQuery.event.special.change = {
</a><a name="line-5705" data-line="5705">
</a><a name="line-5706" data-line="5706">		setup: function() {
</a><a name="line-5707" data-line="5707">
</a><a name="line-5708" data-line="5708">			if ( rformElems.test( this.nodeName ) ) {
</a><a name="line-5709" data-line="5709">				// IE doesn't fire change on a check/radio until blur; trigger it on click
</a><a name="line-5710" data-line="5710">				// after a propertychange. Eat the blur-change in special.change.handle.
</a><a name="line-5711" data-line="5711">				// This still fires onchange a second time for check/radio after blur.
</a><a name="line-5712" data-line="5712">				if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) {
</a><a name="line-5713" data-line="5713">					jQuery.event.add( this, &quot;propertychange._change&quot;, function( event ) {
</a><a name="line-5714" data-line="5714">						if ( event.originalEvent.propertyName === &quot;checked&quot; ) {
</a><a name="line-5715" data-line="5715">							this._just_changed = true;
</a><a name="line-5716" data-line="5716">						}
</a><a name="line-5717" data-line="5717">					});
</a><a name="line-5718" data-line="5718">					jQuery.event.add( this, &quot;click._change&quot;, function( event ) {
</a><a name="line-5719" data-line="5719">						if ( this._just_changed &amp;&amp; !event.isTrigger ) {
</a><a name="line-5720" data-line="5720">							this._just_changed = false;
</a><a name="line-5721" data-line="5721">							jQuery.event.simulate( &quot;change&quot;, this, event, true );
</a><a name="line-5722" data-line="5722">						}
</a><a name="line-5723" data-line="5723">					});
</a><a name="line-5724" data-line="5724">				}
</a><a name="line-5725" data-line="5725">				return false;
</a><a name="line-5726" data-line="5726">			}
</a><a name="line-5727" data-line="5727">			// Delegated event; lazy-add a change handler on descendant inputs
</a><a name="line-5728" data-line="5728">			jQuery.event.add( this, &quot;beforeactivate._change&quot;, function( e ) {
</a><a name="line-5729" data-line="5729">				var elem = e.target;
</a><a name="line-5730" data-line="5730">
</a><a name="line-5731" data-line="5731">				if ( rformElems.test( elem.nodeName ) &amp;&amp; !elem._change_attached ) {
</a><a name="line-5732" data-line="5732">					jQuery.event.add( elem, &quot;change._change&quot;, function( event ) {
</a><a name="line-5733" data-line="5733">						if ( this.parentNode &amp;&amp; !event.isSimulated &amp;&amp; !event.isTrigger ) {
</a><a name="line-5734" data-line="5734">							jQuery.event.simulate( &quot;change&quot;, this.parentNode, event, true );
</a><a name="line-5735" data-line="5735">						}
</a><a name="line-5736" data-line="5736">					});
</a><a name="line-5737" data-line="5737">					elem._change_attached = true;
</a><a name="line-5738" data-line="5738">				}
</a><a name="line-5739" data-line="5739">			});
</a><a name="line-5740" data-line="5740">		},
</a><a name="line-5741" data-line="5741">
</a><a name="line-5742" data-line="5742">		handle: function( event ) {
</a><a name="line-5743" data-line="5743">			var elem = event.target;
</a><a name="line-5744" data-line="5744">
</a><a name="line-5745" data-line="5745">			// Swallow native change events from checkbox/radio, we already triggered them above
</a><a name="line-5746" data-line="5746">			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== &quot;radio&quot; &amp;&amp; elem.type !== &quot;checkbox&quot;) ) {
</a><a name="line-5747" data-line="5747">				return event.handleObj.handler.apply( this, arguments );
</a><a name="line-5748" data-line="5748">			}
</a><a name="line-5749" data-line="5749">		},
</a><a name="line-5750" data-line="5750">
</a><a name="line-5751" data-line="5751">		teardown: function() {
</a><a name="line-5752" data-line="5752">			jQuery.event.remove( this, &quot;._change&quot; );
</a><a name="line-5753" data-line="5753">
</a><a name="line-5754" data-line="5754">			return rformElems.test( this.nodeName );
</a><a name="line-5755" data-line="5755">		}
</a><a name="line-5756" data-line="5756">	};
</a><a name="line-5757" data-line="5757">}
</a><a name="line-5758" data-line="5758">
</a><a name="line-5759" data-line="5759">// Create &quot;bubbling&quot; focus and blur events
</a><a name="line-5760" data-line="5760">if ( !jQuery.support.focusinBubbles ) {
</a><a name="line-5761" data-line="5761">	jQuery.each({ focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {
</a><a name="line-5762" data-line="5762">
</a><a name="line-5763" data-line="5763">		// Attach a single capturing handler while someone wants focusin/focusout
</a><a name="line-5764" data-line="5764">		var attaches = 0,
</a><a name="line-5765" data-line="5765">			handler = function( event ) {
</a><a name="line-5766" data-line="5766">				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
</a><a name="line-5767" data-line="5767">			};
</a><a name="line-5768" data-line="5768">
</a><a name="line-5769" data-line="5769">		jQuery.event.special[ fix ] = {
</a><a name="line-5770" data-line="5770">			setup: function() {
</a><a name="line-5771" data-line="5771">				if ( attaches++ === 0 ) {
</a><a name="line-5772" data-line="5772">					document.addEventListener( orig, handler, true );
</a><a name="line-5773" data-line="5773">				}
</a><a name="line-5774" data-line="5774">			},
</a><a name="line-5775" data-line="5775">			teardown: function() {
</a><a name="line-5776" data-line="5776">				if ( --attaches === 0 ) {
</a><a name="line-5777" data-line="5777">					document.removeEventListener( orig, handler, true );
</a><a name="line-5778" data-line="5778">				}
</a><a name="line-5779" data-line="5779">			}
</a><a name="line-5780" data-line="5780">		};
</a><a name="line-5781" data-line="5781">	});
</a><a name="line-5782" data-line="5782">}
</a><a name="line-5783" data-line="5783">
</a><a name="line-5784" data-line="5784">jQuery.fn.extend({
</a><a name="line-5785" data-line="5785">
</a><a name="line-5786" data-line="5786">	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
</a><a name="line-5787" data-line="5787">		var origFn, type;
</a><a name="line-5788" data-line="5788">
</a><a name="line-5789" data-line="5789">		// Types can be a map of types/handlers
</a><a name="line-5790" data-line="5790">		if ( typeof types === &quot;object&quot; ) {
</a><a name="line-5791" data-line="5791">			// ( types-Object, selector, data )
</a><a name="line-5792" data-line="5792">			if ( typeof selector !== &quot;string&quot; ) { // &amp;&amp; selector != null
</a><a name="line-5793" data-line="5793">				// ( types-Object, data )
</a><a name="line-5794" data-line="5794">				data = data || selector;
</a><a name="line-5795" data-line="5795">				selector = undefined;
</a><a name="line-5796" data-line="5796">			}
</a><a name="line-5797" data-line="5797">			for ( type in types ) {
</a><a name="line-5798" data-line="5798">				this.on( type, selector, data, types[ type ], one );
</a><a name="line-5799" data-line="5799">			}
</a><a name="line-5800" data-line="5800">			return this;
</a><a name="line-5801" data-line="5801">		}
</a><a name="line-5802" data-line="5802">
</a><a name="line-5803" data-line="5803">		if ( data == null &amp;&amp; fn == null ) {
</a><a name="line-5804" data-line="5804">			// ( types, fn )
</a><a name="line-5805" data-line="5805">			fn = selector;
</a><a name="line-5806" data-line="5806">			data = selector = undefined;
</a><a name="line-5807" data-line="5807">		} else if ( fn == null ) {
</a><a name="line-5808" data-line="5808">			if ( typeof selector === &quot;string&quot; ) {
</a><a name="line-5809" data-line="5809">				// ( types, selector, fn )
</a><a name="line-5810" data-line="5810">				fn = data;
</a><a name="line-5811" data-line="5811">				data = undefined;
</a><a name="line-5812" data-line="5812">			} else {
</a><a name="line-5813" data-line="5813">				// ( types, data, fn )
</a><a name="line-5814" data-line="5814">				fn = data;
</a><a name="line-5815" data-line="5815">				data = selector;
</a><a name="line-5816" data-line="5816">				selector = undefined;
</a><a name="line-5817" data-line="5817">			}
</a><a name="line-5818" data-line="5818">		}
</a><a name="line-5819" data-line="5819">		if ( fn === false ) {
</a><a name="line-5820" data-line="5820">			fn = returnFalse;
</a><a name="line-5821" data-line="5821">		} else if ( !fn ) {
</a><a name="line-5822" data-line="5822">			return this;
</a><a name="line-5823" data-line="5823">		}
</a><a name="line-5824" data-line="5824">
</a><a name="line-5825" data-line="5825">		if ( one === 1 ) {
</a><a name="line-5826" data-line="5826">			origFn = fn;
</a><a name="line-5827" data-line="5827">			fn = function( event ) {
</a><a name="line-5828" data-line="5828">				// Can use an empty set, since event contains the info
</a><a name="line-5829" data-line="5829">				jQuery().off( event );
</a><a name="line-5830" data-line="5830">				return origFn.apply( this, arguments );
</a><a name="line-5831" data-line="5831">			};
</a><a name="line-5832" data-line="5832">			// Use same guid so caller can remove using origFn
</a><a name="line-5833" data-line="5833">			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
</a><a name="line-5834" data-line="5834">		}
</a><a name="line-5835" data-line="5835">		return this.each( function() {
</a><a name="line-5836" data-line="5836">			jQuery.event.add( this, types, fn, data, selector );
</a><a name="line-5837" data-line="5837">		});
</a><a name="line-5838" data-line="5838">	},
</a><a name="line-5839" data-line="5839">	one: function( types, selector, data, fn ) {
</a><a name="line-5840" data-line="5840">		return this.on( types, selector, data, fn, 1 );
</a><a name="line-5841" data-line="5841">	},
</a><a name="line-5842" data-line="5842">	off: function( types, selector, fn ) {
</a><a name="line-5843" data-line="5843">		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
</a><a name="line-5844" data-line="5844">			// ( event )  dispatched jQuery.Event
</a><a name="line-5845" data-line="5845">			var handleObj = types.handleObj;
</a><a name="line-5846" data-line="5846">			jQuery( types.delegateTarget ).off(
</a><a name="line-5847" data-line="5847">				handleObj.namespace ? handleObj.origType + &quot;.&quot; + handleObj.namespace : handleObj.origType,
</a><a name="line-5848" data-line="5848">				handleObj.selector,
</a><a name="line-5849" data-line="5849">				handleObj.handler
</a><a name="line-5850" data-line="5850">			);
</a><a name="line-5851" data-line="5851">			return this;
</a><a name="line-5852" data-line="5852">		}
</a><a name="line-5853" data-line="5853">		if ( typeof types === &quot;object&quot; ) {
</a><a name="line-5854" data-line="5854">			// ( types-object [, selector] )
</a><a name="line-5855" data-line="5855">			for ( var type in types ) {
</a><a name="line-5856" data-line="5856">				this.off( type, selector, types[ type ] );
</a><a name="line-5857" data-line="5857">			}
</a><a name="line-5858" data-line="5858">			return this;
</a><a name="line-5859" data-line="5859">		}
</a><a name="line-5860" data-line="5860">		if ( selector === false || typeof selector === &quot;function&quot; ) {
</a><a name="line-5861" data-line="5861">			// ( types [, fn] )
</a><a name="line-5862" data-line="5862">			fn = selector;
</a><a name="line-5863" data-line="5863">			selector = undefined;
</a><a name="line-5864" data-line="5864">		}
</a><a name="line-5865" data-line="5865">		if ( fn === false ) {
</a><a name="line-5866" data-line="5866">			fn = returnFalse;
</a><a name="line-5867" data-line="5867">		}
</a><a name="line-5868" data-line="5868">		return this.each(function() {
</a><a name="line-5869" data-line="5869">			jQuery.event.remove( this, types, fn, selector );
</a><a name="line-5870" data-line="5870">		});
</a><a name="line-5871" data-line="5871">	},
</a><a name="line-5872" data-line="5872">
</a><a name="line-5873" data-line="5873">	bind: function( types, data, fn ) {
</a><a name="line-5874" data-line="5874">		return this.on( types, null, data, fn );
</a><a name="line-5875" data-line="5875">	},
</a><a name="line-5876" data-line="5876">	unbind: function( types, fn ) {
</a><a name="line-5877" data-line="5877">		return this.off( types, null, fn );
</a><a name="line-5878" data-line="5878">	},
</a><a name="line-5879" data-line="5879">
</a><a name="line-5880" data-line="5880">	live: function( types, data, fn ) {
</a><a name="line-5881" data-line="5881">		jQuery( this.context ).on( types, this.selector, data, fn );
</a><a name="line-5882" data-line="5882">		return this;
</a><a name="line-5883" data-line="5883">	},
</a><a name="line-5884" data-line="5884">	die: function( types, fn ) {
</a><a name="line-5885" data-line="5885">		jQuery( this.context ).off( types, this.selector || &quot;**&quot;, fn );
</a><a name="line-5886" data-line="5886">		return this;
</a><a name="line-5887" data-line="5887">	},
</a><a name="line-5888" data-line="5888">
</a><a name="line-5889" data-line="5889">	delegate: function( selector, types, data, fn ) {
</a><a name="line-5890" data-line="5890">		return this.on( types, selector, data, fn );
</a><a name="line-5891" data-line="5891">	},
</a><a name="line-5892" data-line="5892">	undelegate: function( selector, types, fn ) {
</a><a name="line-5893" data-line="5893">		// ( namespace ) or ( selector, types [, fn] )
</a><a name="line-5894" data-line="5894">		return arguments.length == 1? this.off( selector, &quot;**&quot; ) : this.off( types, selector, fn );
</a><a name="line-5895" data-line="5895">	},
</a><a name="line-5896" data-line="5896">
</a><a name="line-5897" data-line="5897">	trigger: function( type, data ) {
</a><a name="line-5898" data-line="5898">		return this.each(function() {
</a><a name="line-5899" data-line="5899">			jQuery.event.trigger( type, data, this );
</a><a name="line-5900" data-line="5900">		});
</a><a name="line-5901" data-line="5901">	},
</a><a name="line-5902" data-line="5902">	triggerHandler: function( type, data ) {
</a><a name="line-5903" data-line="5903">		if ( this[0] ) {
</a><a name="line-5904" data-line="5904">			return jQuery.event.trigger( type, data, this[0], true );
</a><a name="line-5905" data-line="5905">		}
</a><a name="line-5906" data-line="5906">	},
</a><a name="line-5907" data-line="5907">
</a><a name="line-5908" data-line="5908">	toggle: function( fn ) {
</a><a name="line-5909" data-line="5909">		// Save reference to arguments for access in closure
</a><a name="line-5910" data-line="5910">		var args = arguments,
</a><a name="line-5911" data-line="5911">			guid = fn.guid || jQuery.guid++,
</a><a name="line-5912" data-line="5912">			i = 0,
</a><a name="line-5913" data-line="5913">			toggler = function( event ) {
</a><a name="line-5914" data-line="5914">				// Figure out which function to execute
</a><a name="line-5915" data-line="5915">				var lastToggle = ( jQuery._data( this, &quot;lastToggle&quot; + fn.guid ) || 0 ) % i;
</a><a name="line-5916" data-line="5916">				jQuery._data( this, &quot;lastToggle&quot; + fn.guid, lastToggle + 1 );
</a><a name="line-5917" data-line="5917">
</a><a name="line-5918" data-line="5918">				// Make sure that clicks stop
</a><a name="line-5919" data-line="5919">				event.preventDefault();
</a><a name="line-5920" data-line="5920">
</a><a name="line-5921" data-line="5921">				// and execute the function
</a><a name="line-5922" data-line="5922">				return args[ lastToggle ].apply( this, arguments ) || false;
</a><a name="line-5923" data-line="5923">			};
</a><a name="line-5924" data-line="5924">
</a><a name="line-5925" data-line="5925">		// link all the functions, so any of them can unbind this click handler
</a><a name="line-5926" data-line="5926">		toggler.guid = guid;
</a><a name="line-5927" data-line="5927">		while ( i &lt; args.length ) {
</a><a name="line-5928" data-line="5928">			args[ i++ ].guid = guid;
</a><a name="line-5929" data-line="5929">		}
</a><a name="line-5930" data-line="5930">
</a><a name="line-5931" data-line="5931">		return this.click( toggler );
</a><a name="line-5932" data-line="5932">	},
</a><a name="line-5933" data-line="5933">
</a><a name="line-5934" data-line="5934">	hover: function( fnOver, fnOut ) {
</a><a name="line-5935" data-line="5935">		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
</a><a name="line-5936" data-line="5936">	}
</a><a name="line-5937" data-line="5937">});
</a><a name="line-5938" data-line="5938">
</a><a name="line-5939" data-line="5939">jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +
</a><a name="line-5940" data-line="5940">	&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
</a><a name="line-5941" data-line="5941">	&quot;change select submit keydown keypress keyup error contextmenu&quot;).split(&quot; &quot;), function( i, name ) {
</a><a name="line-5942" data-line="5942">
</a><a name="line-5943" data-line="5943">	// Handle event binding
</a><a name="line-5944" data-line="5944">	jQuery.fn[ name ] = function( data, fn ) {
</a><a name="line-5945" data-line="5945">		if ( fn == null ) {
</a><a name="line-5946" data-line="5946">			fn = data;
</a><a name="line-5947" data-line="5947">			data = null;
</a><a name="line-5948" data-line="5948">		}
</a><a name="line-5949" data-line="5949">
</a><a name="line-5950" data-line="5950">		return arguments.length &gt; 0 ?
</a><a name="line-5951" data-line="5951">			this.on( name, null, data, fn ) :
</a><a name="line-5952" data-line="5952">			this.trigger( name );
</a><a name="line-5953" data-line="5953">	};
</a><a name="line-5954" data-line="5954">
</a><a name="line-5955" data-line="5955">	if ( jQuery.attrFn ) {
</a><a name="line-5956" data-line="5956">		jQuery.attrFn[ name ] = true;
</a><a name="line-5957" data-line="5957">	}
</a><a name="line-5958" data-line="5958">
</a><a name="line-5959" data-line="5959">	if ( rkeyEvent.test( name ) ) {
</a><a name="line-5960" data-line="5960">		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
</a><a name="line-5961" data-line="5961">	}
</a><a name="line-5962" data-line="5962">
</a><a name="line-5963" data-line="5963">	if ( rmouseEvent.test( name ) ) {
</a><a name="line-5964" data-line="5964">		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
</a><a name="line-5965" data-line="5965">	}
</a><a name="line-5966" data-line="5966">});
</a><a name="line-5967" data-line="5967">
</a><a name="line-5968" data-line="5968">
</a><a name="line-5969" data-line="5969">
</a><a name="line-5970" data-line="5970">/*!
</a><a name="line-5971" data-line="5971"> * Sizzle CSS Selector Engine
</a><a name="line-5972" data-line="5972"> *  Copyright 2011, The Dojo Foundation
</a><a name="line-5973" data-line="5973"> *  Released under the MIT, BSD, and GPL Licenses.
</a><a name="line-5974" data-line="5974"> *  More information: http://sizzlejs.com/
</a><a name="line-5975" data-line="5975"> */
</a><a name="line-5976" data-line="5976">(function(){
</a><a name="line-5977" data-line="5977">
</a><a name="line-5978" data-line="5978">var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['&quot;][^'&quot;]*['&quot;]|[^\[\]'&quot;]+)+\]|\\.|[^ &gt;+~,(\[\\]+)+|[&gt;+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
</a><a name="line-5979" data-line="5979">	expando = &quot;sizcache&quot; + (Math.random() + '').replace('.', ''),
</a><a name="line-5980" data-line="5980">	done = 0,
</a><a name="line-5981" data-line="5981">	toString = Object.prototype.toString,
</a><a name="line-5982" data-line="5982">	hasDuplicate = false,
</a><a name="line-5983" data-line="5983">	baseHasDuplicate = true,
</a><a name="line-5984" data-line="5984">	rBackslash = /\\/g,
</a><a name="line-5985" data-line="5985">	rReturn = /\r\n/g,
</a><a name="line-5986" data-line="5986">	rNonWord = /\W/;
</a><a name="line-5987" data-line="5987">
</a><a name="line-5988" data-line="5988">// Here we check if the JavaScript engine is using some sort of
</a><a name="line-5989" data-line="5989">// optimization where it does not always call our comparision
</a><a name="line-5990" data-line="5990">// function. If that is the case, discard the hasDuplicate value.
</a><a name="line-5991" data-line="5991">//   Thus far that includes Google Chrome.
</a><a name="line-5992" data-line="5992">[0, 0].sort(function() {
</a><a name="line-5993" data-line="5993">	baseHasDuplicate = false;
</a><a name="line-5994" data-line="5994">	return 0;
</a><a name="line-5995" data-line="5995">});
</a><a name="line-5996" data-line="5996">
</a><a name="line-5997" data-line="5997">var Sizzle = function( selector, context, results, seed ) {
</a><a name="line-5998" data-line="5998">	results = results || [];
</a><a name="line-5999" data-line="5999">	context = context || document;
</a><a name="line-6000" data-line="6000">
</a><a name="line-6001" data-line="6001">	var origContext = context;
</a><a name="line-6002" data-line="6002">
</a><a name="line-6003" data-line="6003">	if ( context.nodeType !== 1 &amp;&amp; context.nodeType !== 9 ) {
</a><a name="line-6004" data-line="6004">		return [];
</a><a name="line-6005" data-line="6005">	}
</a><a name="line-6006" data-line="6006">
</a><a name="line-6007" data-line="6007">	if ( !selector || typeof selector !== &quot;string&quot; ) {
</a><a name="line-6008" data-line="6008">		return results;
</a><a name="line-6009" data-line="6009">	}
</a><a name="line-6010" data-line="6010">
</a><a name="line-6011" data-line="6011">	var m, set, checkSet, extra, ret, cur, pop, i,
</a><a name="line-6012" data-line="6012">		prune = true,
</a><a name="line-6013" data-line="6013">		contextXML = Sizzle.isXML( context ),
</a><a name="line-6014" data-line="6014">		parts = [],
</a><a name="line-6015" data-line="6015">		soFar = selector;
</a><a name="line-6016" data-line="6016">
</a><a name="line-6017" data-line="6017">	// Reset the position of the chunker regexp (start from head)
</a><a name="line-6018" data-line="6018">	do {
</a><a name="line-6019" data-line="6019">		chunker.exec( &quot;&quot; );
</a><a name="line-6020" data-line="6020">		m = chunker.exec( soFar );
</a><a name="line-6021" data-line="6021">
</a><a name="line-6022" data-line="6022">		if ( m ) {
</a><a name="line-6023" data-line="6023">			soFar = m[3];
</a><a name="line-6024" data-line="6024">
</a><a name="line-6025" data-line="6025">			parts.push( m[1] );
</a><a name="line-6026" data-line="6026">
</a><a name="line-6027" data-line="6027">			if ( m[2] ) {
</a><a name="line-6028" data-line="6028">				extra = m[3];
</a><a name="line-6029" data-line="6029">				break;
</a><a name="line-6030" data-line="6030">			}
</a><a name="line-6031" data-line="6031">		}
</a><a name="line-6032" data-line="6032">	} while ( m );
</a><a name="line-6033" data-line="6033">
</a><a name="line-6034" data-line="6034">	if ( parts.length &gt; 1 &amp;&amp; origPOS.exec( selector ) ) {
</a><a name="line-6035" data-line="6035">
</a><a name="line-6036" data-line="6036">		if ( parts.length === 2 &amp;&amp; Expr.relative[ parts[0] ] ) {
</a><a name="line-6037" data-line="6037">			set = posProcess( parts[0] + parts[1], context, seed );
</a><a name="line-6038" data-line="6038">
</a><a name="line-6039" data-line="6039">		} else {
</a><a name="line-6040" data-line="6040">			set = Expr.relative[ parts[0] ] ?
</a><a name="line-6041" data-line="6041">				[ context ] :
</a><a name="line-6042" data-line="6042">				Sizzle( parts.shift(), context );
</a><a name="line-6043" data-line="6043">
</a><a name="line-6044" data-line="6044">			while ( parts.length ) {
</a><a name="line-6045" data-line="6045">				selector = parts.shift();
</a><a name="line-6046" data-line="6046">
</a><a name="line-6047" data-line="6047">				if ( Expr.relative[ selector ] ) {
</a><a name="line-6048" data-line="6048">					selector += parts.shift();
</a><a name="line-6049" data-line="6049">				}
</a><a name="line-6050" data-line="6050">
</a><a name="line-6051" data-line="6051">				set = posProcess( selector, set, seed );
</a><a name="line-6052" data-line="6052">			}
</a><a name="line-6053" data-line="6053">		}
</a><a name="line-6054" data-line="6054">
</a><a name="line-6055" data-line="6055">	} else {
</a><a name="line-6056" data-line="6056">		// Take a shortcut and set the context if the root selector is an ID
</a><a name="line-6057" data-line="6057">		// (but not if it'll be faster if the inner selector is an ID)
</a><a name="line-6058" data-line="6058">		if ( !seed &amp;&amp; parts.length &gt; 1 &amp;&amp; context.nodeType === 9 &amp;&amp; !contextXML &amp;&amp;
</a><a name="line-6059" data-line="6059">				Expr.match.ID.test(parts[0]) &amp;&amp; !Expr.match.ID.test(parts[parts.length - 1]) ) {
</a><a name="line-6060" data-line="6060">
</a><a name="line-6061" data-line="6061">			ret = Sizzle.find( parts.shift(), context, contextXML );
</a><a name="line-6062" data-line="6062">			context = ret.expr ?
</a><a name="line-6063" data-line="6063">				Sizzle.filter( ret.expr, ret.set )[0] :
</a><a name="line-6064" data-line="6064">				ret.set[0];
</a><a name="line-6065" data-line="6065">		}
</a><a name="line-6066" data-line="6066">
</a><a name="line-6067" data-line="6067">		if ( context ) {
</a><a name="line-6068" data-line="6068">			ret = seed ?
</a><a name="line-6069" data-line="6069">				{ expr: parts.pop(), set: makeArray(seed) } :
</a><a name="line-6070" data-line="6070">				Sizzle.find( parts.pop(), parts.length === 1 &amp;&amp; (parts[0] === &quot;~&quot; || parts[0] === &quot;+&quot;) &amp;&amp; context.parentNode ? context.parentNode : context, contextXML );
</a><a name="line-6071" data-line="6071">
</a><a name="line-6072" data-line="6072">			set = ret.expr ?
</a><a name="line-6073" data-line="6073">				Sizzle.filter( ret.expr, ret.set ) :
</a><a name="line-6074" data-line="6074">				ret.set;
</a><a name="line-6075" data-line="6075">
</a><a name="line-6076" data-line="6076">			if ( parts.length &gt; 0 ) {
</a><a name="line-6077" data-line="6077">				checkSet = makeArray( set );
</a><a name="line-6078" data-line="6078">
</a><a name="line-6079" data-line="6079">			} else {
</a><a name="line-6080" data-line="6080">				prune = false;
</a><a name="line-6081" data-line="6081">			}
</a><a name="line-6082" data-line="6082">
</a><a name="line-6083" data-line="6083">			while ( parts.length ) {
</a><a name="line-6084" data-line="6084">				cur = parts.pop();
</a><a name="line-6085" data-line="6085">				pop = cur;
</a><a name="line-6086" data-line="6086">
</a><a name="line-6087" data-line="6087">				if ( !Expr.relative[ cur ] ) {
</a><a name="line-6088" data-line="6088">					cur = &quot;&quot;;
</a><a name="line-6089" data-line="6089">				} else {
</a><a name="line-6090" data-line="6090">					pop = parts.pop();
</a><a name="line-6091" data-line="6091">				}
</a><a name="line-6092" data-line="6092">
</a><a name="line-6093" data-line="6093">				if ( pop == null ) {
</a><a name="line-6094" data-line="6094">					pop = context;
</a><a name="line-6095" data-line="6095">				}
</a><a name="line-6096" data-line="6096">
</a><a name="line-6097" data-line="6097">				Expr.relative[ cur ]( checkSet, pop, contextXML );
</a><a name="line-6098" data-line="6098">			}
</a><a name="line-6099" data-line="6099">
</a><a name="line-6100" data-line="6100">		} else {
</a><a name="line-6101" data-line="6101">			checkSet = parts = [];
</a><a name="line-6102" data-line="6102">		}
</a><a name="line-6103" data-line="6103">	}
</a><a name="line-6104" data-line="6104">
</a><a name="line-6105" data-line="6105">	if ( !checkSet ) {
</a><a name="line-6106" data-line="6106">		checkSet = set;
</a><a name="line-6107" data-line="6107">	}
</a><a name="line-6108" data-line="6108">
</a><a name="line-6109" data-line="6109">	if ( !checkSet ) {
</a><a name="line-6110" data-line="6110">		Sizzle.error( cur || selector );
</a><a name="line-6111" data-line="6111">	}
</a><a name="line-6112" data-line="6112">
</a><a name="line-6113" data-line="6113">	if ( toString.call(checkSet) === &quot;[object Array]&quot; ) {
</a><a name="line-6114" data-line="6114">		if ( !prune ) {
</a><a name="line-6115" data-line="6115">			results.push.apply( results, checkSet );
</a><a name="line-6116" data-line="6116">
</a><a name="line-6117" data-line="6117">		} else if ( context &amp;&amp; context.nodeType === 1 ) {
</a><a name="line-6118" data-line="6118">			for ( i = 0; checkSet[i] != null; i++ ) {
</a><a name="line-6119" data-line="6119">				if ( checkSet[i] &amp;&amp; (checkSet[i] === true || checkSet[i].nodeType === 1 &amp;&amp; Sizzle.contains(context, checkSet[i])) ) {
</a><a name="line-6120" data-line="6120">					results.push( set[i] );
</a><a name="line-6121" data-line="6121">				}
</a><a name="line-6122" data-line="6122">			}
</a><a name="line-6123" data-line="6123">
</a><a name="line-6124" data-line="6124">		} else {
</a><a name="line-6125" data-line="6125">			for ( i = 0; checkSet[i] != null; i++ ) {
</a><a name="line-6126" data-line="6126">				if ( checkSet[i] &amp;&amp; checkSet[i].nodeType === 1 ) {
</a><a name="line-6127" data-line="6127">					results.push( set[i] );
</a><a name="line-6128" data-line="6128">				}
</a><a name="line-6129" data-line="6129">			}
</a><a name="line-6130" data-line="6130">		}
</a><a name="line-6131" data-line="6131">
</a><a name="line-6132" data-line="6132">	} else {
</a><a name="line-6133" data-line="6133">		makeArray( checkSet, results );
</a><a name="line-6134" data-line="6134">	}
</a><a name="line-6135" data-line="6135">
</a><a name="line-6136" data-line="6136">	if ( extra ) {
</a><a name="line-6137" data-line="6137">		Sizzle( extra, origContext, results, seed );
</a><a name="line-6138" data-line="6138">		Sizzle.uniqueSort( results );
</a><a name="line-6139" data-line="6139">	}
</a><a name="line-6140" data-line="6140">
</a><a name="line-6141" data-line="6141">	return results;
</a><a name="line-6142" data-line="6142">};
</a><a name="line-6143" data-line="6143">
</a><a name="line-6144" data-line="6144">Sizzle.uniqueSort = function( results ) {
</a><a name="line-6145" data-line="6145">	if ( sortOrder ) {
</a><a name="line-6146" data-line="6146">		hasDuplicate = baseHasDuplicate;
</a><a name="line-6147" data-line="6147">		results.sort( sortOrder );
</a><a name="line-6148" data-line="6148">
</a><a name="line-6149" data-line="6149">		if ( hasDuplicate ) {
</a><a name="line-6150" data-line="6150">			for ( var i = 1; i &lt; results.length; i++ ) {
</a><a name="line-6151" data-line="6151">				if ( results[i] === results[ i - 1 ] ) {
</a><a name="line-6152" data-line="6152">					results.splice( i--, 1 );
</a><a name="line-6153" data-line="6153">				}
</a><a name="line-6154" data-line="6154">			}
</a><a name="line-6155" data-line="6155">		}
</a><a name="line-6156" data-line="6156">	}
</a><a name="line-6157" data-line="6157">
</a><a name="line-6158" data-line="6158">	return results;
</a><a name="line-6159" data-line="6159">};
</a><a name="line-6160" data-line="6160">
</a><a name="line-6161" data-line="6161">Sizzle.matches = function( expr, set ) {
</a><a name="line-6162" data-line="6162">	return Sizzle( expr, null, null, set );
</a><a name="line-6163" data-line="6163">};
</a><a name="line-6164" data-line="6164">
</a><a name="line-6165" data-line="6165">Sizzle.matchesSelector = function( node, expr ) {
</a><a name="line-6166" data-line="6166">	return Sizzle( expr, null, null, [node] ).length &gt; 0;
</a><a name="line-6167" data-line="6167">};
</a><a name="line-6168" data-line="6168">
</a><a name="line-6169" data-line="6169">Sizzle.find = function( expr, context, isXML ) {
</a><a name="line-6170" data-line="6170">	var set, i, len, match, type, left;
</a><a name="line-6171" data-line="6171">
</a><a name="line-6172" data-line="6172">	if ( !expr ) {
</a><a name="line-6173" data-line="6173">		return [];
</a><a name="line-6174" data-line="6174">	}
</a><a name="line-6175" data-line="6175">
</a><a name="line-6176" data-line="6176">	for ( i = 0, len = Expr.order.length; i &lt; len; i++ ) {
</a><a name="line-6177" data-line="6177">		type = Expr.order[i];
</a><a name="line-6178" data-line="6178">
</a><a name="line-6179" data-line="6179">		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
</a><a name="line-6180" data-line="6180">			left = match[1];
</a><a name="line-6181" data-line="6181">			match.splice( 1, 1 );
</a><a name="line-6182" data-line="6182">
</a><a name="line-6183" data-line="6183">			if ( left.substr( left.length - 1 ) !== &quot;\\&quot; ) {
</a><a name="line-6184" data-line="6184">				match[1] = (match[1] || &quot;&quot;).replace( rBackslash, &quot;&quot; );
</a><a name="line-6185" data-line="6185">				set = Expr.find[ type ]( match, context, isXML );
</a><a name="line-6186" data-line="6186">
</a><a name="line-6187" data-line="6187">				if ( set != null ) {
</a><a name="line-6188" data-line="6188">					expr = expr.replace( Expr.match[ type ], &quot;&quot; );
</a><a name="line-6189" data-line="6189">					break;
</a><a name="line-6190" data-line="6190">				}
</a><a name="line-6191" data-line="6191">			}
</a><a name="line-6192" data-line="6192">		}
</a><a name="line-6193" data-line="6193">	}
</a><a name="line-6194" data-line="6194">
</a><a name="line-6195" data-line="6195">	if ( !set ) {
</a><a name="line-6196" data-line="6196">		set = typeof context.getElementsByTagName !== &quot;undefined&quot; ?
</a><a name="line-6197" data-line="6197">			context.getElementsByTagName( &quot;*&quot; ) :
</a><a name="line-6198" data-line="6198">			[];
</a><a name="line-6199" data-line="6199">	}
</a><a name="line-6200" data-line="6200">
</a><a name="line-6201" data-line="6201">	return { set: set, expr: expr };
</a><a name="line-6202" data-line="6202">};
</a><a name="line-6203" data-line="6203">
</a><a name="line-6204" data-line="6204">Sizzle.filter = function( expr, set, inplace, not ) {
</a><a name="line-6205" data-line="6205">	var match, anyFound,
</a><a name="line-6206" data-line="6206">		type, found, item, filter, left,
</a><a name="line-6207" data-line="6207">		i, pass,
</a><a name="line-6208" data-line="6208">		old = expr,
</a><a name="line-6209" data-line="6209">		result = [],
</a><a name="line-6210" data-line="6210">		curLoop = set,
</a><a name="line-6211" data-line="6211">		isXMLFilter = set &amp;&amp; set[0] &amp;&amp; Sizzle.isXML( set[0] );
</a><a name="line-6212" data-line="6212">
</a><a name="line-6213" data-line="6213">	while ( expr &amp;&amp; set.length ) {
</a><a name="line-6214" data-line="6214">		for ( type in Expr.filter ) {
</a><a name="line-6215" data-line="6215">			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null &amp;&amp; match[2] ) {
</a><a name="line-6216" data-line="6216">				filter = Expr.filter[ type ];
</a><a name="line-6217" data-line="6217">				left = match[1];
</a><a name="line-6218" data-line="6218">
</a><a name="line-6219" data-line="6219">				anyFound = false;
</a><a name="line-6220" data-line="6220">
</a><a name="line-6221" data-line="6221">				match.splice(1,1);
</a><a name="line-6222" data-line="6222">
</a><a name="line-6223" data-line="6223">				if ( left.substr( left.length - 1 ) === &quot;\\&quot; ) {
</a><a name="line-6224" data-line="6224">					continue;
</a><a name="line-6225" data-line="6225">				}
</a><a name="line-6226" data-line="6226">
</a><a name="line-6227" data-line="6227">				if ( curLoop === result ) {
</a><a name="line-6228" data-line="6228">					result = [];
</a><a name="line-6229" data-line="6229">				}
</a><a name="line-6230" data-line="6230">
</a><a name="line-6231" data-line="6231">				if ( Expr.preFilter[ type ] ) {
</a><a name="line-6232" data-line="6232">					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );
</a><a name="line-6233" data-line="6233">
</a><a name="line-6234" data-line="6234">					if ( !match ) {
</a><a name="line-6235" data-line="6235">						anyFound = found = true;
</a><a name="line-6236" data-line="6236">
</a><a name="line-6237" data-line="6237">					} else if ( match === true ) {
</a><a name="line-6238" data-line="6238">						continue;
</a><a name="line-6239" data-line="6239">					}
</a><a name="line-6240" data-line="6240">				}
</a><a name="line-6241" data-line="6241">
</a><a name="line-6242" data-line="6242">				if ( match ) {
</a><a name="line-6243" data-line="6243">					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
</a><a name="line-6244" data-line="6244">						if ( item ) {
</a><a name="line-6245" data-line="6245">							found = filter( item, match, i, curLoop );
</a><a name="line-6246" data-line="6246">							pass = not ^ found;
</a><a name="line-6247" data-line="6247">
</a><a name="line-6248" data-line="6248">							if ( inplace &amp;&amp; found != null ) {
</a><a name="line-6249" data-line="6249">								if ( pass ) {
</a><a name="line-6250" data-line="6250">									anyFound = true;
</a><a name="line-6251" data-line="6251">
</a><a name="line-6252" data-line="6252">								} else {
</a><a name="line-6253" data-line="6253">									curLoop[i] = false;
</a><a name="line-6254" data-line="6254">								}
</a><a name="line-6255" data-line="6255">
</a><a name="line-6256" data-line="6256">							} else if ( pass ) {
</a><a name="line-6257" data-line="6257">								result.push( item );
</a><a name="line-6258" data-line="6258">								anyFound = true;
</a><a name="line-6259" data-line="6259">							}
</a><a name="line-6260" data-line="6260">						}
</a><a name="line-6261" data-line="6261">					}
</a><a name="line-6262" data-line="6262">				}
</a><a name="line-6263" data-line="6263">
</a><a name="line-6264" data-line="6264">				if ( found !== undefined ) {
</a><a name="line-6265" data-line="6265">					if ( !inplace ) {
</a><a name="line-6266" data-line="6266">						curLoop = result;
</a><a name="line-6267" data-line="6267">					}
</a><a name="line-6268" data-line="6268">
</a><a name="line-6269" data-line="6269">					expr = expr.replace( Expr.match[ type ], &quot;&quot; );
</a><a name="line-6270" data-line="6270">
</a><a name="line-6271" data-line="6271">					if ( !anyFound ) {
</a><a name="line-6272" data-line="6272">						return [];
</a><a name="line-6273" data-line="6273">					}
</a><a name="line-6274" data-line="6274">
</a><a name="line-6275" data-line="6275">					break;
</a><a name="line-6276" data-line="6276">				}
</a><a name="line-6277" data-line="6277">			}
</a><a name="line-6278" data-line="6278">		}
</a><a name="line-6279" data-line="6279">
</a><a name="line-6280" data-line="6280">		// Improper expression
</a><a name="line-6281" data-line="6281">		if ( expr === old ) {
</a><a name="line-6282" data-line="6282">			if ( anyFound == null ) {
</a><a name="line-6283" data-line="6283">				Sizzle.error( expr );
</a><a name="line-6284" data-line="6284">
</a><a name="line-6285" data-line="6285">			} else {
</a><a name="line-6286" data-line="6286">				break;
</a><a name="line-6287" data-line="6287">			}
</a><a name="line-6288" data-line="6288">		}
</a><a name="line-6289" data-line="6289">
</a><a name="line-6290" data-line="6290">		old = expr;
</a><a name="line-6291" data-line="6291">	}
</a><a name="line-6292" data-line="6292">
</a><a name="line-6293" data-line="6293">	return curLoop;
</a><a name="line-6294" data-line="6294">};
</a><a name="line-6295" data-line="6295">
</a><a name="line-6296" data-line="6296">Sizzle.error = function( msg ) {
</a><a name="line-6297" data-line="6297">	throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
</a><a name="line-6298" data-line="6298">};
</a><a name="line-6299" data-line="6299">
</a><a name="line-6300" data-line="6300">/**
</a><a name="line-6301" data-line="6301"> * Utility function for retreiving the text value of an array of DOM nodes
</a><a name="line-6302" data-line="6302"> * @param {Array|Element} elem
</a><a name="line-6303" data-line="6303"> */
</a><a name="line-6304" data-line="6304">var getText = Sizzle.getText = function( elem ) {
</a><a name="line-6305" data-line="6305">    var i, node,
</a><a name="line-6306" data-line="6306">		nodeType = elem.nodeType,
</a><a name="line-6307" data-line="6307">		ret = &quot;&quot;;
</a><a name="line-6308" data-line="6308">
</a><a name="line-6309" data-line="6309">	if ( nodeType ) {
</a><a name="line-6310" data-line="6310">		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
</a><a name="line-6311" data-line="6311">			// Use textContent || innerText for elements
</a><a name="line-6312" data-line="6312">			if ( typeof elem.textContent === 'string' ) {
</a><a name="line-6313" data-line="6313">				return elem.textContent;
</a><a name="line-6314" data-line="6314">			} else if ( typeof elem.innerText === 'string' ) {
</a><a name="line-6315" data-line="6315">				// Replace IE's carriage returns
</a><a name="line-6316" data-line="6316">				return elem.innerText.replace( rReturn, '' );
</a><a name="line-6317" data-line="6317">			} else {
</a><a name="line-6318" data-line="6318">				// Traverse it's children
</a><a name="line-6319" data-line="6319">				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
</a><a name="line-6320" data-line="6320">					ret += getText( elem );
</a><a name="line-6321" data-line="6321">				}
</a><a name="line-6322" data-line="6322">			}
</a><a name="line-6323" data-line="6323">		} else if ( nodeType === 3 || nodeType === 4 ) {
</a><a name="line-6324" data-line="6324">			return elem.nodeValue;
</a><a name="line-6325" data-line="6325">		}
</a><a name="line-6326" data-line="6326">	} else {
</a><a name="line-6327" data-line="6327">
</a><a name="line-6328" data-line="6328">		// If no nodeType, this is expected to be an array
</a><a name="line-6329" data-line="6329">		for ( i = 0; (node = elem[i]); i++ ) {
</a><a name="line-6330" data-line="6330">			// Do not traverse comment nodes
</a><a name="line-6331" data-line="6331">			if ( node.nodeType !== 8 ) {
</a><a name="line-6332" data-line="6332">				ret += getText( node );
</a><a name="line-6333" data-line="6333">			}
</a><a name="line-6334" data-line="6334">		}
</a><a name="line-6335" data-line="6335">	}
</a><a name="line-6336" data-line="6336">	return ret;
</a><a name="line-6337" data-line="6337">};
</a><a name="line-6338" data-line="6338">
</a><a name="line-6339" data-line="6339">var Expr = Sizzle.selectors = {
</a><a name="line-6340" data-line="6340">	order: [ &quot;ID&quot;, &quot;NAME&quot;, &quot;TAG&quot; ],
</a><a name="line-6341" data-line="6341">
</a><a name="line-6342" data-line="6342">	match: {
</a><a name="line-6343" data-line="6343">		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
</a><a name="line-6344" data-line="6344">		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
</a><a name="line-6345" data-line="6345">		NAME: /\[name=['&quot;]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['&quot;]*\]/,
</a><a name="line-6346" data-line="6346">		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['&quot;])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
</a><a name="line-6347" data-line="6347">		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
</a><a name="line-6348" data-line="6348">		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
</a><a name="line-6349" data-line="6349">		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
</a><a name="line-6350" data-line="6350">		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['&quot;]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
</a><a name="line-6351" data-line="6351">	},
</a><a name="line-6352" data-line="6352">
</a><a name="line-6353" data-line="6353">	leftMatch: {},
</a><a name="line-6354" data-line="6354">
</a><a name="line-6355" data-line="6355">	attrMap: {
</a><a name="line-6356" data-line="6356">		&quot;class&quot;: &quot;className&quot;,
</a><a name="line-6357" data-line="6357">		&quot;for&quot;: &quot;htmlFor&quot;
</a><a name="line-6358" data-line="6358">	},
</a><a name="line-6359" data-line="6359">
</a><a name="line-6360" data-line="6360">	attrHandle: {
</a><a name="line-6361" data-line="6361">		href: function( elem ) {
</a><a name="line-6362" data-line="6362">			return elem.getAttribute( &quot;href&quot; );
</a><a name="line-6363" data-line="6363">		},
</a><a name="line-6364" data-line="6364">		type: function( elem ) {
</a><a name="line-6365" data-line="6365">			return elem.getAttribute( &quot;type&quot; );
</a><a name="line-6366" data-line="6366">		}
</a><a name="line-6367" data-line="6367">	},
</a><a name="line-6368" data-line="6368">
</a><a name="line-6369" data-line="6369">	relative: {
</a><a name="line-6370" data-line="6370">		&quot;+&quot;: function(checkSet, part){
</a><a name="line-6371" data-line="6371">			var isPartStr = typeof part === &quot;string&quot;,
</a><a name="line-6372" data-line="6372">				isTag = isPartStr &amp;&amp; !rNonWord.test( part ),
</a><a name="line-6373" data-line="6373">				isPartStrNotTag = isPartStr &amp;&amp; !isTag;
</a><a name="line-6374" data-line="6374">
</a><a name="line-6375" data-line="6375">			if ( isTag ) {
</a><a name="line-6376" data-line="6376">				part = part.toLowerCase();
</a><a name="line-6377" data-line="6377">			}
</a><a name="line-6378" data-line="6378">
</a><a name="line-6379" data-line="6379">			for ( var i = 0, l = checkSet.length, elem; i &lt; l; i++ ) {
</a><a name="line-6380" data-line="6380">				if ( (elem = checkSet[i]) ) {
</a><a name="line-6381" data-line="6381">					while ( (elem = elem.previousSibling) &amp;&amp; elem.nodeType !== 1 ) {}
</a><a name="line-6382" data-line="6382">
</a><a name="line-6383" data-line="6383">					checkSet[i] = isPartStrNotTag || elem &amp;&amp; elem.nodeName.toLowerCase() === part ?
</a><a name="line-6384" data-line="6384">						elem || false :
</a><a name="line-6385" data-line="6385">						elem === part;
</a><a name="line-6386" data-line="6386">				}
</a><a name="line-6387" data-line="6387">			}
</a><a name="line-6388" data-line="6388">
</a><a name="line-6389" data-line="6389">			if ( isPartStrNotTag ) {
</a><a name="line-6390" data-line="6390">				Sizzle.filter( part, checkSet, true );
</a><a name="line-6391" data-line="6391">			}
</a><a name="line-6392" data-line="6392">		},
</a><a name="line-6393" data-line="6393">
</a><a name="line-6394" data-line="6394">		&quot;&gt;&quot;: function( checkSet, part ) {
</a><a name="line-6395" data-line="6395">			var elem,
</a><a name="line-6396" data-line="6396">				isPartStr = typeof part === &quot;string&quot;,
</a><a name="line-6397" data-line="6397">				i = 0,
</a><a name="line-6398" data-line="6398">				l = checkSet.length;
</a><a name="line-6399" data-line="6399">
</a><a name="line-6400" data-line="6400">			if ( isPartStr &amp;&amp; !rNonWord.test( part ) ) {
</a><a name="line-6401" data-line="6401">				part = part.toLowerCase();
</a><a name="line-6402" data-line="6402">
</a><a name="line-6403" data-line="6403">				for ( ; i &lt; l; i++ ) {
</a><a name="line-6404" data-line="6404">					elem = checkSet[i];
</a><a name="line-6405" data-line="6405">
</a><a name="line-6406" data-line="6406">					if ( elem ) {
</a><a name="line-6407" data-line="6407">						var parent = elem.parentNode;
</a><a name="line-6408" data-line="6408">						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
</a><a name="line-6409" data-line="6409">					}
</a><a name="line-6410" data-line="6410">				}
</a><a name="line-6411" data-line="6411">
</a><a name="line-6412" data-line="6412">			} else {
</a><a name="line-6413" data-line="6413">				for ( ; i &lt; l; i++ ) {
</a><a name="line-6414" data-line="6414">					elem = checkSet[i];
</a><a name="line-6415" data-line="6415">
</a><a name="line-6416" data-line="6416">					if ( elem ) {
</a><a name="line-6417" data-line="6417">						checkSet[i] = isPartStr ?
</a><a name="line-6418" data-line="6418">							elem.parentNode :
</a><a name="line-6419" data-line="6419">							elem.parentNode === part;
</a><a name="line-6420" data-line="6420">					}
</a><a name="line-6421" data-line="6421">				}
</a><a name="line-6422" data-line="6422">
</a><a name="line-6423" data-line="6423">				if ( isPartStr ) {
</a><a name="line-6424" data-line="6424">					Sizzle.filter( part, checkSet, true );
</a><a name="line-6425" data-line="6425">				}
</a><a name="line-6426" data-line="6426">			}
</a><a name="line-6427" data-line="6427">		},
</a><a name="line-6428" data-line="6428">
</a><a name="line-6429" data-line="6429">		&quot;&quot;: function(checkSet, part, isXML){
</a><a name="line-6430" data-line="6430">			var nodeCheck,
</a><a name="line-6431" data-line="6431">				doneName = done++,
</a><a name="line-6432" data-line="6432">				checkFn = dirCheck;
</a><a name="line-6433" data-line="6433">
</a><a name="line-6434" data-line="6434">			if ( typeof part === &quot;string&quot; &amp;&amp; !rNonWord.test( part ) ) {
</a><a name="line-6435" data-line="6435">				part = part.toLowerCase();
</a><a name="line-6436" data-line="6436">				nodeCheck = part;
</a><a name="line-6437" data-line="6437">				checkFn = dirNodeCheck;
</a><a name="line-6438" data-line="6438">			}
</a><a name="line-6439" data-line="6439">
</a><a name="line-6440" data-line="6440">			checkFn( &quot;parentNode&quot;, part, doneName, checkSet, nodeCheck, isXML );
</a><a name="line-6441" data-line="6441">		},
</a><a name="line-6442" data-line="6442">
</a><a name="line-6443" data-line="6443">		&quot;~&quot;: function( checkSet, part, isXML ) {
</a><a name="line-6444" data-line="6444">			var nodeCheck,
</a><a name="line-6445" data-line="6445">				doneName = done++,
</a><a name="line-6446" data-line="6446">				checkFn = dirCheck;
</a><a name="line-6447" data-line="6447">
</a><a name="line-6448" data-line="6448">			if ( typeof part === &quot;string&quot; &amp;&amp; !rNonWord.test( part ) ) {
</a><a name="line-6449" data-line="6449">				part = part.toLowerCase();
</a><a name="line-6450" data-line="6450">				nodeCheck = part;
</a><a name="line-6451" data-line="6451">				checkFn = dirNodeCheck;
</a><a name="line-6452" data-line="6452">			}
</a><a name="line-6453" data-line="6453">
</a><a name="line-6454" data-line="6454">			checkFn( &quot;previousSibling&quot;, part, doneName, checkSet, nodeCheck, isXML );
</a><a name="line-6455" data-line="6455">		}
</a><a name="line-6456" data-line="6456">	},
</a><a name="line-6457" data-line="6457">
</a><a name="line-6458" data-line="6458">	find: {
</a><a name="line-6459" data-line="6459">		ID: function( match, context, isXML ) {
</a><a name="line-6460" data-line="6460">			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; !isXML ) {
</a><a name="line-6461" data-line="6461">				var m = context.getElementById(match[1]);
</a><a name="line-6462" data-line="6462">				// Check parentNode to catch when Blackberry 4.6 returns
</a><a name="line-6463" data-line="6463">				// nodes that are no longer in the document #6963
</a><a name="line-6464" data-line="6464">				return m &amp;&amp; m.parentNode ? [m] : [];
</a><a name="line-6465" data-line="6465">			}
</a><a name="line-6466" data-line="6466">		},
</a><a name="line-6467" data-line="6467">
</a><a name="line-6468" data-line="6468">		NAME: function( match, context ) {
</a><a name="line-6469" data-line="6469">			if ( typeof context.getElementsByName !== &quot;undefined&quot; ) {
</a><a name="line-6470" data-line="6470">				var ret = [],
</a><a name="line-6471" data-line="6471">					results = context.getElementsByName( match[1] );
</a><a name="line-6472" data-line="6472">
</a><a name="line-6473" data-line="6473">				for ( var i = 0, l = results.length; i &lt; l; i++ ) {
</a><a name="line-6474" data-line="6474">					if ( results[i].getAttribute(&quot;name&quot;) === match[1] ) {
</a><a name="line-6475" data-line="6475">						ret.push( results[i] );
</a><a name="line-6476" data-line="6476">					}
</a><a name="line-6477" data-line="6477">				}
</a><a name="line-6478" data-line="6478">
</a><a name="line-6479" data-line="6479">				return ret.length === 0 ? null : ret;
</a><a name="line-6480" data-line="6480">			}
</a><a name="line-6481" data-line="6481">		},
</a><a name="line-6482" data-line="6482">
</a><a name="line-6483" data-line="6483">		TAG: function( match, context ) {
</a><a name="line-6484" data-line="6484">			if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
</a><a name="line-6485" data-line="6485">				return context.getElementsByTagName( match[1] );
</a><a name="line-6486" data-line="6486">			}
</a><a name="line-6487" data-line="6487">		}
</a><a name="line-6488" data-line="6488">	},
</a><a name="line-6489" data-line="6489">	preFilter: {
</a><a name="line-6490" data-line="6490">		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
</a><a name="line-6491" data-line="6491">			match = &quot; &quot; + match[1].replace( rBackslash, &quot;&quot; ) + &quot; &quot;;
</a><a name="line-6492" data-line="6492">
</a><a name="line-6493" data-line="6493">			if ( isXML ) {
</a><a name="line-6494" data-line="6494">				return match;
</a><a name="line-6495" data-line="6495">			}
</a><a name="line-6496" data-line="6496">
</a><a name="line-6497" data-line="6497">			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
</a><a name="line-6498" data-line="6498">				if ( elem ) {
</a><a name="line-6499" data-line="6499">					if ( not ^ (elem.className &amp;&amp; (&quot; &quot; + elem.className + &quot; &quot;).replace(/[\t\n\r]/g, &quot; &quot;).indexOf(match) &gt;= 0) ) {
</a><a name="line-6500" data-line="6500">						if ( !inplace ) {
</a><a name="line-6501" data-line="6501">							result.push( elem );
</a><a name="line-6502" data-line="6502">						}
</a><a name="line-6503" data-line="6503">
</a><a name="line-6504" data-line="6504">					} else if ( inplace ) {
</a><a name="line-6505" data-line="6505">						curLoop[i] = false;
</a><a name="line-6506" data-line="6506">					}
</a><a name="line-6507" data-line="6507">				}
</a><a name="line-6508" data-line="6508">			}
</a><a name="line-6509" data-line="6509">
</a><a name="line-6510" data-line="6510">			return false;
</a><a name="line-6511" data-line="6511">		},
</a><a name="line-6512" data-line="6512">
</a><a name="line-6513" data-line="6513">		ID: function( match ) {
</a><a name="line-6514" data-line="6514">			return match[1].replace( rBackslash, &quot;&quot; );
</a><a name="line-6515" data-line="6515">		},
</a><a name="line-6516" data-line="6516">
</a><a name="line-6517" data-line="6517">		TAG: function( match, curLoop ) {
</a><a name="line-6518" data-line="6518">			return match[1].replace( rBackslash, &quot;&quot; ).toLowerCase();
</a><a name="line-6519" data-line="6519">		},
</a><a name="line-6520" data-line="6520">
</a><a name="line-6521" data-line="6521">		CHILD: function( match ) {
</a><a name="line-6522" data-line="6522">			if ( match[1] === &quot;nth&quot; ) {
</a><a name="line-6523" data-line="6523">				if ( !match[2] ) {
</a><a name="line-6524" data-line="6524">					Sizzle.error( match[0] );
</a><a name="line-6525" data-line="6525">				}
</a><a name="line-6526" data-line="6526">
</a><a name="line-6527" data-line="6527">				match[2] = match[2].replace(/^\+|\s*/g, '');
</a><a name="line-6528" data-line="6528">
</a><a name="line-6529" data-line="6529">				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
</a><a name="line-6530" data-line="6530">				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
</a><a name="line-6531" data-line="6531">					match[2] === &quot;even&quot; &amp;&amp; &quot;2n&quot; || match[2] === &quot;odd&quot; &amp;&amp; &quot;2n+1&quot; ||
</a><a name="line-6532" data-line="6532">					!/\D/.test( match[2] ) &amp;&amp; &quot;0n+&quot; + match[2] || match[2]);
</a><a name="line-6533" data-line="6533">
</a><a name="line-6534" data-line="6534">				// calculate the numbers (first)n+(last) including if they are negative
</a><a name="line-6535" data-line="6535">				match[2] = (test[1] + (test[2] || 1)) - 0;
</a><a name="line-6536" data-line="6536">				match[3] = test[3] - 0;
</a><a name="line-6537" data-line="6537">			}
</a><a name="line-6538" data-line="6538">			else if ( match[2] ) {
</a><a name="line-6539" data-line="6539">				Sizzle.error( match[0] );
</a><a name="line-6540" data-line="6540">			}
</a><a name="line-6541" data-line="6541">
</a><a name="line-6542" data-line="6542">			// TODO: Move to normal caching system
</a><a name="line-6543" data-line="6543">			match[0] = done++;
</a><a name="line-6544" data-line="6544">
</a><a name="line-6545" data-line="6545">			return match;
</a><a name="line-6546" data-line="6546">		},
</a><a name="line-6547" data-line="6547">
</a><a name="line-6548" data-line="6548">		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
</a><a name="line-6549" data-line="6549">			var name = match[1] = match[1].replace( rBackslash, &quot;&quot; );
</a><a name="line-6550" data-line="6550">
</a><a name="line-6551" data-line="6551">			if ( !isXML &amp;&amp; Expr.attrMap[name] ) {
</a><a name="line-6552" data-line="6552">				match[1] = Expr.attrMap[name];
</a><a name="line-6553" data-line="6553">			}
</a><a name="line-6554" data-line="6554">
</a><a name="line-6555" data-line="6555">			// Handle if an un-quoted value was used
</a><a name="line-6556" data-line="6556">			match[4] = ( match[4] || match[5] || &quot;&quot; ).replace( rBackslash, &quot;&quot; );
</a><a name="line-6557" data-line="6557">
</a><a name="line-6558" data-line="6558">			if ( match[2] === &quot;~=&quot; ) {
</a><a name="line-6559" data-line="6559">				match[4] = &quot; &quot; + match[4] + &quot; &quot;;
</a><a name="line-6560" data-line="6560">			}
</a><a name="line-6561" data-line="6561">
</a><a name="line-6562" data-line="6562">			return match;
</a><a name="line-6563" data-line="6563">		},
</a><a name="line-6564" data-line="6564">
</a><a name="line-6565" data-line="6565">		PSEUDO: function( match, curLoop, inplace, result, not ) {
</a><a name="line-6566" data-line="6566">			if ( match[1] === &quot;not&quot; ) {
</a><a name="line-6567" data-line="6567">				// If we're dealing with a complex expression, or a simple one
</a><a name="line-6568" data-line="6568">				if ( ( chunker.exec(match[3]) || &quot;&quot; ).length &gt; 1 || /^\w/.test(match[3]) ) {
</a><a name="line-6569" data-line="6569">					match[3] = Sizzle(match[3], null, null, curLoop);
</a><a name="line-6570" data-line="6570">
</a><a name="line-6571" data-line="6571">				} else {
</a><a name="line-6572" data-line="6572">					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);
</a><a name="line-6573" data-line="6573">
</a><a name="line-6574" data-line="6574">					if ( !inplace ) {
</a><a name="line-6575" data-line="6575">						result.push.apply( result, ret );
</a><a name="line-6576" data-line="6576">					}
</a><a name="line-6577" data-line="6577">
</a><a name="line-6578" data-line="6578">					return false;
</a><a name="line-6579" data-line="6579">				}
</a><a name="line-6580" data-line="6580">
</a><a name="line-6581" data-line="6581">			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
</a><a name="line-6582" data-line="6582">				return true;
</a><a name="line-6583" data-line="6583">			}
</a><a name="line-6584" data-line="6584">
</a><a name="line-6585" data-line="6585">			return match;
</a><a name="line-6586" data-line="6586">		},
</a><a name="line-6587" data-line="6587">
</a><a name="line-6588" data-line="6588">		POS: function( match ) {
</a><a name="line-6589" data-line="6589">			match.unshift( true );
</a><a name="line-6590" data-line="6590">
</a><a name="line-6591" data-line="6591">			return match;
</a><a name="line-6592" data-line="6592">		}
</a><a name="line-6593" data-line="6593">	},
</a><a name="line-6594" data-line="6594">
</a><a name="line-6595" data-line="6595">	filters: {
</a><a name="line-6596" data-line="6596">		enabled: function( elem ) {
</a><a name="line-6597" data-line="6597">			return elem.disabled === false &amp;&amp; elem.type !== &quot;hidden&quot;;
</a><a name="line-6598" data-line="6598">		},
</a><a name="line-6599" data-line="6599">
</a><a name="line-6600" data-line="6600">		disabled: function( elem ) {
</a><a name="line-6601" data-line="6601">			return elem.disabled === true;
</a><a name="line-6602" data-line="6602">		},
</a><a name="line-6603" data-line="6603">
</a><a name="line-6604" data-line="6604">		checked: function( elem ) {
</a><a name="line-6605" data-line="6605">			return elem.checked === true;
</a><a name="line-6606" data-line="6606">		},
</a><a name="line-6607" data-line="6607">
</a><a name="line-6608" data-line="6608">		selected: function( elem ) {
</a><a name="line-6609" data-line="6609">			// Accessing this property makes selected-by-default
</a><a name="line-6610" data-line="6610">			// options in Safari work properly
</a><a name="line-6611" data-line="6611">			if ( elem.parentNode ) {
</a><a name="line-6612" data-line="6612">				elem.parentNode.selectedIndex;
</a><a name="line-6613" data-line="6613">			}
</a><a name="line-6614" data-line="6614">
</a><a name="line-6615" data-line="6615">			return elem.selected === true;
</a><a name="line-6616" data-line="6616">		},
</a><a name="line-6617" data-line="6617">
</a><a name="line-6618" data-line="6618">		parent: function( elem ) {
</a><a name="line-6619" data-line="6619">			return !!elem.firstChild;
</a><a name="line-6620" data-line="6620">		},
</a><a name="line-6621" data-line="6621">
</a><a name="line-6622" data-line="6622">		empty: function( elem ) {
</a><a name="line-6623" data-line="6623">			return !elem.firstChild;
</a><a name="line-6624" data-line="6624">		},
</a><a name="line-6625" data-line="6625">
</a><a name="line-6626" data-line="6626">		has: function( elem, i, match ) {
</a><a name="line-6627" data-line="6627">			return !!Sizzle( match[3], elem ).length;
</a><a name="line-6628" data-line="6628">		},
</a><a name="line-6629" data-line="6629">
</a><a name="line-6630" data-line="6630">		header: function( elem ) {
</a><a name="line-6631" data-line="6631">			return (/h\d/i).test( elem.nodeName );
</a><a name="line-6632" data-line="6632">		},
</a><a name="line-6633" data-line="6633">
</a><a name="line-6634" data-line="6634">		text: function( elem ) {
</a><a name="line-6635" data-line="6635">			var attr = elem.getAttribute( &quot;type&quot; ), type = elem.type;
</a><a name="line-6636" data-line="6636">			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
</a><a name="line-6637" data-line="6637">			// use getAttribute instead to test this case
</a><a name="line-6638" data-line="6638">			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp; &quot;text&quot; === type &amp;&amp; ( attr === type || attr === null );
</a><a name="line-6639" data-line="6639">		},
</a><a name="line-6640" data-line="6640">
</a><a name="line-6641" data-line="6641">		radio: function( elem ) {
</a><a name="line-6642" data-line="6642">			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp; &quot;radio&quot; === elem.type;
</a><a name="line-6643" data-line="6643">		},
</a><a name="line-6644" data-line="6644">
</a><a name="line-6645" data-line="6645">		checkbox: function( elem ) {
</a><a name="line-6646" data-line="6646">			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp; &quot;checkbox&quot; === elem.type;
</a><a name="line-6647" data-line="6647">		},
</a><a name="line-6648" data-line="6648">
</a><a name="line-6649" data-line="6649">		file: function( elem ) {
</a><a name="line-6650" data-line="6650">			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp; &quot;file&quot; === elem.type;
</a><a name="line-6651" data-line="6651">		},
</a><a name="line-6652" data-line="6652">
</a><a name="line-6653" data-line="6653">		password: function( elem ) {
</a><a name="line-6654" data-line="6654">			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp; &quot;password&quot; === elem.type;
</a><a name="line-6655" data-line="6655">		},
</a><a name="line-6656" data-line="6656">
</a><a name="line-6657" data-line="6657">		submit: function( elem ) {
</a><a name="line-6658" data-line="6658">			var name = elem.nodeName.toLowerCase();
</a><a name="line-6659" data-line="6659">			return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; &quot;submit&quot; === elem.type;
</a><a name="line-6660" data-line="6660">		},
</a><a name="line-6661" data-line="6661">
</a><a name="line-6662" data-line="6662">		image: function( elem ) {
</a><a name="line-6663" data-line="6663">			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp; &quot;image&quot; === elem.type;
</a><a name="line-6664" data-line="6664">		},
</a><a name="line-6665" data-line="6665">
</a><a name="line-6666" data-line="6666">		reset: function( elem ) {
</a><a name="line-6667" data-line="6667">			var name = elem.nodeName.toLowerCase();
</a><a name="line-6668" data-line="6668">			return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; &quot;reset&quot; === elem.type;
</a><a name="line-6669" data-line="6669">		},
</a><a name="line-6670" data-line="6670">
</a><a name="line-6671" data-line="6671">		button: function( elem ) {
</a><a name="line-6672" data-line="6672">			var name = elem.nodeName.toLowerCase();
</a><a name="line-6673" data-line="6673">			return name === &quot;input&quot; &amp;&amp; &quot;button&quot; === elem.type || name === &quot;button&quot;;
</a><a name="line-6674" data-line="6674">		},
</a><a name="line-6675" data-line="6675">
</a><a name="line-6676" data-line="6676">		input: function( elem ) {
</a><a name="line-6677" data-line="6677">			return (/input|select|textarea|button/i).test( elem.nodeName );
</a><a name="line-6678" data-line="6678">		},
</a><a name="line-6679" data-line="6679">
</a><a name="line-6680" data-line="6680">		focus: function( elem ) {
</a><a name="line-6681" data-line="6681">			return elem === elem.ownerDocument.activeElement;
</a><a name="line-6682" data-line="6682">		}
</a><a name="line-6683" data-line="6683">	},
</a><a name="line-6684" data-line="6684">	setFilters: {
</a><a name="line-6685" data-line="6685">		first: function( elem, i ) {
</a><a name="line-6686" data-line="6686">			return i === 0;
</a><a name="line-6687" data-line="6687">		},
</a><a name="line-6688" data-line="6688">
</a><a name="line-6689" data-line="6689">		last: function( elem, i, match, array ) {
</a><a name="line-6690" data-line="6690">			return i === array.length - 1;
</a><a name="line-6691" data-line="6691">		},
</a><a name="line-6692" data-line="6692">
</a><a name="line-6693" data-line="6693">		even: function( elem, i ) {
</a><a name="line-6694" data-line="6694">			return i % 2 === 0;
</a><a name="line-6695" data-line="6695">		},
</a><a name="line-6696" data-line="6696">
</a><a name="line-6697" data-line="6697">		odd: function( elem, i ) {
</a><a name="line-6698" data-line="6698">			return i % 2 === 1;
</a><a name="line-6699" data-line="6699">		},
</a><a name="line-6700" data-line="6700">
</a><a name="line-6701" data-line="6701">		lt: function( elem, i, match ) {
</a><a name="line-6702" data-line="6702">			return i &lt; match[3] - 0;
</a><a name="line-6703" data-line="6703">		},
</a><a name="line-6704" data-line="6704">
</a><a name="line-6705" data-line="6705">		gt: function( elem, i, match ) {
</a><a name="line-6706" data-line="6706">			return i &gt; match[3] - 0;
</a><a name="line-6707" data-line="6707">		},
</a><a name="line-6708" data-line="6708">
</a><a name="line-6709" data-line="6709">		nth: function( elem, i, match ) {
</a><a name="line-6710" data-line="6710">			return match[3] - 0 === i;
</a><a name="line-6711" data-line="6711">		},
</a><a name="line-6712" data-line="6712">
</a><a name="line-6713" data-line="6713">		eq: function( elem, i, match ) {
</a><a name="line-6714" data-line="6714">			return match[3] - 0 === i;
</a><a name="line-6715" data-line="6715">		}
</a><a name="line-6716" data-line="6716">	},
</a><a name="line-6717" data-line="6717">	filter: {
</a><a name="line-6718" data-line="6718">		PSEUDO: function( elem, match, i, array ) {
</a><a name="line-6719" data-line="6719">			var name = match[1],
</a><a name="line-6720" data-line="6720">				filter = Expr.filters[ name ];
</a><a name="line-6721" data-line="6721">
</a><a name="line-6722" data-line="6722">			if ( filter ) {
</a><a name="line-6723" data-line="6723">				return filter( elem, i, match, array );
</a><a name="line-6724" data-line="6724">
</a><a name="line-6725" data-line="6725">			} else if ( name === &quot;contains&quot; ) {
</a><a name="line-6726" data-line="6726">				return (elem.textContent || elem.innerText || getText([ elem ]) || &quot;&quot;).indexOf(match[3]) &gt;= 0;
</a><a name="line-6727" data-line="6727">
</a><a name="line-6728" data-line="6728">			} else if ( name === &quot;not&quot; ) {
</a><a name="line-6729" data-line="6729">				var not = match[3];
</a><a name="line-6730" data-line="6730">
</a><a name="line-6731" data-line="6731">				for ( var j = 0, l = not.length; j &lt; l; j++ ) {
</a><a name="line-6732" data-line="6732">					if ( not[j] === elem ) {
</a><a name="line-6733" data-line="6733">						return false;
</a><a name="line-6734" data-line="6734">					}
</a><a name="line-6735" data-line="6735">				}
</a><a name="line-6736" data-line="6736">
</a><a name="line-6737" data-line="6737">				return true;
</a><a name="line-6738" data-line="6738">
</a><a name="line-6739" data-line="6739">			} else {
</a><a name="line-6740" data-line="6740">				Sizzle.error( name );
</a><a name="line-6741" data-line="6741">			}
</a><a name="line-6742" data-line="6742">		},
</a><a name="line-6743" data-line="6743">
</a><a name="line-6744" data-line="6744">		CHILD: function( elem, match ) {
</a><a name="line-6745" data-line="6745">			var first, last,
</a><a name="line-6746" data-line="6746">				doneName, parent, cache,
</a><a name="line-6747" data-line="6747">				count, diff,
</a><a name="line-6748" data-line="6748">				type = match[1],
</a><a name="line-6749" data-line="6749">				node = elem;
</a><a name="line-6750" data-line="6750">
</a><a name="line-6751" data-line="6751">			switch ( type ) {
</a><a name="line-6752" data-line="6752">				case &quot;only&quot;:
</a><a name="line-6753" data-line="6753">				case &quot;first&quot;:
</a><a name="line-6754" data-line="6754">					while ( (node = node.previousSibling) ) {
</a><a name="line-6755" data-line="6755">						if ( node.nodeType === 1 ) {
</a><a name="line-6756" data-line="6756">							return false;
</a><a name="line-6757" data-line="6757">						}
</a><a name="line-6758" data-line="6758">					}
</a><a name="line-6759" data-line="6759">
</a><a name="line-6760" data-line="6760">					if ( type === &quot;first&quot; ) {
</a><a name="line-6761" data-line="6761">						return true;
</a><a name="line-6762" data-line="6762">					}
</a><a name="line-6763" data-line="6763">
</a><a name="line-6764" data-line="6764">					node = elem;
</a><a name="line-6765" data-line="6765">
</a><a name="line-6766" data-line="6766">					/* falls through */
</a><a name="line-6767" data-line="6767">				case &quot;last&quot;:
</a><a name="line-6768" data-line="6768">					while ( (node = node.nextSibling) ) {
</a><a name="line-6769" data-line="6769">						if ( node.nodeType === 1 ) {
</a><a name="line-6770" data-line="6770">							return false;
</a><a name="line-6771" data-line="6771">						}
</a><a name="line-6772" data-line="6772">					}
</a><a name="line-6773" data-line="6773">
</a><a name="line-6774" data-line="6774">					return true;
</a><a name="line-6775" data-line="6775">
</a><a name="line-6776" data-line="6776">				case &quot;nth&quot;:
</a><a name="line-6777" data-line="6777">					first = match[2];
</a><a name="line-6778" data-line="6778">					last = match[3];
</a><a name="line-6779" data-line="6779">
</a><a name="line-6780" data-line="6780">					if ( first === 1 &amp;&amp; last === 0 ) {
</a><a name="line-6781" data-line="6781">						return true;
</a><a name="line-6782" data-line="6782">					}
</a><a name="line-6783" data-line="6783">
</a><a name="line-6784" data-line="6784">					doneName = match[0];
</a><a name="line-6785" data-line="6785">					parent = elem.parentNode;
</a><a name="line-6786" data-line="6786">
</a><a name="line-6787" data-line="6787">					if ( parent &amp;&amp; (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
</a><a name="line-6788" data-line="6788">						count = 0;
</a><a name="line-6789" data-line="6789">
</a><a name="line-6790" data-line="6790">						for ( node = parent.firstChild; node; node = node.nextSibling ) {
</a><a name="line-6791" data-line="6791">							if ( node.nodeType === 1 ) {
</a><a name="line-6792" data-line="6792">								node.nodeIndex = ++count;
</a><a name="line-6793" data-line="6793">							}
</a><a name="line-6794" data-line="6794">						}
</a><a name="line-6795" data-line="6795">
</a><a name="line-6796" data-line="6796">						parent[ expando ] = doneName;
</a><a name="line-6797" data-line="6797">					}
</a><a name="line-6798" data-line="6798">
</a><a name="line-6799" data-line="6799">					diff = elem.nodeIndex - last;
</a><a name="line-6800" data-line="6800">
</a><a name="line-6801" data-line="6801">					if ( first === 0 ) {
</a><a name="line-6802" data-line="6802">						return diff === 0;
</a><a name="line-6803" data-line="6803">
</a><a name="line-6804" data-line="6804">					} else {
</a><a name="line-6805" data-line="6805">						return ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
</a><a name="line-6806" data-line="6806">					}
</a><a name="line-6807" data-line="6807">			}
</a><a name="line-6808" data-line="6808">		},
</a><a name="line-6809" data-line="6809">
</a><a name="line-6810" data-line="6810">		ID: function( elem, match ) {
</a><a name="line-6811" data-line="6811">			return elem.nodeType === 1 &amp;&amp; elem.getAttribute(&quot;id&quot;) === match;
</a><a name="line-6812" data-line="6812">		},
</a><a name="line-6813" data-line="6813">
</a><a name="line-6814" data-line="6814">		TAG: function( elem, match ) {
</a><a name="line-6815" data-line="6815">			return (match === &quot;*&quot; &amp;&amp; elem.nodeType === 1) || !!elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === match;
</a><a name="line-6816" data-line="6816">		},
</a><a name="line-6817" data-line="6817">
</a><a name="line-6818" data-line="6818">		CLASS: function( elem, match ) {
</a><a name="line-6819" data-line="6819">			return (&quot; &quot; + (elem.className || elem.getAttribute(&quot;class&quot;)) + &quot; &quot;)
</a><a name="line-6820" data-line="6820">				.indexOf( match ) &gt; -1;
</a><a name="line-6821" data-line="6821">		},
</a><a name="line-6822" data-line="6822">
</a><a name="line-6823" data-line="6823">		ATTR: function( elem, match ) {
</a><a name="line-6824" data-line="6824">			var name = match[1],
</a><a name="line-6825" data-line="6825">				result = Sizzle.attr ?
</a><a name="line-6826" data-line="6826">					Sizzle.attr( elem, name ) :
</a><a name="line-6827" data-line="6827">					Expr.attrHandle[ name ] ?
</a><a name="line-6828" data-line="6828">					Expr.attrHandle[ name ]( elem ) :
</a><a name="line-6829" data-line="6829">					elem[ name ] != null ?
</a><a name="line-6830" data-line="6830">						elem[ name ] :
</a><a name="line-6831" data-line="6831">						elem.getAttribute( name ),
</a><a name="line-6832" data-line="6832">				value = result + &quot;&quot;,
</a><a name="line-6833" data-line="6833">				type = match[2],
</a><a name="line-6834" data-line="6834">				check = match[4];
</a><a name="line-6835" data-line="6835">
</a><a name="line-6836" data-line="6836">			return result == null ?
</a><a name="line-6837" data-line="6837">				type === &quot;!=&quot; :
</a><a name="line-6838" data-line="6838">				!type &amp;&amp; Sizzle.attr ?
</a><a name="line-6839" data-line="6839">				result != null :
</a><a name="line-6840" data-line="6840">				type === &quot;=&quot; ?
</a><a name="line-6841" data-line="6841">				value === check :
</a><a name="line-6842" data-line="6842">				type === &quot;*=&quot; ?
</a><a name="line-6843" data-line="6843">				value.indexOf(check) &gt;= 0 :
</a><a name="line-6844" data-line="6844">				type === &quot;~=&quot; ?
</a><a name="line-6845" data-line="6845">				(&quot; &quot; + value + &quot; &quot;).indexOf(check) &gt;= 0 :
</a><a name="line-6846" data-line="6846">				!check ?
</a><a name="line-6847" data-line="6847">				value &amp;&amp; result !== false :
</a><a name="line-6848" data-line="6848">				type === &quot;!=&quot; ?
</a><a name="line-6849" data-line="6849">				value !== check :
</a><a name="line-6850" data-line="6850">				type === &quot;^=&quot; ?
</a><a name="line-6851" data-line="6851">				value.indexOf(check) === 0 :
</a><a name="line-6852" data-line="6852">				type === &quot;$=&quot; ?
</a><a name="line-6853" data-line="6853">				value.substr(value.length - check.length) === check :
</a><a name="line-6854" data-line="6854">				type === &quot;|=&quot; ?
</a><a name="line-6855" data-line="6855">				value === check || value.substr(0, check.length + 1) === check + &quot;-&quot; :
</a><a name="line-6856" data-line="6856">				false;
</a><a name="line-6857" data-line="6857">		},
</a><a name="line-6858" data-line="6858">
</a><a name="line-6859" data-line="6859">		POS: function( elem, match, i, array ) {
</a><a name="line-6860" data-line="6860">			var name = match[2],
</a><a name="line-6861" data-line="6861">				filter = Expr.setFilters[ name ];
</a><a name="line-6862" data-line="6862">
</a><a name="line-6863" data-line="6863">			if ( filter ) {
</a><a name="line-6864" data-line="6864">				return filter( elem, i, match, array );
</a><a name="line-6865" data-line="6865">			}
</a><a name="line-6866" data-line="6866">		}
</a><a name="line-6867" data-line="6867">	}
</a><a name="line-6868" data-line="6868">};
</a><a name="line-6869" data-line="6869">
</a><a name="line-6870" data-line="6870">var origPOS = Expr.match.POS,
</a><a name="line-6871" data-line="6871">	fescape = function(all, num){
</a><a name="line-6872" data-line="6872">		return &quot;\\&quot; + (num - 0 + 1);
</a><a name="line-6873" data-line="6873">	};
</a><a name="line-6874" data-line="6874">
</a><a name="line-6875" data-line="6875">for ( var type in Expr.match ) {
</a><a name="line-6876" data-line="6876">	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
</a><a name="line-6877" data-line="6877">	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
</a><a name="line-6878" data-line="6878">}
</a><a name="line-6879" data-line="6879">// Expose origPOS
</a><a name="line-6880" data-line="6880">// &quot;global&quot; as in regardless of relation to brackets/parens
</a><a name="line-6881" data-line="6881">Expr.match.globalPOS = origPOS;
</a><a name="line-6882" data-line="6882">
</a><a name="line-6883" data-line="6883">var makeArray = function( array, results ) {
</a><a name="line-6884" data-line="6884">	array = Array.prototype.slice.call( array, 0 );
</a><a name="line-6885" data-line="6885">
</a><a name="line-6886" data-line="6886">	if ( results ) {
</a><a name="line-6887" data-line="6887">		results.push.apply( results, array );
</a><a name="line-6888" data-line="6888">		return results;
</a><a name="line-6889" data-line="6889">	}
</a><a name="line-6890" data-line="6890">
</a><a name="line-6891" data-line="6891">	return array;
</a><a name="line-6892" data-line="6892">};
</a><a name="line-6893" data-line="6893">
</a><a name="line-6894" data-line="6894">// Perform a simple check to determine if the browser is capable of
</a><a name="line-6895" data-line="6895">// converting a NodeList to an array using builtin methods.
</a><a name="line-6896" data-line="6896">// Also verifies that the returned array holds DOM nodes
</a><a name="line-6897" data-line="6897">// (which is not the case in the Blackberry browser)
</a><a name="line-6898" data-line="6898">try {
</a><a name="line-6899" data-line="6899">	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;
</a><a name="line-6900" data-line="6900">
</a><a name="line-6901" data-line="6901">// Provide a fallback method if it does not work
</a><a name="line-6902" data-line="6902">} catch( e ) {
</a><a name="line-6903" data-line="6903">	makeArray = function( array, results ) {
</a><a name="line-6904" data-line="6904">		var i = 0,
</a><a name="line-6905" data-line="6905">			ret = results || [];
</a><a name="line-6906" data-line="6906">
</a><a name="line-6907" data-line="6907">		if ( toString.call(array) === &quot;[object Array]&quot; ) {
</a><a name="line-6908" data-line="6908">			Array.prototype.push.apply( ret, array );
</a><a name="line-6909" data-line="6909">
</a><a name="line-6910" data-line="6910">		} else {
</a><a name="line-6911" data-line="6911">			if ( typeof array.length === &quot;number&quot; ) {
</a><a name="line-6912" data-line="6912">				for ( var l = array.length; i &lt; l; i++ ) {
</a><a name="line-6913" data-line="6913">					ret.push( array[i] );
</a><a name="line-6914" data-line="6914">				}
</a><a name="line-6915" data-line="6915">
</a><a name="line-6916" data-line="6916">			} else {
</a><a name="line-6917" data-line="6917">				for ( ; array[i]; i++ ) {
</a><a name="line-6918" data-line="6918">					ret.push( array[i] );
</a><a name="line-6919" data-line="6919">				}
</a><a name="line-6920" data-line="6920">			}
</a><a name="line-6921" data-line="6921">		}
</a><a name="line-6922" data-line="6922">
</a><a name="line-6923" data-line="6923">		return ret;
</a><a name="line-6924" data-line="6924">	};
</a><a name="line-6925" data-line="6925">}
</a><a name="line-6926" data-line="6926">
</a><a name="line-6927" data-line="6927">var sortOrder, siblingCheck;
</a><a name="line-6928" data-line="6928">
</a><a name="line-6929" data-line="6929">if ( document.documentElement.compareDocumentPosition ) {
</a><a name="line-6930" data-line="6930">	sortOrder = function( a, b ) {
</a><a name="line-6931" data-line="6931">		if ( a === b ) {
</a><a name="line-6932" data-line="6932">			hasDuplicate = true;
</a><a name="line-6933" data-line="6933">			return 0;
</a><a name="line-6934" data-line="6934">		}
</a><a name="line-6935" data-line="6935">
</a><a name="line-6936" data-line="6936">		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
</a><a name="line-6937" data-line="6937">			return a.compareDocumentPosition ? -1 : 1;
</a><a name="line-6938" data-line="6938">		}
</a><a name="line-6939" data-line="6939">
</a><a name="line-6940" data-line="6940">		return a.compareDocumentPosition(b) &amp; 4 ? -1 : 1;
</a><a name="line-6941" data-line="6941">	};
</a><a name="line-6942" data-line="6942">
</a><a name="line-6943" data-line="6943">} else {
</a><a name="line-6944" data-line="6944">	sortOrder = function( a, b ) {
</a><a name="line-6945" data-line="6945">		// The nodes are identical, we can exit early
</a><a name="line-6946" data-line="6946">		if ( a === b ) {
</a><a name="line-6947" data-line="6947">			hasDuplicate = true;
</a><a name="line-6948" data-line="6948">			return 0;
</a><a name="line-6949" data-line="6949">
</a><a name="line-6950" data-line="6950">		// Fallback to using sourceIndex (in IE) if it's available on both nodes
</a><a name="line-6951" data-line="6951">		} else if ( a.sourceIndex &amp;&amp; b.sourceIndex ) {
</a><a name="line-6952" data-line="6952">			return a.sourceIndex - b.sourceIndex;
</a><a name="line-6953" data-line="6953">		}
</a><a name="line-6954" data-line="6954">
</a><a name="line-6955" data-line="6955">		var al, bl,
</a><a name="line-6956" data-line="6956">			ap = [],
</a><a name="line-6957" data-line="6957">			bp = [],
</a><a name="line-6958" data-line="6958">			aup = a.parentNode,
</a><a name="line-6959" data-line="6959">			bup = b.parentNode,
</a><a name="line-6960" data-line="6960">			cur = aup;
</a><a name="line-6961" data-line="6961">
</a><a name="line-6962" data-line="6962">		// If the nodes are siblings (or identical) we can do a quick check
</a><a name="line-6963" data-line="6963">		if ( aup === bup ) {
</a><a name="line-6964" data-line="6964">			return siblingCheck( a, b );
</a><a name="line-6965" data-line="6965">
</a><a name="line-6966" data-line="6966">		// If no parents were found then the nodes are disconnected
</a><a name="line-6967" data-line="6967">		} else if ( !aup ) {
</a><a name="line-6968" data-line="6968">			return -1;
</a><a name="line-6969" data-line="6969">
</a><a name="line-6970" data-line="6970">		} else if ( !bup ) {
</a><a name="line-6971" data-line="6971">			return 1;
</a><a name="line-6972" data-line="6972">		}
</a><a name="line-6973" data-line="6973">
</a><a name="line-6974" data-line="6974">		// Otherwise they're somewhere else in the tree so we need
</a><a name="line-6975" data-line="6975">		// to build up a full list of the parentNodes for comparison
</a><a name="line-6976" data-line="6976">		while ( cur ) {
</a><a name="line-6977" data-line="6977">			ap.unshift( cur );
</a><a name="line-6978" data-line="6978">			cur = cur.parentNode;
</a><a name="line-6979" data-line="6979">		}
</a><a name="line-6980" data-line="6980">
</a><a name="line-6981" data-line="6981">		cur = bup;
</a><a name="line-6982" data-line="6982">
</a><a name="line-6983" data-line="6983">		while ( cur ) {
</a><a name="line-6984" data-line="6984">			bp.unshift( cur );
</a><a name="line-6985" data-line="6985">			cur = cur.parentNode;
</a><a name="line-6986" data-line="6986">		}
</a><a name="line-6987" data-line="6987">
</a><a name="line-6988" data-line="6988">		al = ap.length;
</a><a name="line-6989" data-line="6989">		bl = bp.length;
</a><a name="line-6990" data-line="6990">
</a><a name="line-6991" data-line="6991">		// Start walking down the tree looking for a discrepancy
</a><a name="line-6992" data-line="6992">		for ( var i = 0; i &lt; al &amp;&amp; i &lt; bl; i++ ) {
</a><a name="line-6993" data-line="6993">			if ( ap[i] !== bp[i] ) {
</a><a name="line-6994" data-line="6994">				return siblingCheck( ap[i], bp[i] );
</a><a name="line-6995" data-line="6995">			}
</a><a name="line-6996" data-line="6996">		}
</a><a name="line-6997" data-line="6997">
</a><a name="line-6998" data-line="6998">		// We ended someplace up the tree so do a sibling check
</a><a name="line-6999" data-line="6999">		return i === al ?
</a><a name="line-7000" data-line="7000">			siblingCheck( a, bp[i], -1 ) :
</a><a name="line-7001" data-line="7001">			siblingCheck( ap[i], b, 1 );
</a><a name="line-7002" data-line="7002">	};
</a><a name="line-7003" data-line="7003">
</a><a name="line-7004" data-line="7004">	siblingCheck = function( a, b, ret ) {
</a><a name="line-7005" data-line="7005">		if ( a === b ) {
</a><a name="line-7006" data-line="7006">			return ret;
</a><a name="line-7007" data-line="7007">		}
</a><a name="line-7008" data-line="7008">
</a><a name="line-7009" data-line="7009">		var cur = a.nextSibling;
</a><a name="line-7010" data-line="7010">
</a><a name="line-7011" data-line="7011">		while ( cur ) {
</a><a name="line-7012" data-line="7012">			if ( cur === b ) {
</a><a name="line-7013" data-line="7013">				return -1;
</a><a name="line-7014" data-line="7014">			}
</a><a name="line-7015" data-line="7015">
</a><a name="line-7016" data-line="7016">			cur = cur.nextSibling;
</a><a name="line-7017" data-line="7017">		}
</a><a name="line-7018" data-line="7018">
</a><a name="line-7019" data-line="7019">		return 1;
</a><a name="line-7020" data-line="7020">	};
</a><a name="line-7021" data-line="7021">}
</a><a name="line-7022" data-line="7022">
</a><a name="line-7023" data-line="7023">// Check to see if the browser returns elements by name when
</a><a name="line-7024" data-line="7024">// querying by getElementById (and provide a workaround)
</a><a name="line-7025" data-line="7025">(function(){
</a><a name="line-7026" data-line="7026">	// We're going to inject a fake input element with a specified name
</a><a name="line-7027" data-line="7027">	var form = document.createElement(&quot;div&quot;),
</a><a name="line-7028" data-line="7028">		id = &quot;script&quot; + (new Date()).getTime(),
</a><a name="line-7029" data-line="7029">		root = document.documentElement;
</a><a name="line-7030" data-line="7030">
</a><a name="line-7031" data-line="7031">	form.innerHTML = &quot;&lt;a name='&quot; + id + &quot;'/&gt;&quot;;
</a><a name="line-7032" data-line="7032">
</a><a name="line-7033" data-line="7033">	// Inject it into the root element, check its status, and remove it quickly
</a><a name="line-7034" data-line="7034">	root.insertBefore( form, root.firstChild );
</a><a name="line-7035" data-line="7035">
</a><a name="line-7036" data-line="7036">	// The workaround has to do additional checks after a getElementById
</a><a name="line-7037" data-line="7037">	// Which slows things down for other browsers (hence the branching)
</a><a name="line-7038" data-line="7038">	if ( document.getElementById( id ) ) {
</a><a name="line-7039" data-line="7039">		Expr.find.ID = function( match, context, isXML ) {
</a><a name="line-7040" data-line="7040">			if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; !isXML ) {
</a><a name="line-7041" data-line="7041">				var m = context.getElementById(match[1]);
</a><a name="line-7042" data-line="7042">
</a><a name="line-7043" data-line="7043">				return m ?
</a><a name="line-7044" data-line="7044">					m.id === match[1] || typeof m.getAttributeNode !== &quot;undefined&quot; &amp;&amp; m.getAttributeNode(&quot;id&quot;).nodeValue === match[1] ?
</a><a name="line-7045" data-line="7045">						[m] :
</a><a name="line-7046" data-line="7046">						undefined :
</a><a name="line-7047" data-line="7047">					[];
</a><a name="line-7048" data-line="7048">			}
</a><a name="line-7049" data-line="7049">		};
</a><a name="line-7050" data-line="7050">
</a><a name="line-7051" data-line="7051">		Expr.filter.ID = function( elem, match ) {
</a><a name="line-7052" data-line="7052">			var node = typeof elem.getAttributeNode !== &quot;undefined&quot; &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
</a><a name="line-7053" data-line="7053">
</a><a name="line-7054" data-line="7054">			return elem.nodeType === 1 &amp;&amp; node &amp;&amp; node.nodeValue === match;
</a><a name="line-7055" data-line="7055">		};
</a><a name="line-7056" data-line="7056">	}
</a><a name="line-7057" data-line="7057">
</a><a name="line-7058" data-line="7058">	root.removeChild( form );
</a><a name="line-7059" data-line="7059">
</a><a name="line-7060" data-line="7060">	// release memory in IE
</a><a name="line-7061" data-line="7061">	root = form = null;
</a><a name="line-7062" data-line="7062">})();
</a><a name="line-7063" data-line="7063">
</a><a name="line-7064" data-line="7064">(function(){
</a><a name="line-7065" data-line="7065">	// Check to see if the browser returns only elements
</a><a name="line-7066" data-line="7066">	// when doing getElementsByTagName(&quot;*&quot;)
</a><a name="line-7067" data-line="7067">
</a><a name="line-7068" data-line="7068">	// Create a fake element
</a><a name="line-7069" data-line="7069">	var div = document.createElement(&quot;div&quot;);
</a><a name="line-7070" data-line="7070">	div.appendChild( document.createComment(&quot;&quot;) );
</a><a name="line-7071" data-line="7071">
</a><a name="line-7072" data-line="7072">	// Make sure no comments are found
</a><a name="line-7073" data-line="7073">	if ( div.getElementsByTagName(&quot;*&quot;).length &gt; 0 ) {
</a><a name="line-7074" data-line="7074">		Expr.find.TAG = function( match, context ) {
</a><a name="line-7075" data-line="7075">			var results = context.getElementsByTagName( match[1] );
</a><a name="line-7076" data-line="7076">
</a><a name="line-7077" data-line="7077">			// Filter out possible comments
</a><a name="line-7078" data-line="7078">			if ( match[1] === &quot;*&quot; ) {
</a><a name="line-7079" data-line="7079">				var tmp = [];
</a><a name="line-7080" data-line="7080">
</a><a name="line-7081" data-line="7081">				for ( var i = 0; results[i]; i++ ) {
</a><a name="line-7082" data-line="7082">					if ( results[i].nodeType === 1 ) {
</a><a name="line-7083" data-line="7083">						tmp.push( results[i] );
</a><a name="line-7084" data-line="7084">					}
</a><a name="line-7085" data-line="7085">				}
</a><a name="line-7086" data-line="7086">
</a><a name="line-7087" data-line="7087">				results = tmp;
</a><a name="line-7088" data-line="7088">			}
</a><a name="line-7089" data-line="7089">
</a><a name="line-7090" data-line="7090">			return results;
</a><a name="line-7091" data-line="7091">		};
</a><a name="line-7092" data-line="7092">	}
</a><a name="line-7093" data-line="7093">
</a><a name="line-7094" data-line="7094">	// Check to see if an attribute returns normalized href attributes
</a><a name="line-7095" data-line="7095">	div.innerHTML = &quot;&lt;a href='#'&gt;&lt;/a&gt;&quot;;
</a><a name="line-7096" data-line="7096">
</a><a name="line-7097" data-line="7097">	if ( div.firstChild &amp;&amp; typeof div.firstChild.getAttribute !== &quot;undefined&quot; &amp;&amp;
</a><a name="line-7098" data-line="7098">			div.firstChild.getAttribute(&quot;href&quot;) !== &quot;#&quot; ) {
</a><a name="line-7099" data-line="7099">
</a><a name="line-7100" data-line="7100">		Expr.attrHandle.href = function( elem ) {
</a><a name="line-7101" data-line="7101">			return elem.getAttribute( &quot;href&quot;, 2 );
</a><a name="line-7102" data-line="7102">		};
</a><a name="line-7103" data-line="7103">	}
</a><a name="line-7104" data-line="7104">
</a><a name="line-7105" data-line="7105">	// release memory in IE
</a><a name="line-7106" data-line="7106">	div = null;
</a><a name="line-7107" data-line="7107">})();
</a><a name="line-7108" data-line="7108">
</a><a name="line-7109" data-line="7109">if ( document.querySelectorAll ) {
</a><a name="line-7110" data-line="7110">	(function(){
</a><a name="line-7111" data-line="7111">		var oldSizzle = Sizzle,
</a><a name="line-7112" data-line="7112">			div = document.createElement(&quot;div&quot;),
</a><a name="line-7113" data-line="7113">			id = &quot;__sizzle__&quot;;
</a><a name="line-7114" data-line="7114">
</a><a name="line-7115" data-line="7115">		div.innerHTML = &quot;&lt;p class='TEST'&gt;&lt;/p&gt;&quot;;
</a><a name="line-7116" data-line="7116">
</a><a name="line-7117" data-line="7117">		// Safari can't handle uppercase or unicode characters when
</a><a name="line-7118" data-line="7118">		// in quirks mode.
</a><a name="line-7119" data-line="7119">		if ( div.querySelectorAll &amp;&amp; div.querySelectorAll(&quot;.TEST&quot;).length === 0 ) {
</a><a name="line-7120" data-line="7120">			return;
</a><a name="line-7121" data-line="7121">		}
</a><a name="line-7122" data-line="7122">
</a><a name="line-7123" data-line="7123">		Sizzle = function( query, context, extra, seed ) {
</a><a name="line-7124" data-line="7124">			context = context || document;
</a><a name="line-7125" data-line="7125">
</a><a name="line-7126" data-line="7126">			// Only use querySelectorAll on non-XML documents
</a><a name="line-7127" data-line="7127">			// (ID selectors don't work in non-HTML documents)
</a><a name="line-7128" data-line="7128">			if ( !seed &amp;&amp; !Sizzle.isXML(context) ) {
</a><a name="line-7129" data-line="7129">				// See if we find a selector to speed up
</a><a name="line-7130" data-line="7130">				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
</a><a name="line-7131" data-line="7131">
</a><a name="line-7132" data-line="7132">				if ( match &amp;&amp; (context.nodeType === 1 || context.nodeType === 9) ) {
</a><a name="line-7133" data-line="7133">					// Speed-up: Sizzle(&quot;TAG&quot;)
</a><a name="line-7134" data-line="7134">					if ( match[1] ) {
</a><a name="line-7135" data-line="7135">						return makeArray( context.getElementsByTagName( query ), extra );
</a><a name="line-7136" data-line="7136">
</a><a name="line-7137" data-line="7137">					// Speed-up: Sizzle(&quot;.CLASS&quot;)
</a><a name="line-7138" data-line="7138">					} else if ( match[2] &amp;&amp; Expr.find.CLASS &amp;&amp; context.getElementsByClassName ) {
</a><a name="line-7139" data-line="7139">						return makeArray( context.getElementsByClassName( match[2] ), extra );
</a><a name="line-7140" data-line="7140">					}
</a><a name="line-7141" data-line="7141">				}
</a><a name="line-7142" data-line="7142">
</a><a name="line-7143" data-line="7143">				if ( context.nodeType === 9 ) {
</a><a name="line-7144" data-line="7144">					// Speed-up: Sizzle(&quot;body&quot;)
</a><a name="line-7145" data-line="7145">					// The body element only exists once, optimize finding it
</a><a name="line-7146" data-line="7146">					if ( query === &quot;body&quot; &amp;&amp; context.body ) {
</a><a name="line-7147" data-line="7147">						return makeArray( [ context.body ], extra );
</a><a name="line-7148" data-line="7148">
</a><a name="line-7149" data-line="7149">					// Speed-up: Sizzle(&quot;#ID&quot;)
</a><a name="line-7150" data-line="7150">					} else if ( match &amp;&amp; match[3] ) {
</a><a name="line-7151" data-line="7151">						var elem = context.getElementById( match[3] );
</a><a name="line-7152" data-line="7152">
</a><a name="line-7153" data-line="7153">						// Check parentNode to catch when Blackberry 4.6 returns
</a><a name="line-7154" data-line="7154">						// nodes that are no longer in the document #6963
</a><a name="line-7155" data-line="7155">						if ( elem &amp;&amp; elem.parentNode ) {
</a><a name="line-7156" data-line="7156">							// Handle the case where IE and Opera return items
</a><a name="line-7157" data-line="7157">							// by name instead of ID
</a><a name="line-7158" data-line="7158">							if ( elem.id === match[3] ) {
</a><a name="line-7159" data-line="7159">								return makeArray( [ elem ], extra );
</a><a name="line-7160" data-line="7160">							}
</a><a name="line-7161" data-line="7161">
</a><a name="line-7162" data-line="7162">						} else {
</a><a name="line-7163" data-line="7163">							return makeArray( [], extra );
</a><a name="line-7164" data-line="7164">						}
</a><a name="line-7165" data-line="7165">					}
</a><a name="line-7166" data-line="7166">
</a><a name="line-7167" data-line="7167">					try {
</a><a name="line-7168" data-line="7168">						return makeArray( context.querySelectorAll(query), extra );
</a><a name="line-7169" data-line="7169">					} catch(qsaError) {}
</a><a name="line-7170" data-line="7170">
</a><a name="line-7171" data-line="7171">				// qSA works strangely on Element-rooted queries
</a><a name="line-7172" data-line="7172">				// We can work around this by specifying an extra ID on the root
</a><a name="line-7173" data-line="7173">				// and working up from there (Thanks to Andrew Dupont for the technique)
</a><a name="line-7174" data-line="7174">				// IE 8 doesn't work on object elements
</a><a name="line-7175" data-line="7175">				} else if ( context.nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
</a><a name="line-7176" data-line="7176">					var oldContext = context,
</a><a name="line-7177" data-line="7177">						old = context.getAttribute( &quot;id&quot; ),
</a><a name="line-7178" data-line="7178">						nid = old || id,
</a><a name="line-7179" data-line="7179">						hasParent = context.parentNode,
</a><a name="line-7180" data-line="7180">						relativeHierarchySelector = /^\s*[+~]/.test( query );
</a><a name="line-7181" data-line="7181">
</a><a name="line-7182" data-line="7182">					if ( !old ) {
</a><a name="line-7183" data-line="7183">						context.setAttribute( &quot;id&quot;, nid );
</a><a name="line-7184" data-line="7184">					} else {
</a><a name="line-7185" data-line="7185">						nid = nid.replace( /'/g, &quot;\\$&amp;&quot; );
</a><a name="line-7186" data-line="7186">					}
</a><a name="line-7187" data-line="7187">					if ( relativeHierarchySelector &amp;&amp; hasParent ) {
</a><a name="line-7188" data-line="7188">						context = context.parentNode;
</a><a name="line-7189" data-line="7189">					}
</a><a name="line-7190" data-line="7190">
</a><a name="line-7191" data-line="7191">					try {
</a><a name="line-7192" data-line="7192">						if ( !relativeHierarchySelector || hasParent ) {
</a><a name="line-7193" data-line="7193">							return makeArray( context.querySelectorAll( &quot;[id='&quot; + nid + &quot;'] &quot; + query ), extra );
</a><a name="line-7194" data-line="7194">						}
</a><a name="line-7195" data-line="7195">
</a><a name="line-7196" data-line="7196">					} catch(pseudoError) {
</a><a name="line-7197" data-line="7197">					} finally {
</a><a name="line-7198" data-line="7198">						if ( !old ) {
</a><a name="line-7199" data-line="7199">							oldContext.removeAttribute( &quot;id&quot; );
</a><a name="line-7200" data-line="7200">						}
</a><a name="line-7201" data-line="7201">					}
</a><a name="line-7202" data-line="7202">				}
</a><a name="line-7203" data-line="7203">			}
</a><a name="line-7204" data-line="7204">
</a><a name="line-7205" data-line="7205">			return oldSizzle(query, context, extra, seed);
</a><a name="line-7206" data-line="7206">		};
</a><a name="line-7207" data-line="7207">
</a><a name="line-7208" data-line="7208">		for ( var prop in oldSizzle ) {
</a><a name="line-7209" data-line="7209">			Sizzle[ prop ] = oldSizzle[ prop ];
</a><a name="line-7210" data-line="7210">		}
</a><a name="line-7211" data-line="7211">
</a><a name="line-7212" data-line="7212">		// release memory in IE
</a><a name="line-7213" data-line="7213">		div = null;
</a><a name="line-7214" data-line="7214">	})();
</a><a name="line-7215" data-line="7215">}
</a><a name="line-7216" data-line="7216">
</a><a name="line-7217" data-line="7217">(function(){
</a><a name="line-7218" data-line="7218">	var html = document.documentElement,
</a><a name="line-7219" data-line="7219">		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;
</a><a name="line-7220" data-line="7220">
</a><a name="line-7221" data-line="7221">	if ( matches ) {
</a><a name="line-7222" data-line="7222">		// Check to see if it's possible to do matchesSelector
</a><a name="line-7223" data-line="7223">		// on a disconnected node (IE 9 fails this)
</a><a name="line-7224" data-line="7224">		var disconnectedMatch = !matches.call( document.createElement( &quot;div&quot; ), &quot;div&quot; ),
</a><a name="line-7225" data-line="7225">			pseudoWorks = false;
</a><a name="line-7226" data-line="7226">
</a><a name="line-7227" data-line="7227">		try {
</a><a name="line-7228" data-line="7228">			// This should fail with an exception
</a><a name="line-7229" data-line="7229">			// Gecko does not error, returns false instead
</a><a name="line-7230" data-line="7230">			matches.call( document.documentElement, &quot;[test!='']:sizzle&quot; );
</a><a name="line-7231" data-line="7231">
</a><a name="line-7232" data-line="7232">		} catch( pseudoError ) {
</a><a name="line-7233" data-line="7233">			pseudoWorks = true;
</a><a name="line-7234" data-line="7234">		}
</a><a name="line-7235" data-line="7235">
</a><a name="line-7236" data-line="7236">		Sizzle.matchesSelector = function( node, expr ) {
</a><a name="line-7237" data-line="7237">			// Make sure that attribute selectors are quoted
</a><a name="line-7238" data-line="7238">			expr = expr.replace(/\=\s*([^'&quot;\]]*)\s*\]/g, &quot;='$1']&quot;);
</a><a name="line-7239" data-line="7239">
</a><a name="line-7240" data-line="7240">			if ( !Sizzle.isXML( node ) ) {
</a><a name="line-7241" data-line="7241">				try {
</a><a name="line-7242" data-line="7242">					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) &amp;&amp; !/!=/.test( expr ) ) {
</a><a name="line-7243" data-line="7243">						var ret = matches.call( node, expr );
</a><a name="line-7244" data-line="7244">
</a><a name="line-7245" data-line="7245">						// IE 9's matchesSelector returns false on disconnected nodes
</a><a name="line-7246" data-line="7246">						if ( ret || !disconnectedMatch ||
</a><a name="line-7247" data-line="7247">								// As well, disconnected nodes are said to be in a document
</a><a name="line-7248" data-line="7248">								// fragment in IE 9, so check for that
</a><a name="line-7249" data-line="7249">								node.document &amp;&amp; node.document.nodeType !== 11 ) {
</a><a name="line-7250" data-line="7250">							return ret;
</a><a name="line-7251" data-line="7251">						}
</a><a name="line-7252" data-line="7252">					}
</a><a name="line-7253" data-line="7253">				} catch(e) {}
</a><a name="line-7254" data-line="7254">			}
</a><a name="line-7255" data-line="7255">
</a><a name="line-7256" data-line="7256">			return Sizzle(expr, null, null, [node]).length &gt; 0;
</a><a name="line-7257" data-line="7257">		};
</a><a name="line-7258" data-line="7258">	}
</a><a name="line-7259" data-line="7259">})();
</a><a name="line-7260" data-line="7260">
</a><a name="line-7261" data-line="7261">(function(){
</a><a name="line-7262" data-line="7262">	var div = document.createElement(&quot;div&quot;);
</a><a name="line-7263" data-line="7263">
</a><a name="line-7264" data-line="7264">	div.innerHTML = &quot;&lt;div class='test e'&gt;&lt;/div&gt;&lt;div class='test'&gt;&lt;/div&gt;&quot;;
</a><a name="line-7265" data-line="7265">
</a><a name="line-7266" data-line="7266">	// Opera can't find a second classname (in 9.6)
</a><a name="line-7267" data-line="7267">	// Also, make sure that getElementsByClassName actually exists
</a><a name="line-7268" data-line="7268">	if ( !div.getElementsByClassName || div.getElementsByClassName(&quot;e&quot;).length === 0 ) {
</a><a name="line-7269" data-line="7269">		return;
</a><a name="line-7270" data-line="7270">	}
</a><a name="line-7271" data-line="7271">
</a><a name="line-7272" data-line="7272">	// Safari caches class attributes, doesn't catch changes (in 3.2)
</a><a name="line-7273" data-line="7273">	div.lastChild.className = &quot;e&quot;;
</a><a name="line-7274" data-line="7274">
</a><a name="line-7275" data-line="7275">	if ( div.getElementsByClassName(&quot;e&quot;).length === 1 ) {
</a><a name="line-7276" data-line="7276">		return;
</a><a name="line-7277" data-line="7277">	}
</a><a name="line-7278" data-line="7278">
</a><a name="line-7279" data-line="7279">	Expr.order.splice(1, 0, &quot;CLASS&quot;);
</a><a name="line-7280" data-line="7280">	Expr.find.CLASS = function( match, context, isXML ) {
</a><a name="line-7281" data-line="7281">		if ( typeof context.getElementsByClassName !== &quot;undefined&quot; &amp;&amp; !isXML ) {
</a><a name="line-7282" data-line="7282">			return context.getElementsByClassName(match[1]);
</a><a name="line-7283" data-line="7283">		}
</a><a name="line-7284" data-line="7284">	};
</a><a name="line-7285" data-line="7285">
</a><a name="line-7286" data-line="7286">	// release memory in IE
</a><a name="line-7287" data-line="7287">	div = null;
</a><a name="line-7288" data-line="7288">})();
</a><a name="line-7289" data-line="7289">
</a><a name="line-7290" data-line="7290">function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
</a><a name="line-7291" data-line="7291">	for ( var i = 0, l = checkSet.length; i &lt; l; i++ ) {
</a><a name="line-7292" data-line="7292">		var elem = checkSet[i];
</a><a name="line-7293" data-line="7293">
</a><a name="line-7294" data-line="7294">		if ( elem ) {
</a><a name="line-7295" data-line="7295">			var match = false;
</a><a name="line-7296" data-line="7296">
</a><a name="line-7297" data-line="7297">			elem = elem[dir];
</a><a name="line-7298" data-line="7298">
</a><a name="line-7299" data-line="7299">			while ( elem ) {
</a><a name="line-7300" data-line="7300">				if ( elem[ expando ] === doneName ) {
</a><a name="line-7301" data-line="7301">					match = checkSet[elem.sizset];
</a><a name="line-7302" data-line="7302">					break;
</a><a name="line-7303" data-line="7303">				}
</a><a name="line-7304" data-line="7304">
</a><a name="line-7305" data-line="7305">				if ( elem.nodeType === 1 &amp;&amp; !isXML ){
</a><a name="line-7306" data-line="7306">					elem[ expando ] = doneName;
</a><a name="line-7307" data-line="7307">					elem.sizset = i;
</a><a name="line-7308" data-line="7308">				}
</a><a name="line-7309" data-line="7309">
</a><a name="line-7310" data-line="7310">				if ( elem.nodeName.toLowerCase() === cur ) {
</a><a name="line-7311" data-line="7311">					match = elem;
</a><a name="line-7312" data-line="7312">					break;
</a><a name="line-7313" data-line="7313">				}
</a><a name="line-7314" data-line="7314">
</a><a name="line-7315" data-line="7315">				elem = elem[dir];
</a><a name="line-7316" data-line="7316">			}
</a><a name="line-7317" data-line="7317">
</a><a name="line-7318" data-line="7318">			checkSet[i] = match;
</a><a name="line-7319" data-line="7319">		}
</a><a name="line-7320" data-line="7320">	}
</a><a name="line-7321" data-line="7321">}
</a><a name="line-7322" data-line="7322">
</a><a name="line-7323" data-line="7323">function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
</a><a name="line-7324" data-line="7324">	for ( var i = 0, l = checkSet.length; i &lt; l; i++ ) {
</a><a name="line-7325" data-line="7325">		var elem = checkSet[i];
</a><a name="line-7326" data-line="7326">
</a><a name="line-7327" data-line="7327">		if ( elem ) {
</a><a name="line-7328" data-line="7328">			var match = false;
</a><a name="line-7329" data-line="7329">
</a><a name="line-7330" data-line="7330">			elem = elem[dir];
</a><a name="line-7331" data-line="7331">
</a><a name="line-7332" data-line="7332">			while ( elem ) {
</a><a name="line-7333" data-line="7333">				if ( elem[ expando ] === doneName ) {
</a><a name="line-7334" data-line="7334">					match = checkSet[elem.sizset];
</a><a name="line-7335" data-line="7335">					break;
</a><a name="line-7336" data-line="7336">				}
</a><a name="line-7337" data-line="7337">
</a><a name="line-7338" data-line="7338">				if ( elem.nodeType === 1 ) {
</a><a name="line-7339" data-line="7339">					if ( !isXML ) {
</a><a name="line-7340" data-line="7340">						elem[ expando ] = doneName;
</a><a name="line-7341" data-line="7341">						elem.sizset = i;
</a><a name="line-7342" data-line="7342">					}
</a><a name="line-7343" data-line="7343">
</a><a name="line-7344" data-line="7344">					if ( typeof cur !== &quot;string&quot; ) {
</a><a name="line-7345" data-line="7345">						if ( elem === cur ) {
</a><a name="line-7346" data-line="7346">							match = true;
</a><a name="line-7347" data-line="7347">							break;
</a><a name="line-7348" data-line="7348">						}
</a><a name="line-7349" data-line="7349">
</a><a name="line-7350" data-line="7350">					} else if ( Sizzle.filter( cur, [elem] ).length &gt; 0 ) {
</a><a name="line-7351" data-line="7351">						match = elem;
</a><a name="line-7352" data-line="7352">						break;
</a><a name="line-7353" data-line="7353">					}
</a><a name="line-7354" data-line="7354">				}
</a><a name="line-7355" data-line="7355">
</a><a name="line-7356" data-line="7356">				elem = elem[dir];
</a><a name="line-7357" data-line="7357">			}
</a><a name="line-7358" data-line="7358">
</a><a name="line-7359" data-line="7359">			checkSet[i] = match;
</a><a name="line-7360" data-line="7360">		}
</a><a name="line-7361" data-line="7361">	}
</a><a name="line-7362" data-line="7362">}
</a><a name="line-7363" data-line="7363">
</a><a name="line-7364" data-line="7364">if ( document.documentElement.contains ) {
</a><a name="line-7365" data-line="7365">	Sizzle.contains = function( a, b ) {
</a><a name="line-7366" data-line="7366">		return a !== b &amp;&amp; (a.contains ? a.contains(b) : true);
</a><a name="line-7367" data-line="7367">	};
</a><a name="line-7368" data-line="7368">
</a><a name="line-7369" data-line="7369">} else if ( document.documentElement.compareDocumentPosition ) {
</a><a name="line-7370" data-line="7370">	Sizzle.contains = function( a, b ) {
</a><a name="line-7371" data-line="7371">		return !!(a.compareDocumentPosition(b) &amp; 16);
</a><a name="line-7372" data-line="7372">	};
</a><a name="line-7373" data-line="7373">
</a><a name="line-7374" data-line="7374">} else {
</a><a name="line-7375" data-line="7375">	Sizzle.contains = function() {
</a><a name="line-7376" data-line="7376">		return false;
</a><a name="line-7377" data-line="7377">	};
</a><a name="line-7378" data-line="7378">}
</a><a name="line-7379" data-line="7379">
</a><a name="line-7380" data-line="7380">Sizzle.isXML = function( elem ) {
</a><a name="line-7381" data-line="7381">	// documentElement is verified for cases where it doesn't yet exist
</a><a name="line-7382" data-line="7382">	// (such as loading iframes in IE - #4833)
</a><a name="line-7383" data-line="7383">	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;
</a><a name="line-7384" data-line="7384">
</a><a name="line-7385" data-line="7385">	return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
</a><a name="line-7386" data-line="7386">};
</a><a name="line-7387" data-line="7387">
</a><a name="line-7388" data-line="7388">var posProcess = function( selector, context, seed ) {
</a><a name="line-7389" data-line="7389">	var match,
</a><a name="line-7390" data-line="7390">		tmpSet = [],
</a><a name="line-7391" data-line="7391">		later = &quot;&quot;,
</a><a name="line-7392" data-line="7392">		root = context.nodeType ? [context] : context;
</a><a name="line-7393" data-line="7393">
</a><a name="line-7394" data-line="7394">	// Position selectors must be done after the filter
</a><a name="line-7395" data-line="7395">	// And so must :not(positional) so we move all PSEUDOs to the end
</a><a name="line-7396" data-line="7396">	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
</a><a name="line-7397" data-line="7397">		later += match[0];
</a><a name="line-7398" data-line="7398">		selector = selector.replace( Expr.match.PSEUDO, &quot;&quot; );
</a><a name="line-7399" data-line="7399">	}
</a><a name="line-7400" data-line="7400">
</a><a name="line-7401" data-line="7401">	selector = Expr.relative[selector] ? selector + &quot;*&quot; : selector;
</a><a name="line-7402" data-line="7402">
</a><a name="line-7403" data-line="7403">	for ( var i = 0, l = root.length; i &lt; l; i++ ) {
</a><a name="line-7404" data-line="7404">		Sizzle( selector, root[i], tmpSet, seed );
</a><a name="line-7405" data-line="7405">	}
</a><a name="line-7406" data-line="7406">
</a><a name="line-7407" data-line="7407">	return Sizzle.filter( later, tmpSet );
</a><a name="line-7408" data-line="7408">};
</a><a name="line-7409" data-line="7409">
</a><a name="line-7410" data-line="7410">// EXPOSE
</a><a name="line-7411" data-line="7411">// Override sizzle attribute retrieval
</a><a name="line-7412" data-line="7412">Sizzle.attr = jQuery.attr;
</a><a name="line-7413" data-line="7413">Sizzle.selectors.attrMap = {};
</a><a name="line-7414" data-line="7414">jQuery.find = Sizzle;
</a><a name="line-7415" data-line="7415">jQuery.expr = Sizzle.selectors;
</a><a name="line-7416" data-line="7416">jQuery.expr[&quot;:&quot;] = jQuery.expr.filters;
</a><a name="line-7417" data-line="7417">jQuery.unique = Sizzle.uniqueSort;
</a><a name="line-7418" data-line="7418">jQuery.text = Sizzle.getText;
</a><a name="line-7419" data-line="7419">jQuery.isXMLDoc = Sizzle.isXML;
</a><a name="line-7420" data-line="7420">jQuery.contains = Sizzle.contains;
</a><a name="line-7421" data-line="7421">
</a><a name="line-7422" data-line="7422">
</a><a name="line-7423" data-line="7423">})();
</a><a name="line-7424" data-line="7424">
</a><a name="line-7425" data-line="7425">
</a><a name="line-7426" data-line="7426">var runtil = /Until$/,
</a><a name="line-7427" data-line="7427">	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
</a><a name="line-7428" data-line="7428">	// Note: This RegExp should be improved, or likely pulled from Sizzle
</a><a name="line-7429" data-line="7429">	rmultiselector = /,/,
</a><a name="line-7430" data-line="7430">	isSimple = /^.[^:#\[\.,]*$/,
</a><a name="line-7431" data-line="7431">	slice = Array.prototype.slice,
</a><a name="line-7432" data-line="7432">	POS = jQuery.expr.match.globalPOS,
</a><a name="line-7433" data-line="7433">	// methods guaranteed to produce a unique set when starting from a unique set
</a><a name="line-7434" data-line="7434">	guaranteedUnique = {
</a><a name="line-7435" data-line="7435">		children: true,
</a><a name="line-7436" data-line="7436">		contents: true,
</a><a name="line-7437" data-line="7437">		next: true,
</a><a name="line-7438" data-line="7438">		prev: true
</a><a name="line-7439" data-line="7439">	};
</a><a name="line-7440" data-line="7440">
</a><a name="line-7441" data-line="7441">jQuery.fn.extend({
</a><a name="line-7442" data-line="7442">	find: function( selector ) {
</a><a name="line-7443" data-line="7443">		var self = this,
</a><a name="line-7444" data-line="7444">			i, l;
</a><a name="line-7445" data-line="7445">
</a><a name="line-7446" data-line="7446">		if ( typeof selector !== &quot;string&quot; ) {
</a><a name="line-7447" data-line="7447">			return jQuery( selector ).filter(function() {
</a><a name="line-7448" data-line="7448">				for ( i = 0, l = self.length; i &lt; l; i++ ) {
</a><a name="line-7449" data-line="7449">					if ( jQuery.contains( self[ i ], this ) ) {
</a><a name="line-7450" data-line="7450">						return true;
</a><a name="line-7451" data-line="7451">					}
</a><a name="line-7452" data-line="7452">				}
</a><a name="line-7453" data-line="7453">			});
</a><a name="line-7454" data-line="7454">		}
</a><a name="line-7455" data-line="7455">
</a><a name="line-7456" data-line="7456">		var ret = this.pushStack( &quot;&quot;, &quot;find&quot;, selector ),
</a><a name="line-7457" data-line="7457">			length, n, r;
</a><a name="line-7458" data-line="7458">
</a><a name="line-7459" data-line="7459">		for ( i = 0, l = this.length; i &lt; l; i++ ) {
</a><a name="line-7460" data-line="7460">			length = ret.length;
</a><a name="line-7461" data-line="7461">			jQuery.find( selector, this[i], ret );
</a><a name="line-7462" data-line="7462">
</a><a name="line-7463" data-line="7463">			if ( i &gt; 0 ) {
</a><a name="line-7464" data-line="7464">				// Make sure that the results are unique
</a><a name="line-7465" data-line="7465">				for ( n = length; n &lt; ret.length; n++ ) {
</a><a name="line-7466" data-line="7466">					for ( r = 0; r &lt; length; r++ ) {
</a><a name="line-7467" data-line="7467">						if ( ret[r] === ret[n] ) {
</a><a name="line-7468" data-line="7468">							ret.splice(n--, 1);
</a><a name="line-7469" data-line="7469">							break;
</a><a name="line-7470" data-line="7470">						}
</a><a name="line-7471" data-line="7471">					}
</a><a name="line-7472" data-line="7472">				}
</a><a name="line-7473" data-line="7473">			}
</a><a name="line-7474" data-line="7474">		}
</a><a name="line-7475" data-line="7475">
</a><a name="line-7476" data-line="7476">		return ret;
</a><a name="line-7477" data-line="7477">	},
</a><a name="line-7478" data-line="7478">
</a><a name="line-7479" data-line="7479">	has: function( target ) {
</a><a name="line-7480" data-line="7480">		var targets = jQuery( target );
</a><a name="line-7481" data-line="7481">		return this.filter(function() {
</a><a name="line-7482" data-line="7482">			for ( var i = 0, l = targets.length; i &lt; l; i++ ) {
</a><a name="line-7483" data-line="7483">				if ( jQuery.contains( this, targets[i] ) ) {
</a><a name="line-7484" data-line="7484">					return true;
</a><a name="line-7485" data-line="7485">				}
</a><a name="line-7486" data-line="7486">			}
</a><a name="line-7487" data-line="7487">		});
</a><a name="line-7488" data-line="7488">	},
</a><a name="line-7489" data-line="7489">
</a><a name="line-7490" data-line="7490">	not: function( selector ) {
</a><a name="line-7491" data-line="7491">		return this.pushStack( winnow(this, selector, false), &quot;not&quot;, selector);
</a><a name="line-7492" data-line="7492">	},
</a><a name="line-7493" data-line="7493">
</a><a name="line-7494" data-line="7494">	filter: function( selector ) {
</a><a name="line-7495" data-line="7495">		return this.pushStack( winnow(this, selector, true), &quot;filter&quot;, selector );
</a><a name="line-7496" data-line="7496">	},
</a><a name="line-7497" data-line="7497">
</a><a name="line-7498" data-line="7498">	is: function( selector ) {
</a><a name="line-7499" data-line="7499">		return !!selector &amp;&amp; (
</a><a name="line-7500" data-line="7500">			typeof selector === &quot;string&quot; ?
</a><a name="line-7501" data-line="7501">				// If this is a positional selector, check membership in the returned set
</a><a name="line-7502" data-line="7502">				// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won't return true for a doc with two &quot;p&quot;.
</a><a name="line-7503" data-line="7503">				POS.test( selector ) ?
</a><a name="line-7504" data-line="7504">					jQuery( selector, this.context ).index( this[0] ) &gt;= 0 :
</a><a name="line-7505" data-line="7505">					jQuery.filter( selector, this ).length &gt; 0 :
</a><a name="line-7506" data-line="7506">				this.filter( selector ).length &gt; 0 );
</a><a name="line-7507" data-line="7507">	},
</a><a name="line-7508" data-line="7508">
</a><a name="line-7509" data-line="7509">	closest: function( selectors, context ) {
</a><a name="line-7510" data-line="7510">		var ret = [], i, l, cur = this[0];
</a><a name="line-7511" data-line="7511">
</a><a name="line-7512" data-line="7512">		// Array (deprecated as of jQuery 1.7)
</a><a name="line-7513" data-line="7513">		if ( jQuery.isArray( selectors ) ) {
</a><a name="line-7514" data-line="7514">			var level = 1;
</a><a name="line-7515" data-line="7515">
</a><a name="line-7516" data-line="7516">			while ( cur &amp;&amp; cur.ownerDocument &amp;&amp; cur !== context ) {
</a><a name="line-7517" data-line="7517">				for ( i = 0; i &lt; selectors.length; i++ ) {
</a><a name="line-7518" data-line="7518">
</a><a name="line-7519" data-line="7519">					if ( jQuery( cur ).is( selectors[ i ] ) ) {
</a><a name="line-7520" data-line="7520">						ret.push({ selector: selectors[ i ], elem: cur, level: level });
</a><a name="line-7521" data-line="7521">					}
</a><a name="line-7522" data-line="7522">				}
</a><a name="line-7523" data-line="7523">
</a><a name="line-7524" data-line="7524">				cur = cur.parentNode;
</a><a name="line-7525" data-line="7525">				level++;
</a><a name="line-7526" data-line="7526">			}
</a><a name="line-7527" data-line="7527">
</a><a name="line-7528" data-line="7528">			return ret;
</a><a name="line-7529" data-line="7529">		}
</a><a name="line-7530" data-line="7530">
</a><a name="line-7531" data-line="7531">		// String
</a><a name="line-7532" data-line="7532">		var pos = POS.test( selectors ) || typeof selectors !== &quot;string&quot; ?
</a><a name="line-7533" data-line="7533">				jQuery( selectors, context || this.context ) :
</a><a name="line-7534" data-line="7534">				0;
</a><a name="line-7535" data-line="7535">
</a><a name="line-7536" data-line="7536">		for ( i = 0, l = this.length; i &lt; l; i++ ) {
</a><a name="line-7537" data-line="7537">			cur = this[i];
</a><a name="line-7538" data-line="7538">
</a><a name="line-7539" data-line="7539">			while ( cur ) {
</a><a name="line-7540" data-line="7540">				if ( pos ? pos.index(cur) &gt; -1 : jQuery.find.matchesSelector(cur, selectors) ) {
</a><a name="line-7541" data-line="7541">					ret.push( cur );
</a><a name="line-7542" data-line="7542">					break;
</a><a name="line-7543" data-line="7543">
</a><a name="line-7544" data-line="7544">				} else {
</a><a name="line-7545" data-line="7545">					cur = cur.parentNode;
</a><a name="line-7546" data-line="7546">					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
</a><a name="line-7547" data-line="7547">						break;
</a><a name="line-7548" data-line="7548">					}
</a><a name="line-7549" data-line="7549">				}
</a><a name="line-7550" data-line="7550">			}
</a><a name="line-7551" data-line="7551">		}
</a><a name="line-7552" data-line="7552">
</a><a name="line-7553" data-line="7553">		ret = ret.length &gt; 1 ? jQuery.unique( ret ) : ret;
</a><a name="line-7554" data-line="7554">
</a><a name="line-7555" data-line="7555">		return this.pushStack( ret, &quot;closest&quot;, selectors );
</a><a name="line-7556" data-line="7556">	},
</a><a name="line-7557" data-line="7557">
</a><a name="line-7558" data-line="7558">	// Determine the position of an element within
</a><a name="line-7559" data-line="7559">	// the matched set of elements
</a><a name="line-7560" data-line="7560">	index: function( elem ) {
</a><a name="line-7561" data-line="7561">
</a><a name="line-7562" data-line="7562">		// No argument, return index in parent
</a><a name="line-7563" data-line="7563">		if ( !elem ) {
</a><a name="line-7564" data-line="7564">			return ( this[0] &amp;&amp; this[0].parentNode ) ? this.prevAll().length : -1;
</a><a name="line-7565" data-line="7565">		}
</a><a name="line-7566" data-line="7566">
</a><a name="line-7567" data-line="7567">		// index in selector
</a><a name="line-7568" data-line="7568">		if ( typeof elem === &quot;string&quot; ) {
</a><a name="line-7569" data-line="7569">			return jQuery.inArray( this[0], jQuery( elem ) );
</a><a name="line-7570" data-line="7570">		}
</a><a name="line-7571" data-line="7571">
</a><a name="line-7572" data-line="7572">		// Locate the position of the desired element
</a><a name="line-7573" data-line="7573">		return jQuery.inArray(
</a><a name="line-7574" data-line="7574">			// If it receives a jQuery object, the first element is used
</a><a name="line-7575" data-line="7575">			elem.jquery ? elem[0] : elem, this );
</a><a name="line-7576" data-line="7576">	},
</a><a name="line-7577" data-line="7577">
</a><a name="line-7578" data-line="7578">	add: function( selector, context ) {
</a><a name="line-7579" data-line="7579">		var set = typeof selector === &quot;string&quot; ?
</a><a name="line-7580" data-line="7580">				jQuery( selector, context ) :
</a><a name="line-7581" data-line="7581">				jQuery.makeArray( selector &amp;&amp; selector.nodeType ? [ selector ] : selector ),
</a><a name="line-7582" data-line="7582">			all = jQuery.merge( this.get(), set );
</a><a name="line-7583" data-line="7583">
</a><a name="line-7584" data-line="7584">		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
</a><a name="line-7585" data-line="7585">			all :
</a><a name="line-7586" data-line="7586">			jQuery.unique( all ) );
</a><a name="line-7587" data-line="7587">	},
</a><a name="line-7588" data-line="7588">
</a><a name="line-7589" data-line="7589">	andSelf: function() {
</a><a name="line-7590" data-line="7590">		return this.add( this.prevObject );
</a><a name="line-7591" data-line="7591">	}
</a><a name="line-7592" data-line="7592">});
</a><a name="line-7593" data-line="7593">
</a><a name="line-7594" data-line="7594">// A painfully simple check to see if an element is disconnected
</a><a name="line-7595" data-line="7595">// from a document (should be improved, where feasible).
</a><a name="line-7596" data-line="7596">function isDisconnected( node ) {
</a><a name="line-7597" data-line="7597">	return !node || !node.parentNode || node.parentNode.nodeType === 11;
</a><a name="line-7598" data-line="7598">}
</a><a name="line-7599" data-line="7599">
</a><a name="line-7600" data-line="7600">jQuery.each({
</a><a name="line-7601" data-line="7601">	parent: function( elem ) {
</a><a name="line-7602" data-line="7602">		var parent = elem.parentNode;
</a><a name="line-7603" data-line="7603">		return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
</a><a name="line-7604" data-line="7604">	},
</a><a name="line-7605" data-line="7605">	parents: function( elem ) {
</a><a name="line-7606" data-line="7606">		return jQuery.dir( elem, &quot;parentNode&quot; );
</a><a name="line-7607" data-line="7607">	},
</a><a name="line-7608" data-line="7608">	parentsUntil: function( elem, i, until ) {
</a><a name="line-7609" data-line="7609">		return jQuery.dir( elem, &quot;parentNode&quot;, until );
</a><a name="line-7610" data-line="7610">	},
</a><a name="line-7611" data-line="7611">	next: function( elem ) {
</a><a name="line-7612" data-line="7612">		return jQuery.nth( elem, 2, &quot;nextSibling&quot; );
</a><a name="line-7613" data-line="7613">	},
</a><a name="line-7614" data-line="7614">	prev: function( elem ) {
</a><a name="line-7615" data-line="7615">		return jQuery.nth( elem, 2, &quot;previousSibling&quot; );
</a><a name="line-7616" data-line="7616">	},
</a><a name="line-7617" data-line="7617">	nextAll: function( elem ) {
</a><a name="line-7618" data-line="7618">		return jQuery.dir( elem, &quot;nextSibling&quot; );
</a><a name="line-7619" data-line="7619">	},
</a><a name="line-7620" data-line="7620">	prevAll: function( elem ) {
</a><a name="line-7621" data-line="7621">		return jQuery.dir( elem, &quot;previousSibling&quot; );
</a><a name="line-7622" data-line="7622">	},
</a><a name="line-7623" data-line="7623">	nextUntil: function( elem, i, until ) {
</a><a name="line-7624" data-line="7624">		return jQuery.dir( elem, &quot;nextSibling&quot;, until );
</a><a name="line-7625" data-line="7625">	},
</a><a name="line-7626" data-line="7626">	prevUntil: function( elem, i, until ) {
</a><a name="line-7627" data-line="7627">		return jQuery.dir( elem, &quot;previousSibling&quot;, until );
</a><a name="line-7628" data-line="7628">	},
</a><a name="line-7629" data-line="7629">	siblings: function( elem ) {
</a><a name="line-7630" data-line="7630">		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
</a><a name="line-7631" data-line="7631">	},
</a><a name="line-7632" data-line="7632">	children: function( elem ) {
</a><a name="line-7633" data-line="7633">		return jQuery.sibling( elem.firstChild );
</a><a name="line-7634" data-line="7634">	},
</a><a name="line-7635" data-line="7635">	contents: function( elem ) {
</a><a name="line-7636" data-line="7636">		return jQuery.nodeName( elem, &quot;iframe&quot; ) ?
</a><a name="line-7637" data-line="7637">			elem.contentDocument || elem.contentWindow.document :
</a><a name="line-7638" data-line="7638">			jQuery.makeArray( elem.childNodes );
</a><a name="line-7639" data-line="7639">	}
</a><a name="line-7640" data-line="7640">}, function( name, fn ) {
</a><a name="line-7641" data-line="7641">	jQuery.fn[ name ] = function( until, selector ) {
</a><a name="line-7642" data-line="7642">		var ret = jQuery.map( this, fn, until );
</a><a name="line-7643" data-line="7643">
</a><a name="line-7644" data-line="7644">		if ( !runtil.test( name ) ) {
</a><a name="line-7645" data-line="7645">			selector = until;
</a><a name="line-7646" data-line="7646">		}
</a><a name="line-7647" data-line="7647">
</a><a name="line-7648" data-line="7648">		if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
</a><a name="line-7649" data-line="7649">			ret = jQuery.filter( selector, ret );
</a><a name="line-7650" data-line="7650">		}
</a><a name="line-7651" data-line="7651">
</a><a name="line-7652" data-line="7652">		ret = this.length &gt; 1 &amp;&amp; !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;
</a><a name="line-7653" data-line="7653">
</a><a name="line-7654" data-line="7654">		if ( (this.length &gt; 1 || rmultiselector.test( selector )) &amp;&amp; rparentsprev.test( name ) ) {
</a><a name="line-7655" data-line="7655">			ret = ret.reverse();
</a><a name="line-7656" data-line="7656">		}
</a><a name="line-7657" data-line="7657">
</a><a name="line-7658" data-line="7658">		return this.pushStack( ret, name, slice.call( arguments ).join(&quot;,&quot;) );
</a><a name="line-7659" data-line="7659">	};
</a><a name="line-7660" data-line="7660">});
</a><a name="line-7661" data-line="7661">
</a><a name="line-7662" data-line="7662">jQuery.extend({
</a><a name="line-7663" data-line="7663">	filter: function( expr, elems, not ) {
</a><a name="line-7664" data-line="7664">		if ( not ) {
</a><a name="line-7665" data-line="7665">			expr = &quot;:not(&quot; + expr + &quot;)&quot;;
</a><a name="line-7666" data-line="7666">		}
</a><a name="line-7667" data-line="7667">
</a><a name="line-7668" data-line="7668">		return elems.length === 1 ?
</a><a name="line-7669" data-line="7669">			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
</a><a name="line-7670" data-line="7670">			jQuery.find.matches(expr, elems);
</a><a name="line-7671" data-line="7671">	},
</a><a name="line-7672" data-line="7672">
</a><a name="line-7673" data-line="7673">	dir: function( elem, dir, until ) {
</a><a name="line-7674" data-line="7674">		var matched = [],
</a><a name="line-7675" data-line="7675">			cur = elem[ dir ];
</a><a name="line-7676" data-line="7676">
</a><a name="line-7677" data-line="7677">		while ( cur &amp;&amp; cur.nodeType !== 9 &amp;&amp; (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
</a><a name="line-7678" data-line="7678">			if ( cur.nodeType === 1 ) {
</a><a name="line-7679" data-line="7679">				matched.push( cur );
</a><a name="line-7680" data-line="7680">			}
</a><a name="line-7681" data-line="7681">			cur = cur[dir];
</a><a name="line-7682" data-line="7682">		}
</a><a name="line-7683" data-line="7683">		return matched;
</a><a name="line-7684" data-line="7684">	},
</a><a name="line-7685" data-line="7685">
</a><a name="line-7686" data-line="7686">	nth: function( cur, result, dir, elem ) {
</a><a name="line-7687" data-line="7687">		result = result || 1;
</a><a name="line-7688" data-line="7688">		var num = 0;
</a><a name="line-7689" data-line="7689">
</a><a name="line-7690" data-line="7690">		for ( ; cur; cur = cur[dir] ) {
</a><a name="line-7691" data-line="7691">			if ( cur.nodeType === 1 &amp;&amp; ++num === result ) {
</a><a name="line-7692" data-line="7692">				break;
</a><a name="line-7693" data-line="7693">			}
</a><a name="line-7694" data-line="7694">		}
</a><a name="line-7695" data-line="7695">
</a><a name="line-7696" data-line="7696">		return cur;
</a><a name="line-7697" data-line="7697">	},
</a><a name="line-7698" data-line="7698">
</a><a name="line-7699" data-line="7699">	sibling: function( n, elem ) {
</a><a name="line-7700" data-line="7700">		var r = [];
</a><a name="line-7701" data-line="7701">
</a><a name="line-7702" data-line="7702">		for ( ; n; n = n.nextSibling ) {
</a><a name="line-7703" data-line="7703">			if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
</a><a name="line-7704" data-line="7704">				r.push( n );
</a><a name="line-7705" data-line="7705">			}
</a><a name="line-7706" data-line="7706">		}
</a><a name="line-7707" data-line="7707">
</a><a name="line-7708" data-line="7708">		return r;
</a><a name="line-7709" data-line="7709">	}
</a><a name="line-7710" data-line="7710">});
</a><a name="line-7711" data-line="7711">
</a><a name="line-7712" data-line="7712">// Implement the identical functionality for filter and not
</a><a name="line-7713" data-line="7713">function winnow( elements, qualifier, keep ) {
</a><a name="line-7714" data-line="7714">
</a><a name="line-7715" data-line="7715">	// Can't pass null or undefined to indexOf in Firefox 4
</a><a name="line-7716" data-line="7716">	// Set to 0 to skip string check
</a><a name="line-7717" data-line="7717">	qualifier = qualifier || 0;
</a><a name="line-7718" data-line="7718">
</a><a name="line-7719" data-line="7719">	if ( jQuery.isFunction( qualifier ) ) {
</a><a name="line-7720" data-line="7720">		return jQuery.grep(elements, function( elem, i ) {
</a><a name="line-7721" data-line="7721">			var retVal = !!qualifier.call( elem, i, elem );
</a><a name="line-7722" data-line="7722">			return retVal === keep;
</a><a name="line-7723" data-line="7723">		});
</a><a name="line-7724" data-line="7724">
</a><a name="line-7725" data-line="7725">	} else if ( qualifier.nodeType ) {
</a><a name="line-7726" data-line="7726">		return jQuery.grep(elements, function( elem, i ) {
</a><a name="line-7727" data-line="7727">			return ( elem === qualifier ) === keep;
</a><a name="line-7728" data-line="7728">		});
</a><a name="line-7729" data-line="7729">
</a><a name="line-7730" data-line="7730">	} else if ( typeof qualifier === &quot;string&quot; ) {
</a><a name="line-7731" data-line="7731">		var filtered = jQuery.grep(elements, function( elem ) {
</a><a name="line-7732" data-line="7732">			return elem.nodeType === 1;
</a><a name="line-7733" data-line="7733">		});
</a><a name="line-7734" data-line="7734">
</a><a name="line-7735" data-line="7735">		if ( isSimple.test( qualifier ) ) {
</a><a name="line-7736" data-line="7736">			return jQuery.filter(qualifier, filtered, !keep);
</a><a name="line-7737" data-line="7737">		} else {
</a><a name="line-7738" data-line="7738">			qualifier = jQuery.filter( qualifier, filtered );
</a><a name="line-7739" data-line="7739">		}
</a><a name="line-7740" data-line="7740">	}
</a><a name="line-7741" data-line="7741">
</a><a name="line-7742" data-line="7742">	return jQuery.grep(elements, function( elem, i ) {
</a><a name="line-7743" data-line="7743">		return ( jQuery.inArray( elem, qualifier ) &gt;= 0 ) === keep;
</a><a name="line-7744" data-line="7744">	});
</a><a name="line-7745" data-line="7745">}
</a><a name="line-7746" data-line="7746">
</a><a name="line-7747" data-line="7747">
</a><a name="line-7748" data-line="7748">
</a><a name="line-7749" data-line="7749">
</a><a name="line-7750" data-line="7750">function createSafeFragment( document ) {
</a><a name="line-7751" data-line="7751">	var list = nodeNames.split( &quot;|&quot; ),
</a><a name="line-7752" data-line="7752">	safeFrag = document.createDocumentFragment();
</a><a name="line-7753" data-line="7753">
</a><a name="line-7754" data-line="7754">	if ( safeFrag.createElement ) {
</a><a name="line-7755" data-line="7755">		while ( list.length ) {
</a><a name="line-7756" data-line="7756">			safeFrag.createElement(
</a><a name="line-7757" data-line="7757">				list.pop()
</a><a name="line-7758" data-line="7758">			);
</a><a name="line-7759" data-line="7759">		}
</a><a name="line-7760" data-line="7760">	}
</a><a name="line-7761" data-line="7761">	return safeFrag;
</a><a name="line-7762" data-line="7762">}
</a><a name="line-7763" data-line="7763">
</a><a name="line-7764" data-line="7764">var nodeNames = &quot;abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|&quot; +
</a><a name="line-7765" data-line="7765">		&quot;header|hgroup|mark|meter|nav|output|progress|section|summary|time|video&quot;,
</a><a name="line-7766" data-line="7766">	rinlinejQuery = / jQuery\d+=&quot;(?:\d+|null)&quot;/g,
</a><a name="line-7767" data-line="7767">	rleadingWhitespace = /^\s+/,
</a><a name="line-7768" data-line="7768">	rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/ig,
</a><a name="line-7769" data-line="7769">	rtagName = /&lt;([\w:]+)/,
</a><a name="line-7770" data-line="7770">	rtbody = /&lt;tbody/i,
</a><a name="line-7771" data-line="7771">	rhtml = /&lt;|&amp;#?\w+;/,
</a><a name="line-7772" data-line="7772">	rnoInnerhtml = /&lt;(?:script|style)/i,
</a><a name="line-7773" data-line="7773">	rnocache = /&lt;(?:script|object|embed|option|style)/i,
</a><a name="line-7774" data-line="7774">	rnoshimcache = new RegExp(&quot;&lt;(?:&quot; + nodeNames + &quot;)[\\s/&gt;]&quot;, &quot;i&quot;),
</a><a name="line-7775" data-line="7775">	// checked=&quot;checked&quot; or checked
</a><a name="line-7776" data-line="7776">	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
</a><a name="line-7777" data-line="7777">	rscriptType = /\/(java|ecma)script/i,
</a><a name="line-7778" data-line="7778">	rcleanScript = /^\s*&lt;!(?:\[CDATA\[|\-\-)/,
</a><a name="line-7779" data-line="7779">	wrapMap = {
</a><a name="line-7780" data-line="7780">		option: [ 1, &quot;&lt;select multiple='multiple'&gt;&quot;, &quot;&lt;/select&gt;&quot; ],
</a><a name="line-7781" data-line="7781">		legend: [ 1, &quot;&lt;fieldset&gt;&quot;, &quot;&lt;/fieldset&gt;&quot; ],
</a><a name="line-7782" data-line="7782">		thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
</a><a name="line-7783" data-line="7783">		tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
</a><a name="line-7784" data-line="7784">		td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
</a><a name="line-7785" data-line="7785">		col: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
</a><a name="line-7786" data-line="7786">		area: [ 1, &quot;&lt;map&gt;&quot;, &quot;&lt;/map&gt;&quot; ],
</a><a name="line-7787" data-line="7787">		_default: [ 0, &quot;&quot;, &quot;&quot; ]
</a><a name="line-7788" data-line="7788">	},
</a><a name="line-7789" data-line="7789">	safeFragment = createSafeFragment( document );
</a><a name="line-7790" data-line="7790">
</a><a name="line-7791" data-line="7791">wrapMap.optgroup = wrapMap.option;
</a><a name="line-7792" data-line="7792">wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
</a><a name="line-7793" data-line="7793">wrapMap.th = wrapMap.td;
</a><a name="line-7794" data-line="7794">
</a><a name="line-7795" data-line="7795">// IE can't serialize &lt;link&gt; and &lt;script&gt; tags normally
</a><a name="line-7796" data-line="7796">if ( !jQuery.support.htmlSerialize ) {
</a><a name="line-7797" data-line="7797">	wrapMap._default = [ 1, &quot;div&lt;div&gt;&quot;, &quot;&lt;/div&gt;&quot; ];
</a><a name="line-7798" data-line="7798">}
</a><a name="line-7799" data-line="7799">
</a><a name="line-7800" data-line="7800">jQuery.fn.extend({
</a><a name="line-7801" data-line="7801">	text: function( value ) {
</a><a name="line-7802" data-line="7802">		return jQuery.access( this, function( value ) {
</a><a name="line-7803" data-line="7803">			return value === undefined ?
</a><a name="line-7804" data-line="7804">				jQuery.text( this ) :
</a><a name="line-7805" data-line="7805">				this.empty().append( ( this[0] &amp;&amp; this[0].ownerDocument || document ).createTextNode( value ) );
</a><a name="line-7806" data-line="7806">		}, null, value, arguments.length );
</a><a name="line-7807" data-line="7807">	},
</a><a name="line-7808" data-line="7808">
</a><a name="line-7809" data-line="7809">	wrapAll: function( html ) {
</a><a name="line-7810" data-line="7810">		if ( jQuery.isFunction( html ) ) {
</a><a name="line-7811" data-line="7811">			return this.each(function(i) {
</a><a name="line-7812" data-line="7812">				jQuery(this).wrapAll( html.call(this, i) );
</a><a name="line-7813" data-line="7813">			});
</a><a name="line-7814" data-line="7814">		}
</a><a name="line-7815" data-line="7815">
</a><a name="line-7816" data-line="7816">		if ( this[0] ) {
</a><a name="line-7817" data-line="7817">			// The elements to wrap the target around
</a><a name="line-7818" data-line="7818">			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);
</a><a name="line-7819" data-line="7819">
</a><a name="line-7820" data-line="7820">			if ( this[0].parentNode ) {
</a><a name="line-7821" data-line="7821">				wrap.insertBefore( this[0] );
</a><a name="line-7822" data-line="7822">			}
</a><a name="line-7823" data-line="7823">
</a><a name="line-7824" data-line="7824">			wrap.map(function() {
</a><a name="line-7825" data-line="7825">				var elem = this;
</a><a name="line-7826" data-line="7826">
</a><a name="line-7827" data-line="7827">				while ( elem.firstChild &amp;&amp; elem.firstChild.nodeType === 1 ) {
</a><a name="line-7828" data-line="7828">					elem = elem.firstChild;
</a><a name="line-7829" data-line="7829">				}
</a><a name="line-7830" data-line="7830">
</a><a name="line-7831" data-line="7831">				return elem;
</a><a name="line-7832" data-line="7832">			}).append( this );
</a><a name="line-7833" data-line="7833">		}
</a><a name="line-7834" data-line="7834">
</a><a name="line-7835" data-line="7835">		return this;
</a><a name="line-7836" data-line="7836">	},
</a><a name="line-7837" data-line="7837">
</a><a name="line-7838" data-line="7838">	wrapInner: function( html ) {
</a><a name="line-7839" data-line="7839">		if ( jQuery.isFunction( html ) ) {
</a><a name="line-7840" data-line="7840">			return this.each(function(i) {
</a><a name="line-7841" data-line="7841">				jQuery(this).wrapInner( html.call(this, i) );
</a><a name="line-7842" data-line="7842">			});
</a><a name="line-7843" data-line="7843">		}
</a><a name="line-7844" data-line="7844">
</a><a name="line-7845" data-line="7845">		return this.each(function() {
</a><a name="line-7846" data-line="7846">			var self = jQuery( this ),
</a><a name="line-7847" data-line="7847">				contents = self.contents();
</a><a name="line-7848" data-line="7848">
</a><a name="line-7849" data-line="7849">			if ( contents.length ) {
</a><a name="line-7850" data-line="7850">				contents.wrapAll( html );
</a><a name="line-7851" data-line="7851">
</a><a name="line-7852" data-line="7852">			} else {
</a><a name="line-7853" data-line="7853">				self.append( html );
</a><a name="line-7854" data-line="7854">			}
</a><a name="line-7855" data-line="7855">		});
</a><a name="line-7856" data-line="7856">	},
</a><a name="line-7857" data-line="7857">
</a><a name="line-7858" data-line="7858">	wrap: function( html ) {
</a><a name="line-7859" data-line="7859">		var isFunction = jQuery.isFunction( html );
</a><a name="line-7860" data-line="7860">
</a><a name="line-7861" data-line="7861">		return this.each(function(i) {
</a><a name="line-7862" data-line="7862">			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
</a><a name="line-7863" data-line="7863">		});
</a><a name="line-7864" data-line="7864">	},
</a><a name="line-7865" data-line="7865">
</a><a name="line-7866" data-line="7866">	unwrap: function() {
</a><a name="line-7867" data-line="7867">		return this.parent().each(function() {
</a><a name="line-7868" data-line="7868">			if ( !jQuery.nodeName( this, &quot;body&quot; ) ) {
</a><a name="line-7869" data-line="7869">				jQuery( this ).replaceWith( this.childNodes );
</a><a name="line-7870" data-line="7870">			}
</a><a name="line-7871" data-line="7871">		}).end();
</a><a name="line-7872" data-line="7872">	},
</a><a name="line-7873" data-line="7873">
</a><a name="line-7874" data-line="7874">	append: function() {
</a><a name="line-7875" data-line="7875">		return this.domManip(arguments, true, function( elem ) {
</a><a name="line-7876" data-line="7876">			if ( this.nodeType === 1 ) {
</a><a name="line-7877" data-line="7877">				this.appendChild( elem );
</a><a name="line-7878" data-line="7878">			}
</a><a name="line-7879" data-line="7879">		});
</a><a name="line-7880" data-line="7880">	},
</a><a name="line-7881" data-line="7881">
</a><a name="line-7882" data-line="7882">	prepend: function() {
</a><a name="line-7883" data-line="7883">		return this.domManip(arguments, true, function( elem ) {
</a><a name="line-7884" data-line="7884">			if ( this.nodeType === 1 ) {
</a><a name="line-7885" data-line="7885">				this.insertBefore( elem, this.firstChild );
</a><a name="line-7886" data-line="7886">			}
</a><a name="line-7887" data-line="7887">		});
</a><a name="line-7888" data-line="7888">	},
</a><a name="line-7889" data-line="7889">
</a><a name="line-7890" data-line="7890">	before: function() {
</a><a name="line-7891" data-line="7891">		if ( this[0] &amp;&amp; this[0].parentNode ) {
</a><a name="line-7892" data-line="7892">			return this.domManip(arguments, false, function( elem ) {
</a><a name="line-7893" data-line="7893">				this.parentNode.insertBefore( elem, this );
</a><a name="line-7894" data-line="7894">			});
</a><a name="line-7895" data-line="7895">		} else if ( arguments.length ) {
</a><a name="line-7896" data-line="7896">			var set = jQuery.clean( arguments );
</a><a name="line-7897" data-line="7897">			set.push.apply( set, this.toArray() );
</a><a name="line-7898" data-line="7898">			return this.pushStack( set, &quot;before&quot;, arguments );
</a><a name="line-7899" data-line="7899">		}
</a><a name="line-7900" data-line="7900">	},
</a><a name="line-7901" data-line="7901">
</a><a name="line-7902" data-line="7902">	after: function() {
</a><a name="line-7903" data-line="7903">		if ( this[0] &amp;&amp; this[0].parentNode ) {
</a><a name="line-7904" data-line="7904">			return this.domManip(arguments, false, function( elem ) {
</a><a name="line-7905" data-line="7905">				this.parentNode.insertBefore( elem, this.nextSibling );
</a><a name="line-7906" data-line="7906">			});
</a><a name="line-7907" data-line="7907">		} else if ( arguments.length ) {
</a><a name="line-7908" data-line="7908">			var set = this.pushStack( this, &quot;after&quot;, arguments );
</a><a name="line-7909" data-line="7909">			set.push.apply( set, jQuery.clean(arguments) );
</a><a name="line-7910" data-line="7910">			return set;
</a><a name="line-7911" data-line="7911">		}
</a><a name="line-7912" data-line="7912">	},
</a><a name="line-7913" data-line="7913">
</a><a name="line-7914" data-line="7914">	// keepData is for internal use only--do not document
</a><a name="line-7915" data-line="7915">	remove: function( selector, keepData ) {
</a><a name="line-7916" data-line="7916">		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
</a><a name="line-7917" data-line="7917">			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
</a><a name="line-7918" data-line="7918">				if ( !keepData &amp;&amp; elem.nodeType === 1 ) {
</a><a name="line-7919" data-line="7919">					jQuery.cleanData( elem.getElementsByTagName(&quot;*&quot;) );
</a><a name="line-7920" data-line="7920">					jQuery.cleanData( [ elem ] );
</a><a name="line-7921" data-line="7921">				}
</a><a name="line-7922" data-line="7922">
</a><a name="line-7923" data-line="7923">				if ( elem.parentNode ) {
</a><a name="line-7924" data-line="7924">					elem.parentNode.removeChild( elem );
</a><a name="line-7925" data-line="7925">				}
</a><a name="line-7926" data-line="7926">			}
</a><a name="line-7927" data-line="7927">		}
</a><a name="line-7928" data-line="7928">
</a><a name="line-7929" data-line="7929">		return this;
</a><a name="line-7930" data-line="7930">	},
</a><a name="line-7931" data-line="7931">
</a><a name="line-7932" data-line="7932">	empty: function() {
</a><a name="line-7933" data-line="7933">		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
</a><a name="line-7934" data-line="7934">			// Remove element nodes and prevent memory leaks
</a><a name="line-7935" data-line="7935">			if ( elem.nodeType === 1 ) {
</a><a name="line-7936" data-line="7936">				jQuery.cleanData( elem.getElementsByTagName(&quot;*&quot;) );
</a><a name="line-7937" data-line="7937">			}
</a><a name="line-7938" data-line="7938">
</a><a name="line-7939" data-line="7939">			// Remove any remaining nodes
</a><a name="line-7940" data-line="7940">			while ( elem.firstChild ) {
</a><a name="line-7941" data-line="7941">				elem.removeChild( elem.firstChild );
</a><a name="line-7942" data-line="7942">			}
</a><a name="line-7943" data-line="7943">		}
</a><a name="line-7944" data-line="7944">
</a><a name="line-7945" data-line="7945">		return this;
</a><a name="line-7946" data-line="7946">	},
</a><a name="line-7947" data-line="7947">
</a><a name="line-7948" data-line="7948">	clone: function( dataAndEvents, deepDataAndEvents ) {
</a><a name="line-7949" data-line="7949">		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
</a><a name="line-7950" data-line="7950">		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
</a><a name="line-7951" data-line="7951">
</a><a name="line-7952" data-line="7952">		return this.map( function () {
</a><a name="line-7953" data-line="7953">			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
</a><a name="line-7954" data-line="7954">		});
</a><a name="line-7955" data-line="7955">	},
</a><a name="line-7956" data-line="7956">
</a><a name="line-7957" data-line="7957">	html: function( value ) {
</a><a name="line-7958" data-line="7958">		return jQuery.access( this, function( value ) {
</a><a name="line-7959" data-line="7959">			var elem = this[0] || {},
</a><a name="line-7960" data-line="7960">				i = 0,
</a><a name="line-7961" data-line="7961">				l = this.length;
</a><a name="line-7962" data-line="7962">
</a><a name="line-7963" data-line="7963">			if ( value === undefined ) {
</a><a name="line-7964" data-line="7964">				return elem.nodeType === 1 ?
</a><a name="line-7965" data-line="7965">					elem.innerHTML.replace( rinlinejQuery, &quot;&quot; ) :
</a><a name="line-7966" data-line="7966">					null;
</a><a name="line-7967" data-line="7967">			}
</a><a name="line-7968" data-line="7968">
</a><a name="line-7969" data-line="7969">
</a><a name="line-7970" data-line="7970">			if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
</a><a name="line-7971" data-line="7971">				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &amp;&amp;
</a><a name="line-7972" data-line="7972">				!wrapMap[ ( rtagName.exec( value ) || [&quot;&quot;, &quot;&quot;] )[1].toLowerCase() ] ) {
</a><a name="line-7973" data-line="7973">
</a><a name="line-7974" data-line="7974">				value = value.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );
</a><a name="line-7975" data-line="7975">
</a><a name="line-7976" data-line="7976">				try {
</a><a name="line-7977" data-line="7977">					for (; i &lt; l; i++ ) {
</a><a name="line-7978" data-line="7978">						// Remove element nodes and prevent memory leaks
</a><a name="line-7979" data-line="7979">						elem = this[i] || {};
</a><a name="line-7980" data-line="7980">						if ( elem.nodeType === 1 ) {
</a><a name="line-7981" data-line="7981">							jQuery.cleanData( elem.getElementsByTagName( &quot;*&quot; ) );
</a><a name="line-7982" data-line="7982">							elem.innerHTML = value;
</a><a name="line-7983" data-line="7983">						}
</a><a name="line-7984" data-line="7984">					}
</a><a name="line-7985" data-line="7985">
</a><a name="line-7986" data-line="7986">					elem = 0;
</a><a name="line-7987" data-line="7987">
</a><a name="line-7988" data-line="7988">				// If using innerHTML throws an exception, use the fallback method
</a><a name="line-7989" data-line="7989">				} catch(e) {}
</a><a name="line-7990" data-line="7990">			}
</a><a name="line-7991" data-line="7991">
</a><a name="line-7992" data-line="7992">			if ( elem ) {
</a><a name="line-7993" data-line="7993">				this.empty().append( value );
</a><a name="line-7994" data-line="7994">			}
</a><a name="line-7995" data-line="7995">		}, null, value, arguments.length );
</a><a name="line-7996" data-line="7996">	},
</a><a name="line-7997" data-line="7997">
</a><a name="line-7998" data-line="7998">	replaceWith: function( value ) {
</a><a name="line-7999" data-line="7999">		if ( this[0] &amp;&amp; this[0].parentNode ) {
</a><a name="line-8000" data-line="8000">			// Make sure that the elements are removed from the DOM before they are inserted
</a><a name="line-8001" data-line="8001">			// this can help fix replacing a parent with child elements
</a><a name="line-8002" data-line="8002">			if ( jQuery.isFunction( value ) ) {
</a><a name="line-8003" data-line="8003">				return this.each(function(i) {
</a><a name="line-8004" data-line="8004">					var self = jQuery(this), old = self.html();
</a><a name="line-8005" data-line="8005">					self.replaceWith( value.call( this, i, old ) );
</a><a name="line-8006" data-line="8006">				});
</a><a name="line-8007" data-line="8007">			}
</a><a name="line-8008" data-line="8008">
</a><a name="line-8009" data-line="8009">			if ( typeof value !== &quot;string&quot; ) {
</a><a name="line-8010" data-line="8010">				value = jQuery( value ).detach();
</a><a name="line-8011" data-line="8011">			}
</a><a name="line-8012" data-line="8012">
</a><a name="line-8013" data-line="8013">			return this.each(function() {
</a><a name="line-8014" data-line="8014">				var next = this.nextSibling,
</a><a name="line-8015" data-line="8015">					parent = this.parentNode;
</a><a name="line-8016" data-line="8016">
</a><a name="line-8017" data-line="8017">				jQuery( this ).remove();
</a><a name="line-8018" data-line="8018">
</a><a name="line-8019" data-line="8019">				if ( next ) {
</a><a name="line-8020" data-line="8020">					jQuery(next).before( value );
</a><a name="line-8021" data-line="8021">				} else {
</a><a name="line-8022" data-line="8022">					jQuery(parent).append( value );
</a><a name="line-8023" data-line="8023">				}
</a><a name="line-8024" data-line="8024">			});
</a><a name="line-8025" data-line="8025">		} else {
</a><a name="line-8026" data-line="8026">			return this.length ?
</a><a name="line-8027" data-line="8027">				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), &quot;replaceWith&quot;, value ) :
</a><a name="line-8028" data-line="8028">				this;
</a><a name="line-8029" data-line="8029">		}
</a><a name="line-8030" data-line="8030">	},
</a><a name="line-8031" data-line="8031">
</a><a name="line-8032" data-line="8032">	detach: function( selector ) {
</a><a name="line-8033" data-line="8033">		return this.remove( selector, true );
</a><a name="line-8034" data-line="8034">	},
</a><a name="line-8035" data-line="8035">
</a><a name="line-8036" data-line="8036">	domManip: function( args, table, callback ) {
</a><a name="line-8037" data-line="8037">		var results, first, fragment, parent,
</a><a name="line-8038" data-line="8038">			value = args[0],
</a><a name="line-8039" data-line="8039">			scripts = [];
</a><a name="line-8040" data-line="8040">
</a><a name="line-8041" data-line="8041">		// We can't cloneNode fragments that contain checked, in WebKit
</a><a name="line-8042" data-line="8042">		if ( !jQuery.support.checkClone &amp;&amp; arguments.length === 3 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp; rchecked.test( value ) ) {
</a><a name="line-8043" data-line="8043">			return this.each(function() {
</a><a name="line-8044" data-line="8044">				jQuery(this).domManip( args, table, callback, true );
</a><a name="line-8045" data-line="8045">			});
</a><a name="line-8046" data-line="8046">		}
</a><a name="line-8047" data-line="8047">
</a><a name="line-8048" data-line="8048">		if ( jQuery.isFunction(value) ) {
</a><a name="line-8049" data-line="8049">			return this.each(function(i) {
</a><a name="line-8050" data-line="8050">				var self = jQuery(this);
</a><a name="line-8051" data-line="8051">				args[0] = value.call(this, i, table ? self.html() : undefined);
</a><a name="line-8052" data-line="8052">				self.domManip( args, table, callback );
</a><a name="line-8053" data-line="8053">			});
</a><a name="line-8054" data-line="8054">		}
</a><a name="line-8055" data-line="8055">
</a><a name="line-8056" data-line="8056">		if ( this[0] ) {
</a><a name="line-8057" data-line="8057">			parent = value &amp;&amp; value.parentNode;
</a><a name="line-8058" data-line="8058">
</a><a name="line-8059" data-line="8059">			// If we're in a fragment, just use that instead of building a new one
</a><a name="line-8060" data-line="8060">			if ( jQuery.support.parentNode &amp;&amp; parent &amp;&amp; parent.nodeType === 11 &amp;&amp; parent.childNodes.length === this.length ) {
</a><a name="line-8061" data-line="8061">				results = { fragment: parent };
</a><a name="line-8062" data-line="8062">
</a><a name="line-8063" data-line="8063">			} else {
</a><a name="line-8064" data-line="8064">				results = jQuery.buildFragment( args, this, scripts );
</a><a name="line-8065" data-line="8065">			}
</a><a name="line-8066" data-line="8066">
</a><a name="line-8067" data-line="8067">			fragment = results.fragment;
</a><a name="line-8068" data-line="8068">
</a><a name="line-8069" data-line="8069">			if ( fragment.childNodes.length === 1 ) {
</a><a name="line-8070" data-line="8070">				first = fragment = fragment.firstChild;
</a><a name="line-8071" data-line="8071">			} else {
</a><a name="line-8072" data-line="8072">				first = fragment.firstChild;
</a><a name="line-8073" data-line="8073">			}
</a><a name="line-8074" data-line="8074">
</a><a name="line-8075" data-line="8075">			if ( first ) {
</a><a name="line-8076" data-line="8076">				table = table &amp;&amp; jQuery.nodeName( first, &quot;tr&quot; );
</a><a name="line-8077" data-line="8077">
</a><a name="line-8078" data-line="8078">				for ( var i = 0, l = this.length, lastIndex = l - 1; i &lt; l; i++ ) {
</a><a name="line-8079" data-line="8079">					callback.call(
</a><a name="line-8080" data-line="8080">						table ?
</a><a name="line-8081" data-line="8081">							root(this[i], first) :
</a><a name="line-8082" data-line="8082">							this[i],
</a><a name="line-8083" data-line="8083">						// Make sure that we do not leak memory by inadvertently discarding
</a><a name="line-8084" data-line="8084">						// the original fragment (which might have attached data) instead of
</a><a name="line-8085" data-line="8085">						// using it; in addition, use the original fragment object for the last
</a><a name="line-8086" data-line="8086">						// item instead of first because it can end up being emptied incorrectly
</a><a name="line-8087" data-line="8087">						// in certain situations (Bug #8070).
</a><a name="line-8088" data-line="8088">						// Fragments from the fragment cache must always be cloned and never used
</a><a name="line-8089" data-line="8089">						// in place.
</a><a name="line-8090" data-line="8090">						results.cacheable || ( l &gt; 1 &amp;&amp; i &lt; lastIndex ) ?
</a><a name="line-8091" data-line="8091">							jQuery.clone( fragment, true, true ) :
</a><a name="line-8092" data-line="8092">							fragment
</a><a name="line-8093" data-line="8093">					);
</a><a name="line-8094" data-line="8094">				}
</a><a name="line-8095" data-line="8095">			}
</a><a name="line-8096" data-line="8096">
</a><a name="line-8097" data-line="8097">			if ( scripts.length ) {
</a><a name="line-8098" data-line="8098">				jQuery.each( scripts, function( i, elem ) {
</a><a name="line-8099" data-line="8099">					if ( elem.src ) {
</a><a name="line-8100" data-line="8100">						jQuery.ajax({
</a><a name="line-8101" data-line="8101">							type: &quot;GET&quot;,
</a><a name="line-8102" data-line="8102">							global: false,
</a><a name="line-8103" data-line="8103">							url: elem.src,
</a><a name="line-8104" data-line="8104">							async: false,
</a><a name="line-8105" data-line="8105">							dataType: &quot;script&quot;
</a><a name="line-8106" data-line="8106">						});
</a><a name="line-8107" data-line="8107">					} else {
</a><a name="line-8108" data-line="8108">						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || &quot;&quot; ).replace( rcleanScript, &quot;/*$0*/&quot; ) );
</a><a name="line-8109" data-line="8109">					}
</a><a name="line-8110" data-line="8110">
</a><a name="line-8111" data-line="8111">					if ( elem.parentNode ) {
</a><a name="line-8112" data-line="8112">						elem.parentNode.removeChild( elem );
</a><a name="line-8113" data-line="8113">					}
</a><a name="line-8114" data-line="8114">				});
</a><a name="line-8115" data-line="8115">			}
</a><a name="line-8116" data-line="8116">		}
</a><a name="line-8117" data-line="8117">
</a><a name="line-8118" data-line="8118">		return this;
</a><a name="line-8119" data-line="8119">	}
</a><a name="line-8120" data-line="8120">});
</a><a name="line-8121" data-line="8121">
</a><a name="line-8122" data-line="8122">function root( elem, cur ) {
</a><a name="line-8123" data-line="8123">	return jQuery.nodeName(elem, &quot;table&quot;) ?
</a><a name="line-8124" data-line="8124">		(elem.getElementsByTagName(&quot;tbody&quot;)[0] ||
</a><a name="line-8125" data-line="8125">		elem.appendChild(elem.ownerDocument.createElement(&quot;tbody&quot;))) :
</a><a name="line-8126" data-line="8126">		elem;
</a><a name="line-8127" data-line="8127">}
</a><a name="line-8128" data-line="8128">
</a><a name="line-8129" data-line="8129">function cloneCopyEvent( src, dest ) {
</a><a name="line-8130" data-line="8130">
</a><a name="line-8131" data-line="8131">	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
</a><a name="line-8132" data-line="8132">		return;
</a><a name="line-8133" data-line="8133">	}
</a><a name="line-8134" data-line="8134">
</a><a name="line-8135" data-line="8135">	var type, i, l,
</a><a name="line-8136" data-line="8136">		oldData = jQuery._data( src ),
</a><a name="line-8137" data-line="8137">		curData = jQuery._data( dest, oldData ),
</a><a name="line-8138" data-line="8138">		events = oldData.events;
</a><a name="line-8139" data-line="8139">
</a><a name="line-8140" data-line="8140">	if ( events ) {
</a><a name="line-8141" data-line="8141">		delete curData.handle;
</a><a name="line-8142" data-line="8142">		curData.events = {};
</a><a name="line-8143" data-line="8143">
</a><a name="line-8144" data-line="8144">		for ( type in events ) {
</a><a name="line-8145" data-line="8145">			for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
</a><a name="line-8146" data-line="8146">				jQuery.event.add( dest, type, events[ type ][ i ] );
</a><a name="line-8147" data-line="8147">			}
</a><a name="line-8148" data-line="8148">		}
</a><a name="line-8149" data-line="8149">	}
</a><a name="line-8150" data-line="8150">
</a><a name="line-8151" data-line="8151">	// make the cloned public data object a copy from the original
</a><a name="line-8152" data-line="8152">	if ( curData.data ) {
</a><a name="line-8153" data-line="8153">		curData.data = jQuery.extend( {}, curData.data );
</a><a name="line-8154" data-line="8154">	}
</a><a name="line-8155" data-line="8155">}
</a><a name="line-8156" data-line="8156">
</a><a name="line-8157" data-line="8157">function cloneFixAttributes( src, dest ) {
</a><a name="line-8158" data-line="8158">	var nodeName;
</a><a name="line-8159" data-line="8159">
</a><a name="line-8160" data-line="8160">	// We do not need to do anything for non-Elements
</a><a name="line-8161" data-line="8161">	if ( dest.nodeType !== 1 ) {
</a><a name="line-8162" data-line="8162">		return;
</a><a name="line-8163" data-line="8163">	}
</a><a name="line-8164" data-line="8164">
</a><a name="line-8165" data-line="8165">	// clearAttributes removes the attributes, which we don't want,
</a><a name="line-8166" data-line="8166">	// but also removes the attachEvent events, which we *do* want
</a><a name="line-8167" data-line="8167">	if ( dest.clearAttributes ) {
</a><a name="line-8168" data-line="8168">		dest.clearAttributes();
</a><a name="line-8169" data-line="8169">	}
</a><a name="line-8170" data-line="8170">
</a><a name="line-8171" data-line="8171">	// mergeAttributes, in contrast, only merges back on the
</a><a name="line-8172" data-line="8172">	// original attributes, not the events
</a><a name="line-8173" data-line="8173">	if ( dest.mergeAttributes ) {
</a><a name="line-8174" data-line="8174">		dest.mergeAttributes( src );
</a><a name="line-8175" data-line="8175">	}
</a><a name="line-8176" data-line="8176">
</a><a name="line-8177" data-line="8177">	nodeName = dest.nodeName.toLowerCase();
</a><a name="line-8178" data-line="8178">
</a><a name="line-8179" data-line="8179">	// IE6-8 fail to clone children inside object elements that use
</a><a name="line-8180" data-line="8180">	// the proprietary classid attribute value (rather than the type
</a><a name="line-8181" data-line="8181">	// attribute) to identify the type of content to display
</a><a name="line-8182" data-line="8182">	if ( nodeName === &quot;object&quot; ) {
</a><a name="line-8183" data-line="8183">		dest.outerHTML = src.outerHTML;
</a><a name="line-8184" data-line="8184">
</a><a name="line-8185" data-line="8185">	} else if ( nodeName === &quot;input&quot; &amp;&amp; (src.type === &quot;checkbox&quot; || src.type === &quot;radio&quot;) ) {
</a><a name="line-8186" data-line="8186">		// IE6-8 fails to persist the checked state of a cloned checkbox
</a><a name="line-8187" data-line="8187">		// or radio button. Worse, IE6-7 fail to give the cloned element
</a><a name="line-8188" data-line="8188">		// a checked appearance if the defaultChecked value isn't also set
</a><a name="line-8189" data-line="8189">		if ( src.checked ) {
</a><a name="line-8190" data-line="8190">			dest.defaultChecked = dest.checked = src.checked;
</a><a name="line-8191" data-line="8191">		}
</a><a name="line-8192" data-line="8192">
</a><a name="line-8193" data-line="8193">		// IE6-7 get confused and end up setting the value of a cloned
</a><a name="line-8194" data-line="8194">		// checkbox/radio button to an empty string instead of &quot;on&quot;
</a><a name="line-8195" data-line="8195">		if ( dest.value !== src.value ) {
</a><a name="line-8196" data-line="8196">			dest.value = src.value;
</a><a name="line-8197" data-line="8197">		}
</a><a name="line-8198" data-line="8198">
</a><a name="line-8199" data-line="8199">	// IE6-8 fails to return the selected option to the default selected
</a><a name="line-8200" data-line="8200">	// state when cloning options
</a><a name="line-8201" data-line="8201">	} else if ( nodeName === &quot;option&quot; ) {
</a><a name="line-8202" data-line="8202">		dest.selected = src.defaultSelected;
</a><a name="line-8203" data-line="8203">
</a><a name="line-8204" data-line="8204">	// IE6-8 fails to set the defaultValue to the correct value when
</a><a name="line-8205" data-line="8205">	// cloning other types of input fields
</a><a name="line-8206" data-line="8206">	} else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
</a><a name="line-8207" data-line="8207">		dest.defaultValue = src.defaultValue;
</a><a name="line-8208" data-line="8208">
</a><a name="line-8209" data-line="8209">	// IE blanks contents when cloning scripts
</a><a name="line-8210" data-line="8210">	} else if ( nodeName === &quot;script&quot; &amp;&amp; dest.text !== src.text ) {
</a><a name="line-8211" data-line="8211">		dest.text = src.text;
</a><a name="line-8212" data-line="8212">	}
</a><a name="line-8213" data-line="8213">
</a><a name="line-8214" data-line="8214">	// Event data gets referenced instead of copied if the expando
</a><a name="line-8215" data-line="8215">	// gets copied too
</a><a name="line-8216" data-line="8216">	dest.removeAttribute( jQuery.expando );
</a><a name="line-8217" data-line="8217">
</a><a name="line-8218" data-line="8218">	// Clear flags for bubbling special change/submit events, they must
</a><a name="line-8219" data-line="8219">	// be reattached when the newly cloned events are first activated
</a><a name="line-8220" data-line="8220">	dest.removeAttribute( &quot;_submit_attached&quot; );
</a><a name="line-8221" data-line="8221">	dest.removeAttribute( &quot;_change_attached&quot; );
</a><a name="line-8222" data-line="8222">}
</a><a name="line-8223" data-line="8223">
</a><a name="line-8224" data-line="8224">jQuery.buildFragment = function( args, nodes, scripts ) {
</a><a name="line-8225" data-line="8225">	var fragment, cacheable, cacheresults, doc,
</a><a name="line-8226" data-line="8226">	first = args[ 0 ];
</a><a name="line-8227" data-line="8227">
</a><a name="line-8228" data-line="8228">	// nodes may contain either an explicit document object,
</a><a name="line-8229" data-line="8229">	// a jQuery collection or context object.
</a><a name="line-8230" data-line="8230">	// If nodes[0] contains a valid object to assign to doc
</a><a name="line-8231" data-line="8231">	if ( nodes &amp;&amp; nodes[0] ) {
</a><a name="line-8232" data-line="8232">		doc = nodes[0].ownerDocument || nodes[0];
</a><a name="line-8233" data-line="8233">	}
</a><a name="line-8234" data-line="8234">
</a><a name="line-8235" data-line="8235">	// Ensure that an attr object doesn't incorrectly stand in as a document object
</a><a name="line-8236" data-line="8236">	// Chrome and Firefox seem to allow this to occur and will throw exception
</a><a name="line-8237" data-line="8237">	// Fixes #8950
</a><a name="line-8238" data-line="8238">	if ( !doc.createDocumentFragment ) {
</a><a name="line-8239" data-line="8239">		doc = document;
</a><a name="line-8240" data-line="8240">	}
</a><a name="line-8241" data-line="8241">
</a><a name="line-8242" data-line="8242">	// Only cache &quot;small&quot; (1/2 KB) HTML strings that are associated with the main document
</a><a name="line-8243" data-line="8243">	// Cloning options loses the selected state, so don't cache them
</a><a name="line-8244" data-line="8244">	// IE 6 doesn't like it when you put &lt;object&gt; or &lt;embed&gt; elements in a fragment
</a><a name="line-8245" data-line="8245">	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
</a><a name="line-8246" data-line="8246">	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
</a><a name="line-8247" data-line="8247">	if ( args.length === 1 &amp;&amp; typeof first === &quot;string&quot; &amp;&amp; first.length &lt; 512 &amp;&amp; doc === document &amp;&amp;
</a><a name="line-8248" data-line="8248">		first.charAt(0) === &quot;&lt;&quot; &amp;&amp; !rnocache.test( first ) &amp;&amp;
</a><a name="line-8249" data-line="8249">		(jQuery.support.checkClone || !rchecked.test( first )) &amp;&amp;
</a><a name="line-8250" data-line="8250">		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {
</a><a name="line-8251" data-line="8251">
</a><a name="line-8252" data-line="8252">		cacheable = true;
</a><a name="line-8253" data-line="8253">
</a><a name="line-8254" data-line="8254">		cacheresults = jQuery.fragments[ first ];
</a><a name="line-8255" data-line="8255">		if ( cacheresults &amp;&amp; cacheresults !== 1 ) {
</a><a name="line-8256" data-line="8256">			fragment = cacheresults;
</a><a name="line-8257" data-line="8257">		}
</a><a name="line-8258" data-line="8258">	}
</a><a name="line-8259" data-line="8259">
</a><a name="line-8260" data-line="8260">	if ( !fragment ) {
</a><a name="line-8261" data-line="8261">		fragment = doc.createDocumentFragment();
</a><a name="line-8262" data-line="8262">		jQuery.clean( args, doc, fragment, scripts );
</a><a name="line-8263" data-line="8263">	}
</a><a name="line-8264" data-line="8264">
</a><a name="line-8265" data-line="8265">	if ( cacheable ) {
</a><a name="line-8266" data-line="8266">		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
</a><a name="line-8267" data-line="8267">	}
</a><a name="line-8268" data-line="8268">
</a><a name="line-8269" data-line="8269">	return { fragment: fragment, cacheable: cacheable };
</a><a name="line-8270" data-line="8270">};
</a><a name="line-8271" data-line="8271">
</a><a name="line-8272" data-line="8272">jQuery.fragments = {};
</a><a name="line-8273" data-line="8273">
</a><a name="line-8274" data-line="8274">jQuery.each({
</a><a name="line-8275" data-line="8275">	appendTo: &quot;append&quot;,
</a><a name="line-8276" data-line="8276">	prependTo: &quot;prepend&quot;,
</a><a name="line-8277" data-line="8277">	insertBefore: &quot;before&quot;,
</a><a name="line-8278" data-line="8278">	insertAfter: &quot;after&quot;,
</a><a name="line-8279" data-line="8279">	replaceAll: &quot;replaceWith&quot;
</a><a name="line-8280" data-line="8280">}, function( name, original ) {
</a><a name="line-8281" data-line="8281">	jQuery.fn[ name ] = function( selector ) {
</a><a name="line-8282" data-line="8282">		var ret = [],
</a><a name="line-8283" data-line="8283">			insert = jQuery( selector ),
</a><a name="line-8284" data-line="8284">			parent = this.length === 1 &amp;&amp; this[0].parentNode;
</a><a name="line-8285" data-line="8285">
</a><a name="line-8286" data-line="8286">		if ( parent &amp;&amp; parent.nodeType === 11 &amp;&amp; parent.childNodes.length === 1 &amp;&amp; insert.length === 1 ) {
</a><a name="line-8287" data-line="8287">			insert[ original ]( this[0] );
</a><a name="line-8288" data-line="8288">			return this;
</a><a name="line-8289" data-line="8289">
</a><a name="line-8290" data-line="8290">		} else {
</a><a name="line-8291" data-line="8291">			for ( var i = 0, l = insert.length; i &lt; l; i++ ) {
</a><a name="line-8292" data-line="8292">				var elems = ( i &gt; 0 ? this.clone(true) : this ).get();
</a><a name="line-8293" data-line="8293">				jQuery( insert[i] )[ original ]( elems );
</a><a name="line-8294" data-line="8294">				ret = ret.concat( elems );
</a><a name="line-8295" data-line="8295">			}
</a><a name="line-8296" data-line="8296">
</a><a name="line-8297" data-line="8297">			return this.pushStack( ret, name, insert.selector );
</a><a name="line-8298" data-line="8298">		}
</a><a name="line-8299" data-line="8299">	};
</a><a name="line-8300" data-line="8300">});
</a><a name="line-8301" data-line="8301">
</a><a name="line-8302" data-line="8302">function getAll( elem ) {
</a><a name="line-8303" data-line="8303">	if ( typeof elem.getElementsByTagName !== &quot;undefined&quot; ) {
</a><a name="line-8304" data-line="8304">		return elem.getElementsByTagName( &quot;*&quot; );
</a><a name="line-8305" data-line="8305">
</a><a name="line-8306" data-line="8306">	} else if ( typeof elem.querySelectorAll !== &quot;undefined&quot; ) {
</a><a name="line-8307" data-line="8307">		return elem.querySelectorAll( &quot;*&quot; );
</a><a name="line-8308" data-line="8308">
</a><a name="line-8309" data-line="8309">	} else {
</a><a name="line-8310" data-line="8310">		return [];
</a><a name="line-8311" data-line="8311">	}
</a><a name="line-8312" data-line="8312">}
</a><a name="line-8313" data-line="8313">
</a><a name="line-8314" data-line="8314">// Used in clean, fixes the defaultChecked property
</a><a name="line-8315" data-line="8315">function fixDefaultChecked( elem ) {
</a><a name="line-8316" data-line="8316">	if ( elem.type === &quot;checkbox&quot; || elem.type === &quot;radio&quot; ) {
</a><a name="line-8317" data-line="8317">		elem.defaultChecked = elem.checked;
</a><a name="line-8318" data-line="8318">	}
</a><a name="line-8319" data-line="8319">}
</a><a name="line-8320" data-line="8320">// Finds all inputs and passes them to fixDefaultChecked
</a><a name="line-8321" data-line="8321">function findInputs( elem ) {
</a><a name="line-8322" data-line="8322">	var nodeName = ( elem.nodeName || &quot;&quot; ).toLowerCase();
</a><a name="line-8323" data-line="8323">	if ( nodeName === &quot;input&quot; ) {
</a><a name="line-8324" data-line="8324">		fixDefaultChecked( elem );
</a><a name="line-8325" data-line="8325">	// Skip scripts, get other children
</a><a name="line-8326" data-line="8326">	} else if ( nodeName !== &quot;script&quot; &amp;&amp; typeof elem.getElementsByTagName !== &quot;undefined&quot; ) {
</a><a name="line-8327" data-line="8327">		jQuery.grep( elem.getElementsByTagName(&quot;input&quot;), fixDefaultChecked );
</a><a name="line-8328" data-line="8328">	}
</a><a name="line-8329" data-line="8329">}
</a><a name="line-8330" data-line="8330">
</a><a name="line-8331" data-line="8331">// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
</a><a name="line-8332" data-line="8332">function shimCloneNode( elem ) {
</a><a name="line-8333" data-line="8333">	var div = document.createElement( &quot;div&quot; );
</a><a name="line-8334" data-line="8334">	safeFragment.appendChild( div );
</a><a name="line-8335" data-line="8335">
</a><a name="line-8336" data-line="8336">	div.innerHTML = elem.outerHTML;
</a><a name="line-8337" data-line="8337">	return div.firstChild;
</a><a name="line-8338" data-line="8338">}
</a><a name="line-8339" data-line="8339">
</a><a name="line-8340" data-line="8340">jQuery.extend({
</a><a name="line-8341" data-line="8341">	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
</a><a name="line-8342" data-line="8342">		var srcElements,
</a><a name="line-8343" data-line="8343">			destElements,
</a><a name="line-8344" data-line="8344">			i,
</a><a name="line-8345" data-line="8345">			// IE&lt;=8 does not properly clone detached, unknown element nodes
</a><a name="line-8346" data-line="8346">			clone = jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( &quot;&lt;&quot; + elem.nodeName + &quot;&gt;&quot; ) ?
</a><a name="line-8347" data-line="8347">				elem.cloneNode( true ) :
</a><a name="line-8348" data-line="8348">				shimCloneNode( elem );
</a><a name="line-8349" data-line="8349">
</a><a name="line-8350" data-line="8350">		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &amp;&amp;
</a><a name="line-8351" data-line="8351">				(elem.nodeType === 1 || elem.nodeType === 11) &amp;&amp; !jQuery.isXMLDoc(elem) ) {
</a><a name="line-8352" data-line="8352">			// IE copies events bound via attachEvent when using cloneNode.
</a><a name="line-8353" data-line="8353">			// Calling detachEvent on the clone will also remove the events
</a><a name="line-8354" data-line="8354">			// from the original. In order to get around this, we use some
</a><a name="line-8355" data-line="8355">			// proprietary methods to clear the events. Thanks to MooTools
</a><a name="line-8356" data-line="8356">			// guys for this hotness.
</a><a name="line-8357" data-line="8357">
</a><a name="line-8358" data-line="8358">			cloneFixAttributes( elem, clone );
</a><a name="line-8359" data-line="8359">
</a><a name="line-8360" data-line="8360">			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
</a><a name="line-8361" data-line="8361">			srcElements = getAll( elem );
</a><a name="line-8362" data-line="8362">			destElements = getAll( clone );
</a><a name="line-8363" data-line="8363">
</a><a name="line-8364" data-line="8364">			// Weird iteration because IE will replace the length property
</a><a name="line-8365" data-line="8365">			// with an element if you are cloning the body and one of the
</a><a name="line-8366" data-line="8366">			// elements on the page has a name or id of &quot;length&quot;
</a><a name="line-8367" data-line="8367">			for ( i = 0; srcElements[i]; ++i ) {
</a><a name="line-8368" data-line="8368">				// Ensure that the destination node is not null; Fixes #9587
</a><a name="line-8369" data-line="8369">				if ( destElements[i] ) {
</a><a name="line-8370" data-line="8370">					cloneFixAttributes( srcElements[i], destElements[i] );
</a><a name="line-8371" data-line="8371">				}
</a><a name="line-8372" data-line="8372">			}
</a><a name="line-8373" data-line="8373">		}
</a><a name="line-8374" data-line="8374">
</a><a name="line-8375" data-line="8375">		// Copy the events from the original to the clone
</a><a name="line-8376" data-line="8376">		if ( dataAndEvents ) {
</a><a name="line-8377" data-line="8377">			cloneCopyEvent( elem, clone );
</a><a name="line-8378" data-line="8378">
</a><a name="line-8379" data-line="8379">			if ( deepDataAndEvents ) {
</a><a name="line-8380" data-line="8380">				srcElements = getAll( elem );
</a><a name="line-8381" data-line="8381">				destElements = getAll( clone );
</a><a name="line-8382" data-line="8382">
</a><a name="line-8383" data-line="8383">				for ( i = 0; srcElements[i]; ++i ) {
</a><a name="line-8384" data-line="8384">					cloneCopyEvent( srcElements[i], destElements[i] );
</a><a name="line-8385" data-line="8385">				}
</a><a name="line-8386" data-line="8386">			}
</a><a name="line-8387" data-line="8387">		}
</a><a name="line-8388" data-line="8388">
</a><a name="line-8389" data-line="8389">		srcElements = destElements = null;
</a><a name="line-8390" data-line="8390">
</a><a name="line-8391" data-line="8391">		// Return the cloned set
</a><a name="line-8392" data-line="8392">		return clone;
</a><a name="line-8393" data-line="8393">	},
</a><a name="line-8394" data-line="8394">
</a><a name="line-8395" data-line="8395">	clean: function( elems, context, fragment, scripts ) {
</a><a name="line-8396" data-line="8396">		var checkScriptType, script, j,
</a><a name="line-8397" data-line="8397">				ret = [];
</a><a name="line-8398" data-line="8398">
</a><a name="line-8399" data-line="8399">		context = context || document;
</a><a name="line-8400" data-line="8400">
</a><a name="line-8401" data-line="8401">		// !context.createElement fails in IE with an error but returns typeof 'object'
</a><a name="line-8402" data-line="8402">		if ( typeof context.createElement === &quot;undefined&quot; ) {
</a><a name="line-8403" data-line="8403">			context = context.ownerDocument || context[0] &amp;&amp; context[0].ownerDocument || document;
</a><a name="line-8404" data-line="8404">		}
</a><a name="line-8405" data-line="8405">
</a><a name="line-8406" data-line="8406">		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
</a><a name="line-8407" data-line="8407">			if ( typeof elem === &quot;number&quot; ) {
</a><a name="line-8408" data-line="8408">				elem += &quot;&quot;;
</a><a name="line-8409" data-line="8409">			}
</a><a name="line-8410" data-line="8410">
</a><a name="line-8411" data-line="8411">			if ( !elem ) {
</a><a name="line-8412" data-line="8412">				continue;
</a><a name="line-8413" data-line="8413">			}
</a><a name="line-8414" data-line="8414">
</a><a name="line-8415" data-line="8415">			// Convert html string into DOM nodes
</a><a name="line-8416" data-line="8416">			if ( typeof elem === &quot;string&quot; ) {
</a><a name="line-8417" data-line="8417">				if ( !rhtml.test( elem ) ) {
</a><a name="line-8418" data-line="8418">					elem = context.createTextNode( elem );
</a><a name="line-8419" data-line="8419">				} else {
</a><a name="line-8420" data-line="8420">					// Fix &quot;XHTML&quot;-style tags in all browsers
</a><a name="line-8421" data-line="8421">					elem = elem.replace(rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot;);
</a><a name="line-8422" data-line="8422">
</a><a name="line-8423" data-line="8423">					// Trim whitespace, otherwise indexOf won't work as expected
</a><a name="line-8424" data-line="8424">					var tag = ( rtagName.exec( elem ) || [&quot;&quot;, &quot;&quot;] )[1].toLowerCase(),
</a><a name="line-8425" data-line="8425">						wrap = wrapMap[ tag ] || wrapMap._default,
</a><a name="line-8426" data-line="8426">						depth = wrap[0],
</a><a name="line-8427" data-line="8427">						div = context.createElement(&quot;div&quot;),
</a><a name="line-8428" data-line="8428">						safeChildNodes = safeFragment.childNodes,
</a><a name="line-8429" data-line="8429">						remove;
</a><a name="line-8430" data-line="8430">
</a><a name="line-8431" data-line="8431">					// Append wrapper element to unknown element safe doc fragment
</a><a name="line-8432" data-line="8432">					if ( context === document ) {
</a><a name="line-8433" data-line="8433">						// Use the fragment we've already created for this document
</a><a name="line-8434" data-line="8434">						safeFragment.appendChild( div );
</a><a name="line-8435" data-line="8435">					} else {
</a><a name="line-8436" data-line="8436">						// Use a fragment created with the owner document
</a><a name="line-8437" data-line="8437">						createSafeFragment( context ).appendChild( div );
</a><a name="line-8438" data-line="8438">					}
</a><a name="line-8439" data-line="8439">
</a><a name="line-8440" data-line="8440">					// Go to html and back, then peel off extra wrappers
</a><a name="line-8441" data-line="8441">					div.innerHTML = wrap[1] + elem + wrap[2];
</a><a name="line-8442" data-line="8442">
</a><a name="line-8443" data-line="8443">					// Move to the right depth
</a><a name="line-8444" data-line="8444">					while ( depth-- ) {
</a><a name="line-8445" data-line="8445">						div = div.lastChild;
</a><a name="line-8446" data-line="8446">					}
</a><a name="line-8447" data-line="8447">
</a><a name="line-8448" data-line="8448">					// Remove IE's autoinserted &lt;tbody&gt; from table fragments
</a><a name="line-8449" data-line="8449">					if ( !jQuery.support.tbody ) {
</a><a name="line-8450" data-line="8450">
</a><a name="line-8451" data-line="8451">						// String was a &lt;table&gt;, *may* have spurious &lt;tbody&gt;
</a><a name="line-8452" data-line="8452">						var hasBody = rtbody.test(elem),
</a><a name="line-8453" data-line="8453">							tbody = tag === &quot;table&quot; &amp;&amp; !hasBody ?
</a><a name="line-8454" data-line="8454">								div.firstChild &amp;&amp; div.firstChild.childNodes :
</a><a name="line-8455" data-line="8455">
</a><a name="line-8456" data-line="8456">								// String was a bare &lt;thead&gt; or &lt;tfoot&gt;
</a><a name="line-8457" data-line="8457">								wrap[1] === &quot;&lt;table&gt;&quot; &amp;&amp; !hasBody ?
</a><a name="line-8458" data-line="8458">									div.childNodes :
</a><a name="line-8459" data-line="8459">									[];
</a><a name="line-8460" data-line="8460">
</a><a name="line-8461" data-line="8461">						for ( j = tbody.length - 1; j &gt;= 0 ; --j ) {
</a><a name="line-8462" data-line="8462">							if ( jQuery.nodeName( tbody[ j ], &quot;tbody&quot; ) &amp;&amp; !tbody[ j ].childNodes.length ) {
</a><a name="line-8463" data-line="8463">								tbody[ j ].parentNode.removeChild( tbody[ j ] );
</a><a name="line-8464" data-line="8464">							}
</a><a name="line-8465" data-line="8465">						}
</a><a name="line-8466" data-line="8466">					}
</a><a name="line-8467" data-line="8467">
</a><a name="line-8468" data-line="8468">					// IE completely kills leading whitespace when innerHTML is used
</a><a name="line-8469" data-line="8469">					if ( !jQuery.support.leadingWhitespace &amp;&amp; rleadingWhitespace.test( elem ) ) {
</a><a name="line-8470" data-line="8470">						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
</a><a name="line-8471" data-line="8471">					}
</a><a name="line-8472" data-line="8472">
</a><a name="line-8473" data-line="8473">					elem = div.childNodes;
</a><a name="line-8474" data-line="8474">
</a><a name="line-8475" data-line="8475">					// Clear elements from DocumentFragment (safeFragment or otherwise)
</a><a name="line-8476" data-line="8476">					// to avoid hoarding elements. Fixes #11356
</a><a name="line-8477" data-line="8477">					if ( div ) {
</a><a name="line-8478" data-line="8478">						div.parentNode.removeChild( div );
</a><a name="line-8479" data-line="8479">
</a><a name="line-8480" data-line="8480">						// Guard against -1 index exceptions in FF3.6
</a><a name="line-8481" data-line="8481">						if ( safeChildNodes.length &gt; 0 ) {
</a><a name="line-8482" data-line="8482">							remove = safeChildNodes[ safeChildNodes.length - 1 ];
</a><a name="line-8483" data-line="8483">
</a><a name="line-8484" data-line="8484">							if ( remove &amp;&amp; remove.parentNode ) {
</a><a name="line-8485" data-line="8485">								remove.parentNode.removeChild( remove );
</a><a name="line-8486" data-line="8486">							}
</a><a name="line-8487" data-line="8487">						}
</a><a name="line-8488" data-line="8488">					}
</a><a name="line-8489" data-line="8489">				}
</a><a name="line-8490" data-line="8490">			}
</a><a name="line-8491" data-line="8491">
</a><a name="line-8492" data-line="8492">			// Resets defaultChecked for any radios and checkboxes
</a><a name="line-8493" data-line="8493">			// about to be appended to the DOM in IE 6/7 (#8060)
</a><a name="line-8494" data-line="8494">			var len;
</a><a name="line-8495" data-line="8495">			if ( !jQuery.support.appendChecked ) {
</a><a name="line-8496" data-line="8496">				if ( elem[0] &amp;&amp; typeof (len = elem.length) === &quot;number&quot; ) {
</a><a name="line-8497" data-line="8497">					for ( j = 0; j &lt; len; j++ ) {
</a><a name="line-8498" data-line="8498">						findInputs( elem[j] );
</a><a name="line-8499" data-line="8499">					}
</a><a name="line-8500" data-line="8500">				} else {
</a><a name="line-8501" data-line="8501">					findInputs( elem );
</a><a name="line-8502" data-line="8502">				}
</a><a name="line-8503" data-line="8503">			}
</a><a name="line-8504" data-line="8504">
</a><a name="line-8505" data-line="8505">			if ( elem.nodeType ) {
</a><a name="line-8506" data-line="8506">				ret.push( elem );
</a><a name="line-8507" data-line="8507">			} else {
</a><a name="line-8508" data-line="8508">				ret = jQuery.merge( ret, elem );
</a><a name="line-8509" data-line="8509">			}
</a><a name="line-8510" data-line="8510">		}
</a><a name="line-8511" data-line="8511">
</a><a name="line-8512" data-line="8512">		if ( fragment ) {
</a><a name="line-8513" data-line="8513">			checkScriptType = function( elem ) {
</a><a name="line-8514" data-line="8514">				return !elem.type || rscriptType.test( elem.type );
</a><a name="line-8515" data-line="8515">			};
</a><a name="line-8516" data-line="8516">			for ( i = 0; ret[i]; i++ ) {
</a><a name="line-8517" data-line="8517">				script = ret[i];
</a><a name="line-8518" data-line="8518">				if ( scripts &amp;&amp; jQuery.nodeName( script, &quot;script&quot; ) &amp;&amp; (!script.type || rscriptType.test( script.type )) ) {
</a><a name="line-8519" data-line="8519">					scripts.push( script.parentNode ? script.parentNode.removeChild( script ) : script );
</a><a name="line-8520" data-line="8520">
</a><a name="line-8521" data-line="8521">				} else {
</a><a name="line-8522" data-line="8522">					if ( script.nodeType === 1 ) {
</a><a name="line-8523" data-line="8523">						var jsTags = jQuery.grep( script.getElementsByTagName( &quot;script&quot; ), checkScriptType );
</a><a name="line-8524" data-line="8524">
</a><a name="line-8525" data-line="8525">						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
</a><a name="line-8526" data-line="8526">					}
</a><a name="line-8527" data-line="8527">					fragment.appendChild( script );
</a><a name="line-8528" data-line="8528">				}
</a><a name="line-8529" data-line="8529">			}
</a><a name="line-8530" data-line="8530">		}
</a><a name="line-8531" data-line="8531">
</a><a name="line-8532" data-line="8532">		return ret;
</a><a name="line-8533" data-line="8533">	},
</a><a name="line-8534" data-line="8534">
</a><a name="line-8535" data-line="8535">	cleanData: function( elems ) {
</a><a name="line-8536" data-line="8536">		var data, id,
</a><a name="line-8537" data-line="8537">			cache = jQuery.cache,
</a><a name="line-8538" data-line="8538">			special = jQuery.event.special,
</a><a name="line-8539" data-line="8539">			deleteExpando = jQuery.support.deleteExpando;
</a><a name="line-8540" data-line="8540">
</a><a name="line-8541" data-line="8541">		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
</a><a name="line-8542" data-line="8542">			if ( elem.nodeName &amp;&amp; jQuery.noData[elem.nodeName.toLowerCase()] ) {
</a><a name="line-8543" data-line="8543">				continue;
</a><a name="line-8544" data-line="8544">			}
</a><a name="line-8545" data-line="8545">
</a><a name="line-8546" data-line="8546">			id = elem[ jQuery.expando ];
</a><a name="line-8547" data-line="8547">
</a><a name="line-8548" data-line="8548">			if ( id ) {
</a><a name="line-8549" data-line="8549">				data = cache[ id ];
</a><a name="line-8550" data-line="8550">
</a><a name="line-8551" data-line="8551">				if ( data &amp;&amp; data.events ) {
</a><a name="line-8552" data-line="8552">					for ( var type in data.events ) {
</a><a name="line-8553" data-line="8553">						if ( special[ type ] ) {
</a><a name="line-8554" data-line="8554">							jQuery.event.remove( elem, type );
</a><a name="line-8555" data-line="8555">
</a><a name="line-8556" data-line="8556">						// This is a shortcut to avoid jQuery.event.remove's overhead
</a><a name="line-8557" data-line="8557">						} else {
</a><a name="line-8558" data-line="8558">							jQuery.removeEvent( elem, type, data.handle );
</a><a name="line-8559" data-line="8559">						}
</a><a name="line-8560" data-line="8560">					}
</a><a name="line-8561" data-line="8561">
</a><a name="line-8562" data-line="8562">					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
</a><a name="line-8563" data-line="8563">					if ( data.handle ) {
</a><a name="line-8564" data-line="8564">						data.handle.elem = null;
</a><a name="line-8565" data-line="8565">					}
</a><a name="line-8566" data-line="8566">				}
</a><a name="line-8567" data-line="8567">
</a><a name="line-8568" data-line="8568">				if ( deleteExpando ) {
</a><a name="line-8569" data-line="8569">					delete elem[ jQuery.expando ];
</a><a name="line-8570" data-line="8570">
</a><a name="line-8571" data-line="8571">				} else if ( elem.removeAttribute ) {
</a><a name="line-8572" data-line="8572">					elem.removeAttribute( jQuery.expando );
</a><a name="line-8573" data-line="8573">				}
</a><a name="line-8574" data-line="8574">
</a><a name="line-8575" data-line="8575">				delete cache[ id ];
</a><a name="line-8576" data-line="8576">			}
</a><a name="line-8577" data-line="8577">		}
</a><a name="line-8578" data-line="8578">	}
</a><a name="line-8579" data-line="8579">});
</a><a name="line-8580" data-line="8580">
</a><a name="line-8581" data-line="8581">
</a><a name="line-8582" data-line="8582">
</a><a name="line-8583" data-line="8583">
</a><a name="line-8584" data-line="8584">var ralpha = /alpha\([^)]*\)/i,
</a><a name="line-8585" data-line="8585">	ropacity = /opacity=([^)]*)/,
</a><a name="line-8586" data-line="8586">	// fixed for IE9, see #8346
</a><a name="line-8587" data-line="8587">	rupper = /([A-Z]|^ms)/g,
</a><a name="line-8588" data-line="8588">	rnum = /^[\-+]?(?:\d*\.)?\d+$/i,
</a><a name="line-8589" data-line="8589">	rnumnonpx = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
</a><a name="line-8590" data-line="8590">	rrelNum = /^([\-+])=([\-+.\de]+)/,
</a><a name="line-8591" data-line="8591">	rmargin = /^margin/,
</a><a name="line-8592" data-line="8592">
</a><a name="line-8593" data-line="8593">	cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
</a><a name="line-8594" data-line="8594">
</a><a name="line-8595" data-line="8595">	// order is important!
</a><a name="line-8596" data-line="8596">	cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ],
</a><a name="line-8597" data-line="8597">
</a><a name="line-8598" data-line="8598">	curCSS,
</a><a name="line-8599" data-line="8599">
</a><a name="line-8600" data-line="8600">	getComputedStyle,
</a><a name="line-8601" data-line="8601">	currentStyle;
</a><a name="line-8602" data-line="8602">
</a><a name="line-8603" data-line="8603">jQuery.fn.css = function( name, value ) {
</a><a name="line-8604" data-line="8604">	return jQuery.access( this, function( elem, name, value ) {
</a><a name="line-8605" data-line="8605">		return value !== undefined ?
</a><a name="line-8606" data-line="8606">			jQuery.style( elem, name, value ) :
</a><a name="line-8607" data-line="8607">			jQuery.css( elem, name );
</a><a name="line-8608" data-line="8608">	}, name, value, arguments.length &gt; 1 );
</a><a name="line-8609" data-line="8609">};
</a><a name="line-8610" data-line="8610">
</a><a name="line-8611" data-line="8611">jQuery.extend({
</a><a name="line-8612" data-line="8612">	// Add in style property hooks for overriding the default
</a><a name="line-8613" data-line="8613">	// behavior of getting and setting a style property
</a><a name="line-8614" data-line="8614">	cssHooks: {
</a><a name="line-8615" data-line="8615">		opacity: {
</a><a name="line-8616" data-line="8616">			get: function( elem, computed ) {
</a><a name="line-8617" data-line="8617">				if ( computed ) {
</a><a name="line-8618" data-line="8618">					// We should always get a number back from opacity
</a><a name="line-8619" data-line="8619">					var ret = curCSS( elem, &quot;opacity&quot; );
</a><a name="line-8620" data-line="8620">					return ret === &quot;&quot; ? &quot;1&quot; : ret;
</a><a name="line-8621" data-line="8621">
</a><a name="line-8622" data-line="8622">				} else {
</a><a name="line-8623" data-line="8623">					return elem.style.opacity;
</a><a name="line-8624" data-line="8624">				}
</a><a name="line-8625" data-line="8625">			}
</a><a name="line-8626" data-line="8626">		}
</a><a name="line-8627" data-line="8627">	},
</a><a name="line-8628" data-line="8628">
</a><a name="line-8629" data-line="8629">	// Exclude the following css properties to add px
</a><a name="line-8630" data-line="8630">	cssNumber: {
</a><a name="line-8631" data-line="8631">		&quot;fillOpacity&quot;: true,
</a><a name="line-8632" data-line="8632">		&quot;fontWeight&quot;: true,
</a><a name="line-8633" data-line="8633">		&quot;lineHeight&quot;: true,
</a><a name="line-8634" data-line="8634">		&quot;opacity&quot;: true,
</a><a name="line-8635" data-line="8635">		&quot;orphans&quot;: true,
</a><a name="line-8636" data-line="8636">		&quot;widows&quot;: true,
</a><a name="line-8637" data-line="8637">		&quot;zIndex&quot;: true,
</a><a name="line-8638" data-line="8638">		&quot;zoom&quot;: true
</a><a name="line-8639" data-line="8639">	},
</a><a name="line-8640" data-line="8640">
</a><a name="line-8641" data-line="8641">	// Add in properties whose names you wish to fix before
</a><a name="line-8642" data-line="8642">	// setting or getting the value
</a><a name="line-8643" data-line="8643">	cssProps: {
</a><a name="line-8644" data-line="8644">		// normalize float css property
</a><a name="line-8645" data-line="8645">		&quot;float&quot;: jQuery.support.cssFloat ? &quot;cssFloat&quot; : &quot;styleFloat&quot;
</a><a name="line-8646" data-line="8646">	},
</a><a name="line-8647" data-line="8647">
</a><a name="line-8648" data-line="8648">	// Get and set the style property on a DOM Node
</a><a name="line-8649" data-line="8649">	style: function( elem, name, value, extra ) {
</a><a name="line-8650" data-line="8650">		// Don't set styles on text and comment nodes
</a><a name="line-8651" data-line="8651">		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
</a><a name="line-8652" data-line="8652">			return;
</a><a name="line-8653" data-line="8653">		}
</a><a name="line-8654" data-line="8654">
</a><a name="line-8655" data-line="8655">		// Make sure that we're working with the right name
</a><a name="line-8656" data-line="8656">		var ret, type, origName = jQuery.camelCase( name ),
</a><a name="line-8657" data-line="8657">			style = elem.style, hooks = jQuery.cssHooks[ origName ];
</a><a name="line-8658" data-line="8658">
</a><a name="line-8659" data-line="8659">		name = jQuery.cssProps[ origName ] || origName;
</a><a name="line-8660" data-line="8660">
</a><a name="line-8661" data-line="8661">		// Check if we're setting a value
</a><a name="line-8662" data-line="8662">		if ( value !== undefined ) {
</a><a name="line-8663" data-line="8663">			type = typeof value;
</a><a name="line-8664" data-line="8664">
</a><a name="line-8665" data-line="8665">			// convert relative number strings (+= or -=) to relative numbers. #7345
</a><a name="line-8666" data-line="8666">			if ( type === &quot;string&quot; &amp;&amp; (ret = rrelNum.exec( value )) ) {
</a><a name="line-8667" data-line="8667">				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
</a><a name="line-8668" data-line="8668">				// Fixes bug #9237
</a><a name="line-8669" data-line="8669">				type = &quot;number&quot;;
</a><a name="line-8670" data-line="8670">			}
</a><a name="line-8671" data-line="8671">
</a><a name="line-8672" data-line="8672">			// Make sure that NaN and null values aren't set. See: #7116
</a><a name="line-8673" data-line="8673">			if ( value == null || type === &quot;number&quot; &amp;&amp; isNaN( value ) ) {
</a><a name="line-8674" data-line="8674">				return;
</a><a name="line-8675" data-line="8675">			}
</a><a name="line-8676" data-line="8676">
</a><a name="line-8677" data-line="8677">			// If a number was passed in, add 'px' to the (except for certain CSS properties)
</a><a name="line-8678" data-line="8678">			if ( type === &quot;number&quot; &amp;&amp; !jQuery.cssNumber[ origName ] ) {
</a><a name="line-8679" data-line="8679">				value += &quot;px&quot;;
</a><a name="line-8680" data-line="8680">			}
</a><a name="line-8681" data-line="8681">
</a><a name="line-8682" data-line="8682">			// If a hook was provided, use that value, otherwise just set the specified value
</a><a name="line-8683" data-line="8683">			if ( !hooks || !(&quot;set&quot; in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
</a><a name="line-8684" data-line="8684">				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
</a><a name="line-8685" data-line="8685">				// Fixes bug #5509
</a><a name="line-8686" data-line="8686">				try {
</a><a name="line-8687" data-line="8687">					style[ name ] = value;
</a><a name="line-8688" data-line="8688">				} catch(e) {}
</a><a name="line-8689" data-line="8689">			}
</a><a name="line-8690" data-line="8690">
</a><a name="line-8691" data-line="8691">		} else {
</a><a name="line-8692" data-line="8692">			// If a hook was provided get the non-computed value from there
</a><a name="line-8693" data-line="8693">			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, false, extra )) !== undefined ) {
</a><a name="line-8694" data-line="8694">				return ret;
</a><a name="line-8695" data-line="8695">			}
</a><a name="line-8696" data-line="8696">
</a><a name="line-8697" data-line="8697">			// Otherwise just get the value from the style object
</a><a name="line-8698" data-line="8698">			return style[ name ];
</a><a name="line-8699" data-line="8699">		}
</a><a name="line-8700" data-line="8700">	},
</a><a name="line-8701" data-line="8701">
</a><a name="line-8702" data-line="8702">	css: function( elem, name, extra ) {
</a><a name="line-8703" data-line="8703">		var ret, hooks;
</a><a name="line-8704" data-line="8704">
</a><a name="line-8705" data-line="8705">		// Make sure that we're working with the right name
</a><a name="line-8706" data-line="8706">		name = jQuery.camelCase( name );
</a><a name="line-8707" data-line="8707">		hooks = jQuery.cssHooks[ name ];
</a><a name="line-8708" data-line="8708">		name = jQuery.cssProps[ name ] || name;
</a><a name="line-8709" data-line="8709">
</a><a name="line-8710" data-line="8710">		// cssFloat needs a special treatment
</a><a name="line-8711" data-line="8711">		if ( name === &quot;cssFloat&quot; ) {
</a><a name="line-8712" data-line="8712">			name = &quot;float&quot;;
</a><a name="line-8713" data-line="8713">		}
</a><a name="line-8714" data-line="8714">
</a><a name="line-8715" data-line="8715">		// If a hook was provided get the computed value from there
</a><a name="line-8716" data-line="8716">		if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, true, extra )) !== undefined ) {
</a><a name="line-8717" data-line="8717">			return ret;
</a><a name="line-8718" data-line="8718">
</a><a name="line-8719" data-line="8719">		// Otherwise, if a way to get the computed value exists, use that
</a><a name="line-8720" data-line="8720">		} else if ( curCSS ) {
</a><a name="line-8721" data-line="8721">			return curCSS( elem, name );
</a><a name="line-8722" data-line="8722">		}
</a><a name="line-8723" data-line="8723">	},
</a><a name="line-8724" data-line="8724">
</a><a name="line-8725" data-line="8725">	// A method for quickly swapping in/out CSS properties to get correct calculations
</a><a name="line-8726" data-line="8726">	swap: function( elem, options, callback ) {
</a><a name="line-8727" data-line="8727">		var old = {},
</a><a name="line-8728" data-line="8728">			ret, name;
</a><a name="line-8729" data-line="8729">
</a><a name="line-8730" data-line="8730">		// Remember the old values, and insert the new ones
</a><a name="line-8731" data-line="8731">		for ( name in options ) {
</a><a name="line-8732" data-line="8732">			old[ name ] = elem.style[ name ];
</a><a name="line-8733" data-line="8733">			elem.style[ name ] = options[ name ];
</a><a name="line-8734" data-line="8734">		}
</a><a name="line-8735" data-line="8735">
</a><a name="line-8736" data-line="8736">		ret = callback.call( elem );
</a><a name="line-8737" data-line="8737">
</a><a name="line-8738" data-line="8738">		// Revert the old values
</a><a name="line-8739" data-line="8739">		for ( name in options ) {
</a><a name="line-8740" data-line="8740">			elem.style[ name ] = old[ name ];
</a><a name="line-8741" data-line="8741">		}
</a><a name="line-8742" data-line="8742">
</a><a name="line-8743" data-line="8743">		return ret;
</a><a name="line-8744" data-line="8744">	}
</a><a name="line-8745" data-line="8745">});
</a><a name="line-8746" data-line="8746">
</a><a name="line-8747" data-line="8747">// DEPRECATED in 1.3, Use jQuery.css() instead
</a><a name="line-8748" data-line="8748">jQuery.curCSS = jQuery.css;
</a><a name="line-8749" data-line="8749">
</a><a name="line-8750" data-line="8750">if ( document.defaultView &amp;&amp; document.defaultView.getComputedStyle ) {
</a><a name="line-8751" data-line="8751">	getComputedStyle = function( elem, name ) {
</a><a name="line-8752" data-line="8752">		var ret, defaultView, computedStyle, width,
</a><a name="line-8753" data-line="8753">			style = elem.style;
</a><a name="line-8754" data-line="8754">
</a><a name="line-8755" data-line="8755">		name = name.replace( rupper, &quot;-$1&quot; ).toLowerCase();
</a><a name="line-8756" data-line="8756">
</a><a name="line-8757" data-line="8757">		if ( (defaultView = elem.ownerDocument.defaultView) &amp;&amp;
</a><a name="line-8758" data-line="8758">				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
</a><a name="line-8759" data-line="8759">
</a><a name="line-8760" data-line="8760">			ret = computedStyle.getPropertyValue( name );
</a><a name="line-8761" data-line="8761">			if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
</a><a name="line-8762" data-line="8762">				ret = jQuery.style( elem, name );
</a><a name="line-8763" data-line="8763">			}
</a><a name="line-8764" data-line="8764">		}
</a><a name="line-8765" data-line="8765">
</a><a name="line-8766" data-line="8766">		// A tribute to the &quot;awesome hack by Dean Edwards&quot;
</a><a name="line-8767" data-line="8767">		// WebKit uses &quot;computed value (percentage if specified)&quot; instead of &quot;used value&quot; for margins
</a><a name="line-8768" data-line="8768">		// which is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
</a><a name="line-8769" data-line="8769">		if ( !jQuery.support.pixelMargin &amp;&amp; computedStyle &amp;&amp; rmargin.test( name ) &amp;&amp; rnumnonpx.test( ret ) ) {
</a><a name="line-8770" data-line="8770">			width = style.width;
</a><a name="line-8771" data-line="8771">			style.width = ret;
</a><a name="line-8772" data-line="8772">			ret = computedStyle.width;
</a><a name="line-8773" data-line="8773">			style.width = width;
</a><a name="line-8774" data-line="8774">		}
</a><a name="line-8775" data-line="8775">
</a><a name="line-8776" data-line="8776">		return ret;
</a><a name="line-8777" data-line="8777">	};
</a><a name="line-8778" data-line="8778">}
</a><a name="line-8779" data-line="8779">
</a><a name="line-8780" data-line="8780">if ( document.documentElement.currentStyle ) {
</a><a name="line-8781" data-line="8781">	currentStyle = function( elem, name ) {
</a><a name="line-8782" data-line="8782">		var left, rsLeft, uncomputed,
</a><a name="line-8783" data-line="8783">			ret = elem.currentStyle &amp;&amp; elem.currentStyle[ name ],
</a><a name="line-8784" data-line="8784">			style = elem.style;
</a><a name="line-8785" data-line="8785">
</a><a name="line-8786" data-line="8786">		// Avoid setting ret to empty string here
</a><a name="line-8787" data-line="8787">		// so we don't default to auto
</a><a name="line-8788" data-line="8788">		if ( ret == null &amp;&amp; style &amp;&amp; (uncomputed = style[ name ]) ) {
</a><a name="line-8789" data-line="8789">			ret = uncomputed;
</a><a name="line-8790" data-line="8790">		}
</a><a name="line-8791" data-line="8791">
</a><a name="line-8792" data-line="8792">		// From the awesome hack by Dean Edwards
</a><a name="line-8793" data-line="8793">		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
</a><a name="line-8794" data-line="8794">
</a><a name="line-8795" data-line="8795">		// If we're not dealing with a regular pixel number
</a><a name="line-8796" data-line="8796">		// but a number that has a weird ending, we need to convert it to pixels
</a><a name="line-8797" data-line="8797">		if ( rnumnonpx.test( ret ) ) {
</a><a name="line-8798" data-line="8798">
</a><a name="line-8799" data-line="8799">			// Remember the original values
</a><a name="line-8800" data-line="8800">			left = style.left;
</a><a name="line-8801" data-line="8801">			rsLeft = elem.runtimeStyle &amp;&amp; elem.runtimeStyle.left;
</a><a name="line-8802" data-line="8802">
</a><a name="line-8803" data-line="8803">			// Put in the new values to get a computed value out
</a><a name="line-8804" data-line="8804">			if ( rsLeft ) {
</a><a name="line-8805" data-line="8805">				elem.runtimeStyle.left = elem.currentStyle.left;
</a><a name="line-8806" data-line="8806">			}
</a><a name="line-8807" data-line="8807">			style.left = name === &quot;fontSize&quot; ? &quot;1em&quot; : ret;
</a><a name="line-8808" data-line="8808">			ret = style.pixelLeft + &quot;px&quot;;
</a><a name="line-8809" data-line="8809">
</a><a name="line-8810" data-line="8810">			// Revert the changed values
</a><a name="line-8811" data-line="8811">			style.left = left;
</a><a name="line-8812" data-line="8812">			if ( rsLeft ) {
</a><a name="line-8813" data-line="8813">				elem.runtimeStyle.left = rsLeft;
</a><a name="line-8814" data-line="8814">			}
</a><a name="line-8815" data-line="8815">		}
</a><a name="line-8816" data-line="8816">
</a><a name="line-8817" data-line="8817">		return ret === &quot;&quot; ? &quot;auto&quot; : ret;
</a><a name="line-8818" data-line="8818">	};
</a><a name="line-8819" data-line="8819">}
</a><a name="line-8820" data-line="8820">
</a><a name="line-8821" data-line="8821">curCSS = getComputedStyle || currentStyle;
</a><a name="line-8822" data-line="8822">
</a><a name="line-8823" data-line="8823">function getWidthOrHeight( elem, name, extra ) {
</a><a name="line-8824" data-line="8824">
</a><a name="line-8825" data-line="8825">	// Start with offset property
</a><a name="line-8826" data-line="8826">	var val = name === &quot;width&quot; ? elem.offsetWidth : elem.offsetHeight,
</a><a name="line-8827" data-line="8827">		i = name === &quot;width&quot; ? 1 : 0,
</a><a name="line-8828" data-line="8828">		len = 4;
</a><a name="line-8829" data-line="8829">
</a><a name="line-8830" data-line="8830">	if ( val &gt; 0 ) {
</a><a name="line-8831" data-line="8831">		if ( extra !== &quot;border&quot; ) {
</a><a name="line-8832" data-line="8832">			for ( ; i &lt; len; i += 2 ) {
</a><a name="line-8833" data-line="8833">				if ( !extra ) {
</a><a name="line-8834" data-line="8834">					val -= parseFloat( jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ] ) ) || 0;
</a><a name="line-8835" data-line="8835">				}
</a><a name="line-8836" data-line="8836">				if ( extra === &quot;margin&quot; ) {
</a><a name="line-8837" data-line="8837">					val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ] ) ) || 0;
</a><a name="line-8838" data-line="8838">				} else {
</a><a name="line-8839" data-line="8839">					val -= parseFloat( jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot; ) ) || 0;
</a><a name="line-8840" data-line="8840">				}
</a><a name="line-8841" data-line="8841">			}
</a><a name="line-8842" data-line="8842">		}
</a><a name="line-8843" data-line="8843">
</a><a name="line-8844" data-line="8844">		return val + &quot;px&quot;;
</a><a name="line-8845" data-line="8845">	}
</a><a name="line-8846" data-line="8846">
</a><a name="line-8847" data-line="8847">	// Fall back to computed then uncomputed css if necessary
</a><a name="line-8848" data-line="8848">	val = curCSS( elem, name );
</a><a name="line-8849" data-line="8849">	if ( val &lt; 0 || val == null ) {
</a><a name="line-8850" data-line="8850">		val = elem.style[ name ];
</a><a name="line-8851" data-line="8851">	}
</a><a name="line-8852" data-line="8852">
</a><a name="line-8853" data-line="8853">	// Computed unit is not pixels. Stop here and return.
</a><a name="line-8854" data-line="8854">	if ( rnumnonpx.test(val) ) {
</a><a name="line-8855" data-line="8855">		return val;
</a><a name="line-8856" data-line="8856">	}
</a><a name="line-8857" data-line="8857">
</a><a name="line-8858" data-line="8858">	// Normalize &quot;&quot;, auto, and prepare for extra
</a><a name="line-8859" data-line="8859">	val = parseFloat( val ) || 0;
</a><a name="line-8860" data-line="8860">
</a><a name="line-8861" data-line="8861">	// Add padding, border, margin
</a><a name="line-8862" data-line="8862">	if ( extra ) {
</a><a name="line-8863" data-line="8863">		for ( ; i &lt; len; i += 2 ) {
</a><a name="line-8864" data-line="8864">			val += parseFloat( jQuery.css( elem, &quot;padding&quot; + cssExpand[ i ] ) ) || 0;
</a><a name="line-8865" data-line="8865">			if ( extra !== &quot;padding&quot; ) {
</a><a name="line-8866" data-line="8866">				val += parseFloat( jQuery.css( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot; ) ) || 0;
</a><a name="line-8867" data-line="8867">			}
</a><a name="line-8868" data-line="8868">			if ( extra === &quot;margin&quot; ) {
</a><a name="line-8869" data-line="8869">				val += parseFloat( jQuery.css( elem, extra + cssExpand[ i ]) ) || 0;
</a><a name="line-8870" data-line="8870">			}
</a><a name="line-8871" data-line="8871">		}
</a><a name="line-8872" data-line="8872">	}
</a><a name="line-8873" data-line="8873">
</a><a name="line-8874" data-line="8874">	return val + &quot;px&quot;;
</a><a name="line-8875" data-line="8875">}
</a><a name="line-8876" data-line="8876">
</a><a name="line-8877" data-line="8877">jQuery.each([ &quot;height&quot;, &quot;width&quot; ], function( i, name ) {
</a><a name="line-8878" data-line="8878">	jQuery.cssHooks[ name ] = {
</a><a name="line-8879" data-line="8879">		get: function( elem, computed, extra ) {
</a><a name="line-8880" data-line="8880">			if ( computed ) {
</a><a name="line-8881" data-line="8881">				if ( elem.offsetWidth !== 0 ) {
</a><a name="line-8882" data-line="8882">					return getWidthOrHeight( elem, name, extra );
</a><a name="line-8883" data-line="8883">				} else {
</a><a name="line-8884" data-line="8884">					return jQuery.swap( elem, cssShow, function() {
</a><a name="line-8885" data-line="8885">						return getWidthOrHeight( elem, name, extra );
</a><a name="line-8886" data-line="8886">					});
</a><a name="line-8887" data-line="8887">				}
</a><a name="line-8888" data-line="8888">			}
</a><a name="line-8889" data-line="8889">		},
</a><a name="line-8890" data-line="8890">
</a><a name="line-8891" data-line="8891">		set: function( elem, value ) {
</a><a name="line-8892" data-line="8892">			return rnum.test( value ) ?
</a><a name="line-8893" data-line="8893">				value + &quot;px&quot; :
</a><a name="line-8894" data-line="8894">				value;
</a><a name="line-8895" data-line="8895">		}
</a><a name="line-8896" data-line="8896">	};
</a><a name="line-8897" data-line="8897">});
</a><a name="line-8898" data-line="8898">
</a><a name="line-8899" data-line="8899">if ( !jQuery.support.opacity ) {
</a><a name="line-8900" data-line="8900">	jQuery.cssHooks.opacity = {
</a><a name="line-8901" data-line="8901">		get: function( elem, computed ) {
</a><a name="line-8902" data-line="8902">			// IE uses filters for opacity
</a><a name="line-8903" data-line="8903">			return ropacity.test( (computed &amp;&amp; elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || &quot;&quot; ) ?
</a><a name="line-8904" data-line="8904">				( parseFloat( RegExp.$1 ) / 100 ) + &quot;&quot; :
</a><a name="line-8905" data-line="8905">				computed ? &quot;1&quot; : &quot;&quot;;
</a><a name="line-8906" data-line="8906">		},
</a><a name="line-8907" data-line="8907">
</a><a name="line-8908" data-line="8908">		set: function( elem, value ) {
</a><a name="line-8909" data-line="8909">			var style = elem.style,
</a><a name="line-8910" data-line="8910">				currentStyle = elem.currentStyle,
</a><a name="line-8911" data-line="8911">				opacity = jQuery.isNumeric( value ) ? &quot;alpha(opacity=&quot; + value * 100 + &quot;)&quot; : &quot;&quot;,
</a><a name="line-8912" data-line="8912">				filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || &quot;&quot;;
</a><a name="line-8913" data-line="8913">
</a><a name="line-8914" data-line="8914">			// IE has trouble with opacity if it does not have layout
</a><a name="line-8915" data-line="8915">			// Force it by setting the zoom level
</a><a name="line-8916" data-line="8916">			style.zoom = 1;
</a><a name="line-8917" data-line="8917">
</a><a name="line-8918" data-line="8918">			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
</a><a name="line-8919" data-line="8919">			if ( value &gt;= 1 &amp;&amp; jQuery.trim( filter.replace( ralpha, &quot;&quot; ) ) === &quot;&quot; ) {
</a><a name="line-8920" data-line="8920">
</a><a name="line-8921" data-line="8921">				// Setting style.filter to null, &quot;&quot; &amp; &quot; &quot; still leave &quot;filter:&quot; in the cssText
</a><a name="line-8922" data-line="8922">				// if &quot;filter:&quot; is present at all, clearType is disabled, we want to avoid this
</a><a name="line-8923" data-line="8923">				// style.removeAttribute is IE Only, but so apparently is this code path...
</a><a name="line-8924" data-line="8924">				style.removeAttribute( &quot;filter&quot; );
</a><a name="line-8925" data-line="8925">
</a><a name="line-8926" data-line="8926">				// if there there is no filter style applied in a css rule, we are done
</a><a name="line-8927" data-line="8927">				if ( currentStyle &amp;&amp; !currentStyle.filter ) {
</a><a name="line-8928" data-line="8928">					return;
</a><a name="line-8929" data-line="8929">				}
</a><a name="line-8930" data-line="8930">			}
</a><a name="line-8931" data-line="8931">
</a><a name="line-8932" data-line="8932">			// otherwise, set new filter values
</a><a name="line-8933" data-line="8933">			style.filter = ralpha.test( filter ) ?
</a><a name="line-8934" data-line="8934">				filter.replace( ralpha, opacity ) :
</a><a name="line-8935" data-line="8935">				filter + &quot; &quot; + opacity;
</a><a name="line-8936" data-line="8936">		}
</a><a name="line-8937" data-line="8937">	};
</a><a name="line-8938" data-line="8938">}
</a><a name="line-8939" data-line="8939">
</a><a name="line-8940" data-line="8940">jQuery(function() {
</a><a name="line-8941" data-line="8941">	// This hook cannot be added until DOM ready because the support test
</a><a name="line-8942" data-line="8942">	// for it is not run until after DOM ready
</a><a name="line-8943" data-line="8943">	if ( !jQuery.support.reliableMarginRight ) {
</a><a name="line-8944" data-line="8944">		jQuery.cssHooks.marginRight = {
</a><a name="line-8945" data-line="8945">			get: function( elem, computed ) {
</a><a name="line-8946" data-line="8946">				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
</a><a name="line-8947" data-line="8947">				// Work around by temporarily setting element display to inline-block
</a><a name="line-8948" data-line="8948">				return jQuery.swap( elem, { &quot;display&quot;: &quot;inline-block&quot; }, function() {
</a><a name="line-8949" data-line="8949">					if ( computed ) {
</a><a name="line-8950" data-line="8950">						return curCSS( elem, &quot;margin-right&quot; );
</a><a name="line-8951" data-line="8951">					} else {
</a><a name="line-8952" data-line="8952">						return elem.style.marginRight;
</a><a name="line-8953" data-line="8953">					}
</a><a name="line-8954" data-line="8954">				});
</a><a name="line-8955" data-line="8955">			}
</a><a name="line-8956" data-line="8956">		};
</a><a name="line-8957" data-line="8957">	}
</a><a name="line-8958" data-line="8958">});
</a><a name="line-8959" data-line="8959">
</a><a name="line-8960" data-line="8960">if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {
</a><a name="line-8961" data-line="8961">	jQuery.expr.filters.hidden = function( elem ) {
</a><a name="line-8962" data-line="8962">		var width = elem.offsetWidth,
</a><a name="line-8963" data-line="8963">			height = elem.offsetHeight;
</a><a name="line-8964" data-line="8964">
</a><a name="line-8965" data-line="8965">		return ( width === 0 &amp;&amp; height === 0 ) || (!jQuery.support.reliableHiddenOffsets &amp;&amp; ((elem.style &amp;&amp; elem.style.display) || jQuery.css( elem, &quot;display&quot; )) === &quot;none&quot;);
</a><a name="line-8966" data-line="8966">	};
</a><a name="line-8967" data-line="8967">
</a><a name="line-8968" data-line="8968">	jQuery.expr.filters.visible = function( elem ) {
</a><a name="line-8969" data-line="8969">		return !jQuery.expr.filters.hidden( elem );
</a><a name="line-8970" data-line="8970">	};
</a><a name="line-8971" data-line="8971">}
</a><a name="line-8972" data-line="8972">
</a><a name="line-8973" data-line="8973">// These hooks are used by animate to expand properties
</a><a name="line-8974" data-line="8974">jQuery.each({
</a><a name="line-8975" data-line="8975">	margin: &quot;&quot;,
</a><a name="line-8976" data-line="8976">	padding: &quot;&quot;,
</a><a name="line-8977" data-line="8977">	border: &quot;Width&quot;
</a><a name="line-8978" data-line="8978">}, function( prefix, suffix ) {
</a><a name="line-8979" data-line="8979">
</a><a name="line-8980" data-line="8980">	jQuery.cssHooks[ prefix + suffix ] = {
</a><a name="line-8981" data-line="8981">		expand: function( value ) {
</a><a name="line-8982" data-line="8982">			var i,
</a><a name="line-8983" data-line="8983">
</a><a name="line-8984" data-line="8984">				// assumes a single number if not a string
</a><a name="line-8985" data-line="8985">				parts = typeof value === &quot;string&quot; ? value.split(&quot; &quot;) : [ value ],
</a><a name="line-8986" data-line="8986">				expanded = {};
</a><a name="line-8987" data-line="8987">
</a><a name="line-8988" data-line="8988">			for ( i = 0; i &lt; 4; i++ ) {
</a><a name="line-8989" data-line="8989">				expanded[ prefix + cssExpand[ i ] + suffix ] =
</a><a name="line-8990" data-line="8990">					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
</a><a name="line-8991" data-line="8991">			}
</a><a name="line-8992" data-line="8992">
</a><a name="line-8993" data-line="8993">			return expanded;
</a><a name="line-8994" data-line="8994">		}
</a><a name="line-8995" data-line="8995">	};
</a><a name="line-8996" data-line="8996">});
</a><a name="line-8997" data-line="8997">
</a><a name="line-8998" data-line="8998">
</a><a name="line-8999" data-line="8999">
</a><a name="line-9000" data-line="9000">
</a><a name="line-9001" data-line="9001">var r20 = /%20/g,
</a><a name="line-9002" data-line="9002">	rbracket = /\[\]$/,
</a><a name="line-9003" data-line="9003">	rCRLF = /\r?\n/g,
</a><a name="line-9004" data-line="9004">	rhash = /#.*$/,
</a><a name="line-9005" data-line="9005">	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
</a><a name="line-9006" data-line="9006">	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
</a><a name="line-9007" data-line="9007">	// #7653, #8125, #8152: local protocol detection
</a><a name="line-9008" data-line="9008">	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
</a><a name="line-9009" data-line="9009">	rnoContent = /^(?:GET|HEAD)$/,
</a><a name="line-9010" data-line="9010">	rprotocol = /^\/\//,
</a><a name="line-9011" data-line="9011">	rquery = /\?/,
</a><a name="line-9012" data-line="9012">	rscript = /&lt;script\b[^&lt;]*(?:(?!&lt;\/script&gt;)&lt;[^&lt;]*)*&lt;\/script&gt;/gi,
</a><a name="line-9013" data-line="9013">	rselectTextarea = /^(?:select|textarea)/i,
</a><a name="line-9014" data-line="9014">	rspacesAjax = /\s+/,
</a><a name="line-9015" data-line="9015">	rts = /([?&amp;])_=[^&amp;]*/,
</a><a name="line-9016" data-line="9016">	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
</a><a name="line-9017" data-line="9017">
</a><a name="line-9018" data-line="9018">	// Keep a copy of the old load method
</a><a name="line-9019" data-line="9019">	_load = jQuery.fn.load,
</a><a name="line-9020" data-line="9020">
</a><a name="line-9021" data-line="9021">	/* Prefilters
</a><a name="line-9022" data-line="9022">	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
</a><a name="line-9023" data-line="9023">	 * 2) These are called:
</a><a name="line-9024" data-line="9024">	 *    - BEFORE asking for a transport
</a><a name="line-9025" data-line="9025">	 *    - AFTER param serialization (s.data is a string if s.processData is true)
</a><a name="line-9026" data-line="9026">	 * 3) key is the dataType
</a><a name="line-9027" data-line="9027">	 * 4) the catchall symbol &quot;*&quot; can be used
</a><a name="line-9028" data-line="9028">	 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
</a><a name="line-9029" data-line="9029">	 */
</a><a name="line-9030" data-line="9030">	prefilters = {},
</a><a name="line-9031" data-line="9031">
</a><a name="line-9032" data-line="9032">	/* Transports bindings
</a><a name="line-9033" data-line="9033">	 * 1) key is the dataType
</a><a name="line-9034" data-line="9034">	 * 2) the catchall symbol &quot;*&quot; can be used
</a><a name="line-9035" data-line="9035">	 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
</a><a name="line-9036" data-line="9036">	 */
</a><a name="line-9037" data-line="9037">	transports = {},
</a><a name="line-9038" data-line="9038">
</a><a name="line-9039" data-line="9039">	// Document location
</a><a name="line-9040" data-line="9040">	ajaxLocation,
</a><a name="line-9041" data-line="9041">
</a><a name="line-9042" data-line="9042">	// Document location segments
</a><a name="line-9043" data-line="9043">	ajaxLocParts,
</a><a name="line-9044" data-line="9044">
</a><a name="line-9045" data-line="9045">	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
</a><a name="line-9046" data-line="9046">	allTypes = [&quot;*/&quot;] + [&quot;*&quot;];
</a><a name="line-9047" data-line="9047">
</a><a name="line-9048" data-line="9048">// #8138, IE may throw an exception when accessing
</a><a name="line-9049" data-line="9049">// a field from window.location if document.domain has been set
</a><a name="line-9050" data-line="9050">try {
</a><a name="line-9051" data-line="9051">	ajaxLocation = location.href;
</a><a name="line-9052" data-line="9052">} catch( e ) {
</a><a name="line-9053" data-line="9053">	// Use the href attribute of an A element
</a><a name="line-9054" data-line="9054">	// since IE will modify it given document.location
</a><a name="line-9055" data-line="9055">	ajaxLocation = document.createElement( &quot;a&quot; );
</a><a name="line-9056" data-line="9056">	ajaxLocation.href = &quot;&quot;;
</a><a name="line-9057" data-line="9057">	ajaxLocation = ajaxLocation.href;
</a><a name="line-9058" data-line="9058">}
</a><a name="line-9059" data-line="9059">
</a><a name="line-9060" data-line="9060">// Segment location into parts
</a><a name="line-9061" data-line="9061">ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
</a><a name="line-9062" data-line="9062">
</a><a name="line-9063" data-line="9063">// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
</a><a name="line-9064" data-line="9064">function addToPrefiltersOrTransports( structure ) {
</a><a name="line-9065" data-line="9065">
</a><a name="line-9066" data-line="9066">	// dataTypeExpression is optional and defaults to &quot;*&quot;
</a><a name="line-9067" data-line="9067">	return function( dataTypeExpression, func ) {
</a><a name="line-9068" data-line="9068">
</a><a name="line-9069" data-line="9069">		if ( typeof dataTypeExpression !== &quot;string&quot; ) {
</a><a name="line-9070" data-line="9070">			func = dataTypeExpression;
</a><a name="line-9071" data-line="9071">			dataTypeExpression = &quot;*&quot;;
</a><a name="line-9072" data-line="9072">		}
</a><a name="line-9073" data-line="9073">
</a><a name="line-9074" data-line="9074">		if ( jQuery.isFunction( func ) ) {
</a><a name="line-9075" data-line="9075">			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
</a><a name="line-9076" data-line="9076">				i = 0,
</a><a name="line-9077" data-line="9077">				length = dataTypes.length,
</a><a name="line-9078" data-line="9078">				dataType,
</a><a name="line-9079" data-line="9079">				list,
</a><a name="line-9080" data-line="9080">				placeBefore;
</a><a name="line-9081" data-line="9081">
</a><a name="line-9082" data-line="9082">			// For each dataType in the dataTypeExpression
</a><a name="line-9083" data-line="9083">			for ( ; i &lt; length; i++ ) {
</a><a name="line-9084" data-line="9084">				dataType = dataTypes[ i ];
</a><a name="line-9085" data-line="9085">				// We control if we're asked to add before
</a><a name="line-9086" data-line="9086">				// any existing element
</a><a name="line-9087" data-line="9087">				placeBefore = /^\+/.test( dataType );
</a><a name="line-9088" data-line="9088">				if ( placeBefore ) {
</a><a name="line-9089" data-line="9089">					dataType = dataType.substr( 1 ) || &quot;*&quot;;
</a><a name="line-9090" data-line="9090">				}
</a><a name="line-9091" data-line="9091">				list = structure[ dataType ] = structure[ dataType ] || [];
</a><a name="line-9092" data-line="9092">				// then we add to the structure accordingly
</a><a name="line-9093" data-line="9093">				list[ placeBefore ? &quot;unshift&quot; : &quot;push&quot; ]( func );
</a><a name="line-9094" data-line="9094">			}
</a><a name="line-9095" data-line="9095">		}
</a><a name="line-9096" data-line="9096">	};
</a><a name="line-9097" data-line="9097">}
</a><a name="line-9098" data-line="9098">
</a><a name="line-9099" data-line="9099">// Base inspection function for prefilters and transports
</a><a name="line-9100" data-line="9100">function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
</a><a name="line-9101" data-line="9101">		dataType /* internal */, inspected /* internal */ ) {
</a><a name="line-9102" data-line="9102">
</a><a name="line-9103" data-line="9103">	dataType = dataType || options.dataTypes[ 0 ];
</a><a name="line-9104" data-line="9104">	inspected = inspected || {};
</a><a name="line-9105" data-line="9105">
</a><a name="line-9106" data-line="9106">	inspected[ dataType ] = true;
</a><a name="line-9107" data-line="9107">
</a><a name="line-9108" data-line="9108">	var list = structure[ dataType ],
</a><a name="line-9109" data-line="9109">		i = 0,
</a><a name="line-9110" data-line="9110">		length = list ? list.length : 0,
</a><a name="line-9111" data-line="9111">		executeOnly = ( structure === prefilters ),
</a><a name="line-9112" data-line="9112">		selection;
</a><a name="line-9113" data-line="9113">
</a><a name="line-9114" data-line="9114">	for ( ; i &lt; length &amp;&amp; ( executeOnly || !selection ); i++ ) {
</a><a name="line-9115" data-line="9115">		selection = list[ i ]( options, originalOptions, jqXHR );
</a><a name="line-9116" data-line="9116">		// If we got redirected to another dataType
</a><a name="line-9117" data-line="9117">		// we try there if executing only and not done already
</a><a name="line-9118" data-line="9118">		if ( typeof selection === &quot;string&quot; ) {
</a><a name="line-9119" data-line="9119">			if ( !executeOnly || inspected[ selection ] ) {
</a><a name="line-9120" data-line="9120">				selection = undefined;
</a><a name="line-9121" data-line="9121">			} else {
</a><a name="line-9122" data-line="9122">				options.dataTypes.unshift( selection );
</a><a name="line-9123" data-line="9123">				selection = inspectPrefiltersOrTransports(
</a><a name="line-9124" data-line="9124">						structure, options, originalOptions, jqXHR, selection, inspected );
</a><a name="line-9125" data-line="9125">			}
</a><a name="line-9126" data-line="9126">		}
</a><a name="line-9127" data-line="9127">	}
</a><a name="line-9128" data-line="9128">	// If we're only executing or nothing was selected
</a><a name="line-9129" data-line="9129">	// we try the catchall dataType if not done already
</a><a name="line-9130" data-line="9130">	if ( ( executeOnly || !selection ) &amp;&amp; !inspected[ &quot;*&quot; ] ) {
</a><a name="line-9131" data-line="9131">		selection = inspectPrefiltersOrTransports(
</a><a name="line-9132" data-line="9132">				structure, options, originalOptions, jqXHR, &quot;*&quot;, inspected );
</a><a name="line-9133" data-line="9133">	}
</a><a name="line-9134" data-line="9134">	// unnecessary when only executing (prefilters)
</a><a name="line-9135" data-line="9135">	// but it'll be ignored by the caller in that case
</a><a name="line-9136" data-line="9136">	return selection;
</a><a name="line-9137" data-line="9137">}
</a><a name="line-9138" data-line="9138">
</a><a name="line-9139" data-line="9139">// A special extend for ajax options
</a><a name="line-9140" data-line="9140">// that takes &quot;flat&quot; options (not to be deep extended)
</a><a name="line-9141" data-line="9141">// Fixes #9887
</a><a name="line-9142" data-line="9142">function ajaxExtend( target, src ) {
</a><a name="line-9143" data-line="9143">	var key, deep,
</a><a name="line-9144" data-line="9144">		flatOptions = jQuery.ajaxSettings.flatOptions || {};
</a><a name="line-9145" data-line="9145">	for ( key in src ) {
</a><a name="line-9146" data-line="9146">		if ( src[ key ] !== undefined ) {
</a><a name="line-9147" data-line="9147">			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
</a><a name="line-9148" data-line="9148">		}
</a><a name="line-9149" data-line="9149">	}
</a><a name="line-9150" data-line="9150">	if ( deep ) {
</a><a name="line-9151" data-line="9151">		jQuery.extend( true, target, deep );
</a><a name="line-9152" data-line="9152">	}
</a><a name="line-9153" data-line="9153">}
</a><a name="line-9154" data-line="9154">
</a><a name="line-9155" data-line="9155">jQuery.fn.extend({
</a><a name="line-9156" data-line="9156">	load: function( url, params, callback ) {
</a><a name="line-9157" data-line="9157">		if ( typeof url !== &quot;string&quot; &amp;&amp; _load ) {
</a><a name="line-9158" data-line="9158">			return _load.apply( this, arguments );
</a><a name="line-9159" data-line="9159">
</a><a name="line-9160" data-line="9160">		// Don't do a request if no elements are being requested
</a><a name="line-9161" data-line="9161">		} else if ( !this.length ) {
</a><a name="line-9162" data-line="9162">			return this;
</a><a name="line-9163" data-line="9163">		}
</a><a name="line-9164" data-line="9164">
</a><a name="line-9165" data-line="9165">		var off = url.indexOf( &quot; &quot; );
</a><a name="line-9166" data-line="9166">		if ( off &gt;= 0 ) {
</a><a name="line-9167" data-line="9167">			var selector = url.slice( off, url.length );
</a><a name="line-9168" data-line="9168">			url = url.slice( 0, off );
</a><a name="line-9169" data-line="9169">		}
</a><a name="line-9170" data-line="9170">
</a><a name="line-9171" data-line="9171">		// Default to a GET request
</a><a name="line-9172" data-line="9172">		var type = &quot;GET&quot;;
</a><a name="line-9173" data-line="9173">
</a><a name="line-9174" data-line="9174">		// If the second parameter was provided
</a><a name="line-9175" data-line="9175">		if ( params ) {
</a><a name="line-9176" data-line="9176">			// If it's a function
</a><a name="line-9177" data-line="9177">			if ( jQuery.isFunction( params ) ) {
</a><a name="line-9178" data-line="9178">				// We assume that it's the callback
</a><a name="line-9179" data-line="9179">				callback = params;
</a><a name="line-9180" data-line="9180">				params = undefined;
</a><a name="line-9181" data-line="9181">
</a><a name="line-9182" data-line="9182">			// Otherwise, build a param string
</a><a name="line-9183" data-line="9183">			} else if ( typeof params === &quot;object&quot; ) {
</a><a name="line-9184" data-line="9184">				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
</a><a name="line-9185" data-line="9185">				type = &quot;POST&quot;;
</a><a name="line-9186" data-line="9186">			}
</a><a name="line-9187" data-line="9187">		}
</a><a name="line-9188" data-line="9188">
</a><a name="line-9189" data-line="9189">		var self = this;
</a><a name="line-9190" data-line="9190">
</a><a name="line-9191" data-line="9191">		// Request the remote document
</a><a name="line-9192" data-line="9192">		jQuery.ajax({
</a><a name="line-9193" data-line="9193">			url: url,
</a><a name="line-9194" data-line="9194">			type: type,
</a><a name="line-9195" data-line="9195">			dataType: &quot;html&quot;,
</a><a name="line-9196" data-line="9196">			data: params,
</a><a name="line-9197" data-line="9197">			// Complete callback (responseText is used internally)
</a><a name="line-9198" data-line="9198">			complete: function( jqXHR, status, responseText ) {
</a><a name="line-9199" data-line="9199">				// Store the response as specified by the jqXHR object
</a><a name="line-9200" data-line="9200">				responseText = jqXHR.responseText;
</a><a name="line-9201" data-line="9201">				// If successful, inject the HTML into all the matched elements
</a><a name="line-9202" data-line="9202">				if ( jqXHR.isResolved() ) {
</a><a name="line-9203" data-line="9203">					// #4825: Get the actual response in case
</a><a name="line-9204" data-line="9204">					// a dataFilter is present in ajaxSettings
</a><a name="line-9205" data-line="9205">					jqXHR.done(function( r ) {
</a><a name="line-9206" data-line="9206">						responseText = r;
</a><a name="line-9207" data-line="9207">					});
</a><a name="line-9208" data-line="9208">					// See if a selector was specified
</a><a name="line-9209" data-line="9209">					self.html( selector ?
</a><a name="line-9210" data-line="9210">						// Create a dummy div to hold the results
</a><a name="line-9211" data-line="9211">						jQuery(&quot;&lt;div&gt;&quot;)
</a><a name="line-9212" data-line="9212">							// inject the contents of the document in, removing the scripts
</a><a name="line-9213" data-line="9213">							// to avoid any 'Permission Denied' errors in IE
</a><a name="line-9214" data-line="9214">							.append(responseText.replace(rscript, &quot;&quot;))
</a><a name="line-9215" data-line="9215">
</a><a name="line-9216" data-line="9216">							// Locate the specified elements
</a><a name="line-9217" data-line="9217">							.find(selector) :
</a><a name="line-9218" data-line="9218">
</a><a name="line-9219" data-line="9219">						// If not, just inject the full result
</a><a name="line-9220" data-line="9220">						responseText );
</a><a name="line-9221" data-line="9221">				}
</a><a name="line-9222" data-line="9222">
</a><a name="line-9223" data-line="9223">				if ( callback ) {
</a><a name="line-9224" data-line="9224">					self.each( callback, [ responseText, status, jqXHR ] );
</a><a name="line-9225" data-line="9225">				}
</a><a name="line-9226" data-line="9226">			}
</a><a name="line-9227" data-line="9227">		});
</a><a name="line-9228" data-line="9228">
</a><a name="line-9229" data-line="9229">		return this;
</a><a name="line-9230" data-line="9230">	},
</a><a name="line-9231" data-line="9231">
</a><a name="line-9232" data-line="9232">	serialize: function() {
</a><a name="line-9233" data-line="9233">		return jQuery.param( this.serializeArray() );
</a><a name="line-9234" data-line="9234">	},
</a><a name="line-9235" data-line="9235">
</a><a name="line-9236" data-line="9236">	serializeArray: function() {
</a><a name="line-9237" data-line="9237">		return this.map(function(){
</a><a name="line-9238" data-line="9238">			return this.elements ? jQuery.makeArray( this.elements ) : this;
</a><a name="line-9239" data-line="9239">		})
</a><a name="line-9240" data-line="9240">		.filter(function(){
</a><a name="line-9241" data-line="9241">			return this.name &amp;&amp; !this.disabled &amp;&amp;
</a><a name="line-9242" data-line="9242">				( this.checked || rselectTextarea.test( this.nodeName ) ||
</a><a name="line-9243" data-line="9243">					rinput.test( this.type ) );
</a><a name="line-9244" data-line="9244">		})
</a><a name="line-9245" data-line="9245">		.map(function( i, elem ){
</a><a name="line-9246" data-line="9246">			var val = jQuery( this ).val();
</a><a name="line-9247" data-line="9247">
</a><a name="line-9248" data-line="9248">			return val == null ?
</a><a name="line-9249" data-line="9249">				null :
</a><a name="line-9250" data-line="9250">				jQuery.isArray( val ) ?
</a><a name="line-9251" data-line="9251">					jQuery.map( val, function( val, i ){
</a><a name="line-9252" data-line="9252">						return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
</a><a name="line-9253" data-line="9253">					}) :
</a><a name="line-9254" data-line="9254">					{ name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
</a><a name="line-9255" data-line="9255">		}).get();
</a><a name="line-9256" data-line="9256">	}
</a><a name="line-9257" data-line="9257">});
</a><a name="line-9258" data-line="9258">
</a><a name="line-9259" data-line="9259">// Attach a bunch of functions for handling common AJAX events
</a><a name="line-9260" data-line="9260">jQuery.each( &quot;ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend&quot;.split( &quot; &quot; ), function( i, o ){
</a><a name="line-9261" data-line="9261">	jQuery.fn[ o ] = function( f ){
</a><a name="line-9262" data-line="9262">		return this.on( o, f );
</a><a name="line-9263" data-line="9263">	};
</a><a name="line-9264" data-line="9264">});
</a><a name="line-9265" data-line="9265">
</a><a name="line-9266" data-line="9266">jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
</a><a name="line-9267" data-line="9267">	jQuery[ method ] = function( url, data, callback, type ) {
</a><a name="line-9268" data-line="9268">		// shift arguments if data argument was omitted
</a><a name="line-9269" data-line="9269">		if ( jQuery.isFunction( data ) ) {
</a><a name="line-9270" data-line="9270">			type = type || callback;
</a><a name="line-9271" data-line="9271">			callback = data;
</a><a name="line-9272" data-line="9272">			data = undefined;
</a><a name="line-9273" data-line="9273">		}
</a><a name="line-9274" data-line="9274">
</a><a name="line-9275" data-line="9275">		return jQuery.ajax({
</a><a name="line-9276" data-line="9276">			type: method,
</a><a name="line-9277" data-line="9277">			url: url,
</a><a name="line-9278" data-line="9278">			data: data,
</a><a name="line-9279" data-line="9279">			success: callback,
</a><a name="line-9280" data-line="9280">			dataType: type
</a><a name="line-9281" data-line="9281">		});
</a><a name="line-9282" data-line="9282">	};
</a><a name="line-9283" data-line="9283">});
</a><a name="line-9284" data-line="9284">
</a><a name="line-9285" data-line="9285">jQuery.extend({
</a><a name="line-9286" data-line="9286">
</a><a name="line-9287" data-line="9287">	getScript: function( url, callback ) {
</a><a name="line-9288" data-line="9288">		return jQuery.get( url, undefined, callback, &quot;script&quot; );
</a><a name="line-9289" data-line="9289">	},
</a><a name="line-9290" data-line="9290">
</a><a name="line-9291" data-line="9291">	getJSON: function( url, data, callback ) {
</a><a name="line-9292" data-line="9292">		return jQuery.get( url, data, callback, &quot;json&quot; );
</a><a name="line-9293" data-line="9293">	},
</a><a name="line-9294" data-line="9294">
</a><a name="line-9295" data-line="9295">	// Creates a full fledged settings object into target
</a><a name="line-9296" data-line="9296">	// with both ajaxSettings and settings fields.
</a><a name="line-9297" data-line="9297">	// If target is omitted, writes into ajaxSettings.
</a><a name="line-9298" data-line="9298">	ajaxSetup: function( target, settings ) {
</a><a name="line-9299" data-line="9299">		if ( settings ) {
</a><a name="line-9300" data-line="9300">			// Building a settings object
</a><a name="line-9301" data-line="9301">			ajaxExtend( target, jQuery.ajaxSettings );
</a><a name="line-9302" data-line="9302">		} else {
</a><a name="line-9303" data-line="9303">			// Extending ajaxSettings
</a><a name="line-9304" data-line="9304">			settings = target;
</a><a name="line-9305" data-line="9305">			target = jQuery.ajaxSettings;
</a><a name="line-9306" data-line="9306">		}
</a><a name="line-9307" data-line="9307">		ajaxExtend( target, settings );
</a><a name="line-9308" data-line="9308">		return target;
</a><a name="line-9309" data-line="9309">	},
</a><a name="line-9310" data-line="9310">
</a><a name="line-9311" data-line="9311">	ajaxSettings: {
</a><a name="line-9312" data-line="9312">		url: ajaxLocation,
</a><a name="line-9313" data-line="9313">		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
</a><a name="line-9314" data-line="9314">		global: true,
</a><a name="line-9315" data-line="9315">		type: &quot;GET&quot;,
</a><a name="line-9316" data-line="9316">		contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
</a><a name="line-9317" data-line="9317">		processData: true,
</a><a name="line-9318" data-line="9318">		async: true,
</a><a name="line-9319" data-line="9319">		/*
</a><a name="line-9320" data-line="9320">		timeout: 0,
</a><a name="line-9321" data-line="9321">		data: null,
</a><a name="line-9322" data-line="9322">		dataType: null,
</a><a name="line-9323" data-line="9323">		username: null,
</a><a name="line-9324" data-line="9324">		password: null,
</a><a name="line-9325" data-line="9325">		cache: null,
</a><a name="line-9326" data-line="9326">		traditional: false,
</a><a name="line-9327" data-line="9327">		headers: {},
</a><a name="line-9328" data-line="9328">		*/
</a><a name="line-9329" data-line="9329">
</a><a name="line-9330" data-line="9330">		accepts: {
</a><a name="line-9331" data-line="9331">			xml: &quot;application/xml, text/xml&quot;,
</a><a name="line-9332" data-line="9332">			html: &quot;text/html&quot;,
</a><a name="line-9333" data-line="9333">			text: &quot;text/plain&quot;,
</a><a name="line-9334" data-line="9334">			json: &quot;application/json, text/javascript&quot;,
</a><a name="line-9335" data-line="9335">			&quot;*&quot;: allTypes
</a><a name="line-9336" data-line="9336">		},
</a><a name="line-9337" data-line="9337">
</a><a name="line-9338" data-line="9338">		contents: {
</a><a name="line-9339" data-line="9339">			xml: /xml/,
</a><a name="line-9340" data-line="9340">			html: /html/,
</a><a name="line-9341" data-line="9341">			json: /json/
</a><a name="line-9342" data-line="9342">		},
</a><a name="line-9343" data-line="9343">
</a><a name="line-9344" data-line="9344">		responseFields: {
</a><a name="line-9345" data-line="9345">			xml: &quot;responseXML&quot;,
</a><a name="line-9346" data-line="9346">			text: &quot;responseText&quot;
</a><a name="line-9347" data-line="9347">		},
</a><a name="line-9348" data-line="9348">
</a><a name="line-9349" data-line="9349">		// List of data converters
</a><a name="line-9350" data-line="9350">		// 1) key format is &quot;source_type destination_type&quot; (a single space in-between)
</a><a name="line-9351" data-line="9351">		// 2) the catchall symbol &quot;*&quot; can be used for source_type
</a><a name="line-9352" data-line="9352">		converters: {
</a><a name="line-9353" data-line="9353">
</a><a name="line-9354" data-line="9354">			// Convert anything to text
</a><a name="line-9355" data-line="9355">			&quot;* text&quot;: window.String,
</a><a name="line-9356" data-line="9356">
</a><a name="line-9357" data-line="9357">			// Text to html (true = no transformation)
</a><a name="line-9358" data-line="9358">			&quot;text html&quot;: true,
</a><a name="line-9359" data-line="9359">
</a><a name="line-9360" data-line="9360">			// Evaluate text as a json expression
</a><a name="line-9361" data-line="9361">			&quot;text json&quot;: jQuery.parseJSON,
</a><a name="line-9362" data-line="9362">
</a><a name="line-9363" data-line="9363">			// Parse text as xml
</a><a name="line-9364" data-line="9364">			&quot;text xml&quot;: jQuery.parseXML
</a><a name="line-9365" data-line="9365">		},
</a><a name="line-9366" data-line="9366">
</a><a name="line-9367" data-line="9367">		// For options that shouldn't be deep extended:
</a><a name="line-9368" data-line="9368">		// you can add your own custom options here if
</a><a name="line-9369" data-line="9369">		// and when you create one that shouldn't be
</a><a name="line-9370" data-line="9370">		// deep extended (see ajaxExtend)
</a><a name="line-9371" data-line="9371">		flatOptions: {
</a><a name="line-9372" data-line="9372">			context: true,
</a><a name="line-9373" data-line="9373">			url: true
</a><a name="line-9374" data-line="9374">		}
</a><a name="line-9375" data-line="9375">	},
</a><a name="line-9376" data-line="9376">
</a><a name="line-9377" data-line="9377">	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
</a><a name="line-9378" data-line="9378">	ajaxTransport: addToPrefiltersOrTransports( transports ),
</a><a name="line-9379" data-line="9379">
</a><a name="line-9380" data-line="9380">	// Main method
</a><a name="line-9381" data-line="9381">	ajax: function( url, options ) {
</a><a name="line-9382" data-line="9382">
</a><a name="line-9383" data-line="9383">		// If url is an object, simulate pre-1.5 signature
</a><a name="line-9384" data-line="9384">		if ( typeof url === &quot;object&quot; ) {
</a><a name="line-9385" data-line="9385">			options = url;
</a><a name="line-9386" data-line="9386">			url = undefined;
</a><a name="line-9387" data-line="9387">		}
</a><a name="line-9388" data-line="9388">
</a><a name="line-9389" data-line="9389">		// Force options to be an object
</a><a name="line-9390" data-line="9390">		options = options || {};
</a><a name="line-9391" data-line="9391">
</a><a name="line-9392" data-line="9392">		var // Create the final options object
</a><a name="line-9393" data-line="9393">			s = jQuery.ajaxSetup( {}, options ),
</a><a name="line-9394" data-line="9394">			// Callbacks context
</a><a name="line-9395" data-line="9395">			callbackContext = s.context || s,
</a><a name="line-9396" data-line="9396">			// Context for global events
</a><a name="line-9397" data-line="9397">			// It's the callbackContext if one was provided in the options
</a><a name="line-9398" data-line="9398">			// and if it's a DOM node or a jQuery collection
</a><a name="line-9399" data-line="9399">			globalEventContext = callbackContext !== s &amp;&amp;
</a><a name="line-9400" data-line="9400">				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
</a><a name="line-9401" data-line="9401">						jQuery( callbackContext ) : jQuery.event,
</a><a name="line-9402" data-line="9402">			// Deferreds
</a><a name="line-9403" data-line="9403">			deferred = jQuery.Deferred(),
</a><a name="line-9404" data-line="9404">			completeDeferred = jQuery.Callbacks( &quot;once memory&quot; ),
</a><a name="line-9405" data-line="9405">			// Status-dependent callbacks
</a><a name="line-9406" data-line="9406">			statusCode = s.statusCode || {},
</a><a name="line-9407" data-line="9407">			// ifModified key
</a><a name="line-9408" data-line="9408">			ifModifiedKey,
</a><a name="line-9409" data-line="9409">			// Headers (they are sent all at once)
</a><a name="line-9410" data-line="9410">			requestHeaders = {},
</a><a name="line-9411" data-line="9411">			requestHeadersNames = {},
</a><a name="line-9412" data-line="9412">			// Response headers
</a><a name="line-9413" data-line="9413">			responseHeadersString,
</a><a name="line-9414" data-line="9414">			responseHeaders,
</a><a name="line-9415" data-line="9415">			// transport
</a><a name="line-9416" data-line="9416">			transport,
</a><a name="line-9417" data-line="9417">			// timeout handle
</a><a name="line-9418" data-line="9418">			timeoutTimer,
</a><a name="line-9419" data-line="9419">			// Cross-domain detection vars
</a><a name="line-9420" data-line="9420">			parts,
</a><a name="line-9421" data-line="9421">			// The jqXHR state
</a><a name="line-9422" data-line="9422">			state = 0,
</a><a name="line-9423" data-line="9423">			// To know if global events are to be dispatched
</a><a name="line-9424" data-line="9424">			fireGlobals,
</a><a name="line-9425" data-line="9425">			// Loop variable
</a><a name="line-9426" data-line="9426">			i,
</a><a name="line-9427" data-line="9427">			// Fake xhr
</a><a name="line-9428" data-line="9428">			jqXHR = {
</a><a name="line-9429" data-line="9429">
</a><a name="line-9430" data-line="9430">				readyState: 0,
</a><a name="line-9431" data-line="9431">
</a><a name="line-9432" data-line="9432">				// Caches the header
</a><a name="line-9433" data-line="9433">				setRequestHeader: function( name, value ) {
</a><a name="line-9434" data-line="9434">					if ( !state ) {
</a><a name="line-9435" data-line="9435">						var lname = name.toLowerCase();
</a><a name="line-9436" data-line="9436">						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
</a><a name="line-9437" data-line="9437">						requestHeaders[ name ] = value;
</a><a name="line-9438" data-line="9438">					}
</a><a name="line-9439" data-line="9439">					return this;
</a><a name="line-9440" data-line="9440">				},
</a><a name="line-9441" data-line="9441">
</a><a name="line-9442" data-line="9442">				// Raw string
</a><a name="line-9443" data-line="9443">				getAllResponseHeaders: function() {
</a><a name="line-9444" data-line="9444">					return state === 2 ? responseHeadersString : null;
</a><a name="line-9445" data-line="9445">				},
</a><a name="line-9446" data-line="9446">
</a><a name="line-9447" data-line="9447">				// Builds headers hashtable if needed
</a><a name="line-9448" data-line="9448">				getResponseHeader: function( key ) {
</a><a name="line-9449" data-line="9449">					var match;
</a><a name="line-9450" data-line="9450">					if ( state === 2 ) {
</a><a name="line-9451" data-line="9451">						if ( !responseHeaders ) {
</a><a name="line-9452" data-line="9452">							responseHeaders = {};
</a><a name="line-9453" data-line="9453">							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
</a><a name="line-9454" data-line="9454">								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
</a><a name="line-9455" data-line="9455">							}
</a><a name="line-9456" data-line="9456">						}
</a><a name="line-9457" data-line="9457">						match = responseHeaders[ key.toLowerCase() ];
</a><a name="line-9458" data-line="9458">					}
</a><a name="line-9459" data-line="9459">					return match === undefined ? null : match;
</a><a name="line-9460" data-line="9460">				},
</a><a name="line-9461" data-line="9461">
</a><a name="line-9462" data-line="9462">				// Overrides response content-type header
</a><a name="line-9463" data-line="9463">				overrideMimeType: function( type ) {
</a><a name="line-9464" data-line="9464">					if ( !state ) {
</a><a name="line-9465" data-line="9465">						s.mimeType = type;
</a><a name="line-9466" data-line="9466">					}
</a><a name="line-9467" data-line="9467">					return this;
</a><a name="line-9468" data-line="9468">				},
</a><a name="line-9469" data-line="9469">
</a><a name="line-9470" data-line="9470">				// Cancel the request
</a><a name="line-9471" data-line="9471">				abort: function( statusText ) {
</a><a name="line-9472" data-line="9472">					statusText = statusText || &quot;abort&quot;;
</a><a name="line-9473" data-line="9473">					if ( transport ) {
</a><a name="line-9474" data-line="9474">						transport.abort( statusText );
</a><a name="line-9475" data-line="9475">					}
</a><a name="line-9476" data-line="9476">					done( 0, statusText );
</a><a name="line-9477" data-line="9477">					return this;
</a><a name="line-9478" data-line="9478">				}
</a><a name="line-9479" data-line="9479">			};
</a><a name="line-9480" data-line="9480">
</a><a name="line-9481" data-line="9481">		// Callback for when everything is done
</a><a name="line-9482" data-line="9482">		// It is defined here because jslint complains if it is declared
</a><a name="line-9483" data-line="9483">		// at the end of the function (which would be more logical and readable)
</a><a name="line-9484" data-line="9484">		function done( status, nativeStatusText, responses, headers ) {
</a><a name="line-9485" data-line="9485">
</a><a name="line-9486" data-line="9486">			// Called once
</a><a name="line-9487" data-line="9487">			if ( state === 2 ) {
</a><a name="line-9488" data-line="9488">				return;
</a><a name="line-9489" data-line="9489">			}
</a><a name="line-9490" data-line="9490">
</a><a name="line-9491" data-line="9491">			// State is &quot;done&quot; now
</a><a name="line-9492" data-line="9492">			state = 2;
</a><a name="line-9493" data-line="9493">
</a><a name="line-9494" data-line="9494">			// Clear timeout if it exists
</a><a name="line-9495" data-line="9495">			if ( timeoutTimer ) {
</a><a name="line-9496" data-line="9496">				clearTimeout( timeoutTimer );
</a><a name="line-9497" data-line="9497">			}
</a><a name="line-9498" data-line="9498">
</a><a name="line-9499" data-line="9499">			// Dereference transport for early garbage collection
</a><a name="line-9500" data-line="9500">			// (no matter how long the jqXHR object will be used)
</a><a name="line-9501" data-line="9501">			transport = undefined;
</a><a name="line-9502" data-line="9502">
</a><a name="line-9503" data-line="9503">			// Cache response headers
</a><a name="line-9504" data-line="9504">			responseHeadersString = headers || &quot;&quot;;
</a><a name="line-9505" data-line="9505">
</a><a name="line-9506" data-line="9506">			// Set readyState
</a><a name="line-9507" data-line="9507">			jqXHR.readyState = status &gt; 0 ? 4 : 0;
</a><a name="line-9508" data-line="9508">
</a><a name="line-9509" data-line="9509">			var isSuccess,
</a><a name="line-9510" data-line="9510">				success,
</a><a name="line-9511" data-line="9511">				error,
</a><a name="line-9512" data-line="9512">				statusText = nativeStatusText,
</a><a name="line-9513" data-line="9513">				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
</a><a name="line-9514" data-line="9514">				lastModified,
</a><a name="line-9515" data-line="9515">				etag;
</a><a name="line-9516" data-line="9516">
</a><a name="line-9517" data-line="9517">			// If successful, handle type chaining
</a><a name="line-9518" data-line="9518">			if ( status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304 ) {
</a><a name="line-9519" data-line="9519">
</a><a name="line-9520" data-line="9520">				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
</a><a name="line-9521" data-line="9521">				if ( s.ifModified ) {
</a><a name="line-9522" data-line="9522">
</a><a name="line-9523" data-line="9523">					if ( ( lastModified = jqXHR.getResponseHeader( &quot;Last-Modified&quot; ) ) ) {
</a><a name="line-9524" data-line="9524">						jQuery.lastModified[ ifModifiedKey ] = lastModified;
</a><a name="line-9525" data-line="9525">					}
</a><a name="line-9526" data-line="9526">					if ( ( etag = jqXHR.getResponseHeader( &quot;Etag&quot; ) ) ) {
</a><a name="line-9527" data-line="9527">						jQuery.etag[ ifModifiedKey ] = etag;
</a><a name="line-9528" data-line="9528">					}
</a><a name="line-9529" data-line="9529">				}
</a><a name="line-9530" data-line="9530">
</a><a name="line-9531" data-line="9531">				// If not modified
</a><a name="line-9532" data-line="9532">				if ( status === 304 ) {
</a><a name="line-9533" data-line="9533">
</a><a name="line-9534" data-line="9534">					statusText = &quot;notmodified&quot;;
</a><a name="line-9535" data-line="9535">					isSuccess = true;
</a><a name="line-9536" data-line="9536">
</a><a name="line-9537" data-line="9537">				// If we have data
</a><a name="line-9538" data-line="9538">				} else {
</a><a name="line-9539" data-line="9539">
</a><a name="line-9540" data-line="9540">					try {
</a><a name="line-9541" data-line="9541">						success = ajaxConvert( s, response );
</a><a name="line-9542" data-line="9542">						statusText = &quot;success&quot;;
</a><a name="line-9543" data-line="9543">						isSuccess = true;
</a><a name="line-9544" data-line="9544">					} catch(e) {
</a><a name="line-9545" data-line="9545">						// We have a parsererror
</a><a name="line-9546" data-line="9546">						statusText = &quot;parsererror&quot;;
</a><a name="line-9547" data-line="9547">						error = e;
</a><a name="line-9548" data-line="9548">					}
</a><a name="line-9549" data-line="9549">				}
</a><a name="line-9550" data-line="9550">			} else {
</a><a name="line-9551" data-line="9551">				// We extract error from statusText
</a><a name="line-9552" data-line="9552">				// then normalize statusText and status for non-aborts
</a><a name="line-9553" data-line="9553">				error = statusText;
</a><a name="line-9554" data-line="9554">				if ( !statusText || status ) {
</a><a name="line-9555" data-line="9555">					statusText = &quot;error&quot;;
</a><a name="line-9556" data-line="9556">					if ( status &lt; 0 ) {
</a><a name="line-9557" data-line="9557">						status = 0;
</a><a name="line-9558" data-line="9558">					}
</a><a name="line-9559" data-line="9559">				}
</a><a name="line-9560" data-line="9560">			}
</a><a name="line-9561" data-line="9561">
</a><a name="line-9562" data-line="9562">			// Set data for the fake xhr object
</a><a name="line-9563" data-line="9563">			jqXHR.status = status;
</a><a name="line-9564" data-line="9564">			jqXHR.statusText = &quot;&quot; + ( nativeStatusText || statusText );
</a><a name="line-9565" data-line="9565">
</a><a name="line-9566" data-line="9566">			// Success/Error
</a><a name="line-9567" data-line="9567">			if ( isSuccess ) {
</a><a name="line-9568" data-line="9568">				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
</a><a name="line-9569" data-line="9569">			} else {
</a><a name="line-9570" data-line="9570">				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
</a><a name="line-9571" data-line="9571">			}
</a><a name="line-9572" data-line="9572">
</a><a name="line-9573" data-line="9573">			// Status-dependent callbacks
</a><a name="line-9574" data-line="9574">			jqXHR.statusCode( statusCode );
</a><a name="line-9575" data-line="9575">			statusCode = undefined;
</a><a name="line-9576" data-line="9576">
</a><a name="line-9577" data-line="9577">			if ( fireGlobals ) {
</a><a name="line-9578" data-line="9578">				globalEventContext.trigger( &quot;ajax&quot; + ( isSuccess ? &quot;Success&quot; : &quot;Error&quot; ),
</a><a name="line-9579" data-line="9579">						[ jqXHR, s, isSuccess ? success : error ] );
</a><a name="line-9580" data-line="9580">			}
</a><a name="line-9581" data-line="9581">
</a><a name="line-9582" data-line="9582">			// Complete
</a><a name="line-9583" data-line="9583">			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
</a><a name="line-9584" data-line="9584">
</a><a name="line-9585" data-line="9585">			if ( fireGlobals ) {
</a><a name="line-9586" data-line="9586">				globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
</a><a name="line-9587" data-line="9587">				// Handle the global AJAX counter
</a><a name="line-9588" data-line="9588">				if ( !( --jQuery.active ) ) {
</a><a name="line-9589" data-line="9589">					jQuery.event.trigger( &quot;ajaxStop&quot; );
</a><a name="line-9590" data-line="9590">				}
</a><a name="line-9591" data-line="9591">			}
</a><a name="line-9592" data-line="9592">		}
</a><a name="line-9593" data-line="9593">
</a><a name="line-9594" data-line="9594">		// Attach deferreds
</a><a name="line-9595" data-line="9595">		deferred.promise( jqXHR );
</a><a name="line-9596" data-line="9596">		jqXHR.success = jqXHR.done;
</a><a name="line-9597" data-line="9597">		jqXHR.error = jqXHR.fail;
</a><a name="line-9598" data-line="9598">		jqXHR.complete = completeDeferred.add;
</a><a name="line-9599" data-line="9599">
</a><a name="line-9600" data-line="9600">		// Status-dependent callbacks
</a><a name="line-9601" data-line="9601">		jqXHR.statusCode = function( map ) {
</a><a name="line-9602" data-line="9602">			if ( map ) {
</a><a name="line-9603" data-line="9603">				var tmp;
</a><a name="line-9604" data-line="9604">				if ( state &lt; 2 ) {
</a><a name="line-9605" data-line="9605">					for ( tmp in map ) {
</a><a name="line-9606" data-line="9606">						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
</a><a name="line-9607" data-line="9607">					}
</a><a name="line-9608" data-line="9608">				} else {
</a><a name="line-9609" data-line="9609">					tmp = map[ jqXHR.status ];
</a><a name="line-9610" data-line="9610">					jqXHR.then( tmp, tmp );
</a><a name="line-9611" data-line="9611">				}
</a><a name="line-9612" data-line="9612">			}
</a><a name="line-9613" data-line="9613">			return this;
</a><a name="line-9614" data-line="9614">		};
</a><a name="line-9615" data-line="9615">
</a><a name="line-9616" data-line="9616">		// Remove hash character (#7531: and string promotion)
</a><a name="line-9617" data-line="9617">		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
</a><a name="line-9618" data-line="9618">		// We also use the url parameter if available
</a><a name="line-9619" data-line="9619">		s.url = ( ( url || s.url ) + &quot;&quot; ).replace( rhash, &quot;&quot; ).replace( rprotocol, ajaxLocParts[ 1 ] + &quot;//&quot; );
</a><a name="line-9620" data-line="9620">
</a><a name="line-9621" data-line="9621">		// Extract dataTypes list
</a><a name="line-9622" data-line="9622">		s.dataTypes = jQuery.trim( s.dataType || &quot;*&quot; ).toLowerCase().split( rspacesAjax );
</a><a name="line-9623" data-line="9623">
</a><a name="line-9624" data-line="9624">		// Determine if a cross-domain request is in order
</a><a name="line-9625" data-line="9625">		if ( s.crossDomain == null ) {
</a><a name="line-9626" data-line="9626">			parts = rurl.exec( s.url.toLowerCase() );
</a><a name="line-9627" data-line="9627">			s.crossDomain = !!( parts &amp;&amp;
</a><a name="line-9628" data-line="9628">				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
</a><a name="line-9629" data-line="9629">					( parts[ 3 ] || ( parts[ 1 ] === &quot;http:&quot; ? 80 : 443 ) ) !=
</a><a name="line-9630" data-line="9630">						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === &quot;http:&quot; ? 80 : 443 ) ) )
</a><a name="line-9631" data-line="9631">			);
</a><a name="line-9632" data-line="9632">		}
</a><a name="line-9633" data-line="9633">
</a><a name="line-9634" data-line="9634">		// Convert data if not already a string
</a><a name="line-9635" data-line="9635">		if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
</a><a name="line-9636" data-line="9636">			s.data = jQuery.param( s.data, s.traditional );
</a><a name="line-9637" data-line="9637">		}
</a><a name="line-9638" data-line="9638">
</a><a name="line-9639" data-line="9639">		// Apply prefilters
</a><a name="line-9640" data-line="9640">		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
</a><a name="line-9641" data-line="9641">
</a><a name="line-9642" data-line="9642">		// If request was aborted inside a prefilter, stop there
</a><a name="line-9643" data-line="9643">		if ( state === 2 ) {
</a><a name="line-9644" data-line="9644">			return false;
</a><a name="line-9645" data-line="9645">		}
</a><a name="line-9646" data-line="9646">
</a><a name="line-9647" data-line="9647">		// We can fire global events as of now if asked to
</a><a name="line-9648" data-line="9648">		fireGlobals = s.global;
</a><a name="line-9649" data-line="9649">
</a><a name="line-9650" data-line="9650">		// Uppercase the type
</a><a name="line-9651" data-line="9651">		s.type = s.type.toUpperCase();
</a><a name="line-9652" data-line="9652">
</a><a name="line-9653" data-line="9653">		// Determine if request has content
</a><a name="line-9654" data-line="9654">		s.hasContent = !rnoContent.test( s.type );
</a><a name="line-9655" data-line="9655">
</a><a name="line-9656" data-line="9656">		// Watch for a new set of requests
</a><a name="line-9657" data-line="9657">		if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
</a><a name="line-9658" data-line="9658">			jQuery.event.trigger( &quot;ajaxStart&quot; );
</a><a name="line-9659" data-line="9659">		}
</a><a name="line-9660" data-line="9660">
</a><a name="line-9661" data-line="9661">		// More options handling for requests with no content
</a><a name="line-9662" data-line="9662">		if ( !s.hasContent ) {
</a><a name="line-9663" data-line="9663">
</a><a name="line-9664" data-line="9664">			// If data is available, append data to url
</a><a name="line-9665" data-line="9665">			if ( s.data ) {
</a><a name="line-9666" data-line="9666">				s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data;
</a><a name="line-9667" data-line="9667">				// #9682: remove data so that it's not used in an eventual retry
</a><a name="line-9668" data-line="9668">				delete s.data;
</a><a name="line-9669" data-line="9669">			}
</a><a name="line-9670" data-line="9670">
</a><a name="line-9671" data-line="9671">			// Get ifModifiedKey before adding the anti-cache parameter
</a><a name="line-9672" data-line="9672">			ifModifiedKey = s.url;
</a><a name="line-9673" data-line="9673">
</a><a name="line-9674" data-line="9674">			// Add anti-cache in url if needed
</a><a name="line-9675" data-line="9675">			if ( s.cache === false ) {
</a><a name="line-9676" data-line="9676">
</a><a name="line-9677" data-line="9677">				var ts = jQuery.now(),
</a><a name="line-9678" data-line="9678">					// try replacing _= if it is there
</a><a name="line-9679" data-line="9679">					ret = s.url.replace( rts, &quot;$1_=&quot; + ts );
</a><a name="line-9680" data-line="9680">
</a><a name="line-9681" data-line="9681">				// if nothing was replaced, add timestamp to the end
</a><a name="line-9682" data-line="9682">				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ts : &quot;&quot; );
</a><a name="line-9683" data-line="9683">			}
</a><a name="line-9684" data-line="9684">		}
</a><a name="line-9685" data-line="9685">
</a><a name="line-9686" data-line="9686">		// Set the correct header, if data is being sent
</a><a name="line-9687" data-line="9687">		if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
</a><a name="line-9688" data-line="9688">			jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
</a><a name="line-9689" data-line="9689">		}
</a><a name="line-9690" data-line="9690">
</a><a name="line-9691" data-line="9691">		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
</a><a name="line-9692" data-line="9692">		if ( s.ifModified ) {
</a><a name="line-9693" data-line="9693">			ifModifiedKey = ifModifiedKey || s.url;
</a><a name="line-9694" data-line="9694">			if ( jQuery.lastModified[ ifModifiedKey ] ) {
</a><a name="line-9695" data-line="9695">				jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ ifModifiedKey ] );
</a><a name="line-9696" data-line="9696">			}
</a><a name="line-9697" data-line="9697">			if ( jQuery.etag[ ifModifiedKey ] ) {
</a><a name="line-9698" data-line="9698">				jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ ifModifiedKey ] );
</a><a name="line-9699" data-line="9699">			}
</a><a name="line-9700" data-line="9700">		}
</a><a name="line-9701" data-line="9701">
</a><a name="line-9702" data-line="9702">		// Set the Accepts header for the server, depending on the dataType
</a><a name="line-9703" data-line="9703">		jqXHR.setRequestHeader(
</a><a name="line-9704" data-line="9704">			&quot;Accept&quot;,
</a><a name="line-9705" data-line="9705">			s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?
</a><a name="line-9706" data-line="9706">				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
</a><a name="line-9707" data-line="9707">				s.accepts[ &quot;*&quot; ]
</a><a name="line-9708" data-line="9708">		);
</a><a name="line-9709" data-line="9709">
</a><a name="line-9710" data-line="9710">		// Check for headers option
</a><a name="line-9711" data-line="9711">		for ( i in s.headers ) {
</a><a name="line-9712" data-line="9712">			jqXHR.setRequestHeader( i, s.headers[ i ] );
</a><a name="line-9713" data-line="9713">		}
</a><a name="line-9714" data-line="9714">
</a><a name="line-9715" data-line="9715">		// Allow custom headers/mimetypes and early abort
</a><a name="line-9716" data-line="9716">		if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
</a><a name="line-9717" data-line="9717">				// Abort if not done already
</a><a name="line-9718" data-line="9718">				jqXHR.abort();
</a><a name="line-9719" data-line="9719">				return false;
</a><a name="line-9720" data-line="9720">
</a><a name="line-9721" data-line="9721">		}
</a><a name="line-9722" data-line="9722">
</a><a name="line-9723" data-line="9723">		// Install callbacks on deferreds
</a><a name="line-9724" data-line="9724">		for ( i in { success: 1, error: 1, complete: 1 } ) {
</a><a name="line-9725" data-line="9725">			jqXHR[ i ]( s[ i ] );
</a><a name="line-9726" data-line="9726">		}
</a><a name="line-9727" data-line="9727">
</a><a name="line-9728" data-line="9728">		// Get transport
</a><a name="line-9729" data-line="9729">		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
</a><a name="line-9730" data-line="9730">
</a><a name="line-9731" data-line="9731">		// If no transport, we auto-abort
</a><a name="line-9732" data-line="9732">		if ( !transport ) {
</a><a name="line-9733" data-line="9733">			done( -1, &quot;No Transport&quot; );
</a><a name="line-9734" data-line="9734">		} else {
</a><a name="line-9735" data-line="9735">			jqXHR.readyState = 1;
</a><a name="line-9736" data-line="9736">			// Send global event
</a><a name="line-9737" data-line="9737">			if ( fireGlobals ) {
</a><a name="line-9738" data-line="9738">				globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
</a><a name="line-9739" data-line="9739">			}
</a><a name="line-9740" data-line="9740">			// Timeout
</a><a name="line-9741" data-line="9741">			if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
</a><a name="line-9742" data-line="9742">				timeoutTimer = setTimeout( function(){
</a><a name="line-9743" data-line="9743">					jqXHR.abort( &quot;timeout&quot; );
</a><a name="line-9744" data-line="9744">				}, s.timeout );
</a><a name="line-9745" data-line="9745">			}
</a><a name="line-9746" data-line="9746">
</a><a name="line-9747" data-line="9747">			try {
</a><a name="line-9748" data-line="9748">				state = 1;
</a><a name="line-9749" data-line="9749">				transport.send( requestHeaders, done );
</a><a name="line-9750" data-line="9750">			} catch (e) {
</a><a name="line-9751" data-line="9751">				// Propagate exception as error if not done
</a><a name="line-9752" data-line="9752">				if ( state &lt; 2 ) {
</a><a name="line-9753" data-line="9753">					done( -1, e );
</a><a name="line-9754" data-line="9754">				// Simply rethrow otherwise
</a><a name="line-9755" data-line="9755">				} else {
</a><a name="line-9756" data-line="9756">					throw e;
</a><a name="line-9757" data-line="9757">				}
</a><a name="line-9758" data-line="9758">			}
</a><a name="line-9759" data-line="9759">		}
</a><a name="line-9760" data-line="9760">
</a><a name="line-9761" data-line="9761">		return jqXHR;
</a><a name="line-9762" data-line="9762">	},
</a><a name="line-9763" data-line="9763">
</a><a name="line-9764" data-line="9764">	// Serialize an array of form elements or a set of
</a><a name="line-9765" data-line="9765">	// key/values into a query string
</a><a name="line-9766" data-line="9766">	param: function( a, traditional ) {
</a><a name="line-9767" data-line="9767">		var s = [],
</a><a name="line-9768" data-line="9768">			add = function( key, value ) {
</a><a name="line-9769" data-line="9769">				// If value is a function, invoke it and return its value
</a><a name="line-9770" data-line="9770">				value = jQuery.isFunction( value ) ? value() : value;
</a><a name="line-9771" data-line="9771">				s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( value );
</a><a name="line-9772" data-line="9772">			};
</a><a name="line-9773" data-line="9773">
</a><a name="line-9774" data-line="9774">		// Set traditional to true for jQuery &lt;= 1.3.2 behavior.
</a><a name="line-9775" data-line="9775">		if ( traditional === undefined ) {
</a><a name="line-9776" data-line="9776">			traditional = jQuery.ajaxSettings.traditional;
</a><a name="line-9777" data-line="9777">		}
</a><a name="line-9778" data-line="9778">
</a><a name="line-9779" data-line="9779">		// If an array was passed in, assume that it is an array of form elements.
</a><a name="line-9780" data-line="9780">		if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
</a><a name="line-9781" data-line="9781">			// Serialize the form elements
</a><a name="line-9782" data-line="9782">			jQuery.each( a, function() {
</a><a name="line-9783" data-line="9783">				add( this.name, this.value );
</a><a name="line-9784" data-line="9784">			});
</a><a name="line-9785" data-line="9785">
</a><a name="line-9786" data-line="9786">		} else {
</a><a name="line-9787" data-line="9787">			// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
</a><a name="line-9788" data-line="9788">			// did it), otherwise encode params recursively.
</a><a name="line-9789" data-line="9789">			for ( var prefix in a ) {
</a><a name="line-9790" data-line="9790">				buildParams( prefix, a[ prefix ], traditional, add );
</a><a name="line-9791" data-line="9791">			}
</a><a name="line-9792" data-line="9792">		}
</a><a name="line-9793" data-line="9793">
</a><a name="line-9794" data-line="9794">		// Return the resulting serialization
</a><a name="line-9795" data-line="9795">		return s.join( &quot;&amp;&quot; ).replace( r20, &quot;+&quot; );
</a><a name="line-9796" data-line="9796">	}
</a><a name="line-9797" data-line="9797">});
</a><a name="line-9798" data-line="9798">
</a><a name="line-9799" data-line="9799">function buildParams( prefix, obj, traditional, add ) {
</a><a name="line-9800" data-line="9800">	if ( jQuery.isArray( obj ) ) {
</a><a name="line-9801" data-line="9801">		// Serialize array item.
</a><a name="line-9802" data-line="9802">		jQuery.each( obj, function( i, v ) {
</a><a name="line-9803" data-line="9803">			if ( traditional || rbracket.test( prefix ) ) {
</a><a name="line-9804" data-line="9804">				// Treat each array item as a scalar.
</a><a name="line-9805" data-line="9805">				add( prefix, v );
</a><a name="line-9806" data-line="9806">
</a><a name="line-9807" data-line="9807">			} else {
</a><a name="line-9808" data-line="9808">				// If array item is non-scalar (array or object), encode its
</a><a name="line-9809" data-line="9809">				// numeric index to resolve deserialization ambiguity issues.
</a><a name="line-9810" data-line="9810">				// Note that rack (as of 1.0.0) can't currently deserialize
</a><a name="line-9811" data-line="9811">				// nested arrays properly, and attempting to do so may cause
</a><a name="line-9812" data-line="9812">				// a server error. Possible fixes are to modify rack's
</a><a name="line-9813" data-line="9813">				// deserialization algorithm or to provide an option or flag
</a><a name="line-9814" data-line="9814">				// to force array serialization to be shallow.
</a><a name="line-9815" data-line="9815">				buildParams( prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; ? i : &quot;&quot; ) + &quot;]&quot;, v, traditional, add );
</a><a name="line-9816" data-line="9816">			}
</a><a name="line-9817" data-line="9817">		});
</a><a name="line-9818" data-line="9818">
</a><a name="line-9819" data-line="9819">	} else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) {
</a><a name="line-9820" data-line="9820">		// Serialize object item.
</a><a name="line-9821" data-line="9821">		for ( var name in obj ) {
</a><a name="line-9822" data-line="9822">			buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
</a><a name="line-9823" data-line="9823">		}
</a><a name="line-9824" data-line="9824">
</a><a name="line-9825" data-line="9825">	} else {
</a><a name="line-9826" data-line="9826">		// Serialize scalar item.
</a><a name="line-9827" data-line="9827">		add( prefix, obj );
</a><a name="line-9828" data-line="9828">	}
</a><a name="line-9829" data-line="9829">}
</a><a name="line-9830" data-line="9830">
</a><a name="line-9831" data-line="9831">// This is still on the jQuery object... for now
</a><a name="line-9832" data-line="9832">// Want to move this to jQuery.ajax some day
</a><a name="line-9833" data-line="9833">jQuery.extend({
</a><a name="line-9834" data-line="9834">
</a><a name="line-9835" data-line="9835">	// Counter for holding the number of active queries
</a><a name="line-9836" data-line="9836">	active: 0,
</a><a name="line-9837" data-line="9837">
</a><a name="line-9838" data-line="9838">	// Last-Modified header cache for next request
</a><a name="line-9839" data-line="9839">	lastModified: {},
</a><a name="line-9840" data-line="9840">	etag: {}
</a><a name="line-9841" data-line="9841">
</a><a name="line-9842" data-line="9842">});
</a><a name="line-9843" data-line="9843">
</a><a name="line-9844" data-line="9844">/* Handles responses to an ajax request:
</a><a name="line-9845" data-line="9845"> * - sets all responseXXX fields accordingly
</a><a name="line-9846" data-line="9846"> * - finds the right dataType (mediates between content-type and expected dataType)
</a><a name="line-9847" data-line="9847"> * - returns the corresponding response
</a><a name="line-9848" data-line="9848"> */
</a><a name="line-9849" data-line="9849">function ajaxHandleResponses( s, jqXHR, responses ) {
</a><a name="line-9850" data-line="9850">
</a><a name="line-9851" data-line="9851">	var contents = s.contents,
</a><a name="line-9852" data-line="9852">		dataTypes = s.dataTypes,
</a><a name="line-9853" data-line="9853">		responseFields = s.responseFields,
</a><a name="line-9854" data-line="9854">		ct,
</a><a name="line-9855" data-line="9855">		type,
</a><a name="line-9856" data-line="9856">		finalDataType,
</a><a name="line-9857" data-line="9857">		firstDataType;
</a><a name="line-9858" data-line="9858">
</a><a name="line-9859" data-line="9859">	// Fill responseXXX fields
</a><a name="line-9860" data-line="9860">	for ( type in responseFields ) {
</a><a name="line-9861" data-line="9861">		if ( type in responses ) {
</a><a name="line-9862" data-line="9862">			jqXHR[ responseFields[type] ] = responses[ type ];
</a><a name="line-9863" data-line="9863">		}
</a><a name="line-9864" data-line="9864">	}
</a><a name="line-9865" data-line="9865">
</a><a name="line-9866" data-line="9866">	// Remove auto dataType and get content-type in the process
</a><a name="line-9867" data-line="9867">	while( dataTypes[ 0 ] === &quot;*&quot; ) {
</a><a name="line-9868" data-line="9868">		dataTypes.shift();
</a><a name="line-9869" data-line="9869">		if ( ct === undefined ) {
</a><a name="line-9870" data-line="9870">			ct = s.mimeType || jqXHR.getResponseHeader( &quot;content-type&quot; );
</a><a name="line-9871" data-line="9871">		}
</a><a name="line-9872" data-line="9872">	}
</a><a name="line-9873" data-line="9873">
</a><a name="line-9874" data-line="9874">	// Check if we're dealing with a known content-type
</a><a name="line-9875" data-line="9875">	if ( ct ) {
</a><a name="line-9876" data-line="9876">		for ( type in contents ) {
</a><a name="line-9877" data-line="9877">			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
</a><a name="line-9878" data-line="9878">				dataTypes.unshift( type );
</a><a name="line-9879" data-line="9879">				break;
</a><a name="line-9880" data-line="9880">			}
</a><a name="line-9881" data-line="9881">		}
</a><a name="line-9882" data-line="9882">	}
</a><a name="line-9883" data-line="9883">
</a><a name="line-9884" data-line="9884">	// Check to see if we have a response for the expected dataType
</a><a name="line-9885" data-line="9885">	if ( dataTypes[ 0 ] in responses ) {
</a><a name="line-9886" data-line="9886">		finalDataType = dataTypes[ 0 ];
</a><a name="line-9887" data-line="9887">	} else {
</a><a name="line-9888" data-line="9888">		// Try convertible dataTypes
</a><a name="line-9889" data-line="9889">		for ( type in responses ) {
</a><a name="line-9890" data-line="9890">			if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[0] ] ) {
</a><a name="line-9891" data-line="9891">				finalDataType = type;
</a><a name="line-9892" data-line="9892">				break;
</a><a name="line-9893" data-line="9893">			}
</a><a name="line-9894" data-line="9894">			if ( !firstDataType ) {
</a><a name="line-9895" data-line="9895">				firstDataType = type;
</a><a name="line-9896" data-line="9896">			}
</a><a name="line-9897" data-line="9897">		}
</a><a name="line-9898" data-line="9898">		// Or just use first one
</a><a name="line-9899" data-line="9899">		finalDataType = finalDataType || firstDataType;
</a><a name="line-9900" data-line="9900">	}
</a><a name="line-9901" data-line="9901">
</a><a name="line-9902" data-line="9902">	// If we found a dataType
</a><a name="line-9903" data-line="9903">	// We add the dataType to the list if needed
</a><a name="line-9904" data-line="9904">	// and return the corresponding response
</a><a name="line-9905" data-line="9905">	if ( finalDataType ) {
</a><a name="line-9906" data-line="9906">		if ( finalDataType !== dataTypes[ 0 ] ) {
</a><a name="line-9907" data-line="9907">			dataTypes.unshift( finalDataType );
</a><a name="line-9908" data-line="9908">		}
</a><a name="line-9909" data-line="9909">		return responses[ finalDataType ];
</a><a name="line-9910" data-line="9910">	}
</a><a name="line-9911" data-line="9911">}
</a><a name="line-9912" data-line="9912">
</a><a name="line-9913" data-line="9913">// Chain conversions given the request and the original response
</a><a name="line-9914" data-line="9914">function ajaxConvert( s, response ) {
</a><a name="line-9915" data-line="9915">
</a><a name="line-9916" data-line="9916">	// Apply the dataFilter if provided
</a><a name="line-9917" data-line="9917">	if ( s.dataFilter ) {
</a><a name="line-9918" data-line="9918">		response = s.dataFilter( response, s.dataType );
</a><a name="line-9919" data-line="9919">	}
</a><a name="line-9920" data-line="9920">
</a><a name="line-9921" data-line="9921">	var dataTypes = s.dataTypes,
</a><a name="line-9922" data-line="9922">		converters = {},
</a><a name="line-9923" data-line="9923">		i,
</a><a name="line-9924" data-line="9924">		key,
</a><a name="line-9925" data-line="9925">		length = dataTypes.length,
</a><a name="line-9926" data-line="9926">		tmp,
</a><a name="line-9927" data-line="9927">		// Current and previous dataTypes
</a><a name="line-9928" data-line="9928">		current = dataTypes[ 0 ],
</a><a name="line-9929" data-line="9929">		prev,
</a><a name="line-9930" data-line="9930">		// Conversion expression
</a><a name="line-9931" data-line="9931">		conversion,
</a><a name="line-9932" data-line="9932">		// Conversion function
</a><a name="line-9933" data-line="9933">		conv,
</a><a name="line-9934" data-line="9934">		// Conversion functions (transitive conversion)
</a><a name="line-9935" data-line="9935">		conv1,
</a><a name="line-9936" data-line="9936">		conv2;
</a><a name="line-9937" data-line="9937">
</a><a name="line-9938" data-line="9938">	// For each dataType in the chain
</a><a name="line-9939" data-line="9939">	for ( i = 1; i &lt; length; i++ ) {
</a><a name="line-9940" data-line="9940">
</a><a name="line-9941" data-line="9941">		// Create converters map
</a><a name="line-9942" data-line="9942">		// with lowercased keys
</a><a name="line-9943" data-line="9943">		if ( i === 1 ) {
</a><a name="line-9944" data-line="9944">			for ( key in s.converters ) {
</a><a name="line-9945" data-line="9945">				if ( typeof key === &quot;string&quot; ) {
</a><a name="line-9946" data-line="9946">					converters[ key.toLowerCase() ] = s.converters[ key ];
</a><a name="line-9947" data-line="9947">				}
</a><a name="line-9948" data-line="9948">			}
</a><a name="line-9949" data-line="9949">		}
</a><a name="line-9950" data-line="9950">
</a><a name="line-9951" data-line="9951">		// Get the dataTypes
</a><a name="line-9952" data-line="9952">		prev = current;
</a><a name="line-9953" data-line="9953">		current = dataTypes[ i ];
</a><a name="line-9954" data-line="9954">
</a><a name="line-9955" data-line="9955">		// If current is auto dataType, update it to prev
</a><a name="line-9956" data-line="9956">		if ( current === &quot;*&quot; ) {
</a><a name="line-9957" data-line="9957">			current = prev;
</a><a name="line-9958" data-line="9958">		// If no auto and dataTypes are actually different
</a><a name="line-9959" data-line="9959">		} else if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {
</a><a name="line-9960" data-line="9960">
</a><a name="line-9961" data-line="9961">			// Get the converter
</a><a name="line-9962" data-line="9962">			conversion = prev + &quot; &quot; + current;
</a><a name="line-9963" data-line="9963">			conv = converters[ conversion ] || converters[ &quot;* &quot; + current ];
</a><a name="line-9964" data-line="9964">
</a><a name="line-9965" data-line="9965">			// If there is no direct converter, search transitively
</a><a name="line-9966" data-line="9966">			if ( !conv ) {
</a><a name="line-9967" data-line="9967">				conv2 = undefined;
</a><a name="line-9968" data-line="9968">				for ( conv1 in converters ) {
</a><a name="line-9969" data-line="9969">					tmp = conv1.split( &quot; &quot; );
</a><a name="line-9970" data-line="9970">					if ( tmp[ 0 ] === prev || tmp[ 0 ] === &quot;*&quot; ) {
</a><a name="line-9971" data-line="9971">						conv2 = converters[ tmp[1] + &quot; &quot; + current ];
</a><a name="line-9972" data-line="9972">						if ( conv2 ) {
</a><a name="line-9973" data-line="9973">							conv1 = converters[ conv1 ];
</a><a name="line-9974" data-line="9974">							if ( conv1 === true ) {
</a><a name="line-9975" data-line="9975">								conv = conv2;
</a><a name="line-9976" data-line="9976">							} else if ( conv2 === true ) {
</a><a name="line-9977" data-line="9977">								conv = conv1;
</a><a name="line-9978" data-line="9978">							}
</a><a name="line-9979" data-line="9979">							break;
</a><a name="line-9980" data-line="9980">						}
</a><a name="line-9981" data-line="9981">					}
</a><a name="line-9982" data-line="9982">				}
</a><a name="line-9983" data-line="9983">			}
</a><a name="line-9984" data-line="9984">			// If we found no converter, dispatch an error
</a><a name="line-9985" data-line="9985">			if ( !( conv || conv2 ) ) {
</a><a name="line-9986" data-line="9986">				jQuery.error( &quot;No conversion from &quot; + conversion.replace(&quot; &quot;,&quot; to &quot;) );
</a><a name="line-9987" data-line="9987">			}
</a><a name="line-9988" data-line="9988">			// If found converter is not an equivalence
</a><a name="line-9989" data-line="9989">			if ( conv !== true ) {
</a><a name="line-9990" data-line="9990">				// Convert with 1 or 2 converters accordingly
</a><a name="line-9991" data-line="9991">				response = conv ? conv( response ) : conv2( conv1(response) );
</a><a name="line-9992" data-line="9992">			}
</a><a name="line-9993" data-line="9993">		}
</a><a name="line-9994" data-line="9994">	}
</a><a name="line-9995" data-line="9995">	return response;
</a><a name="line-9996" data-line="9996">}
</a><a name="line-9997" data-line="9997">
</a><a name="line-9998" data-line="9998">
</a><a name="line-9999" data-line="9999">
</a><a name="line-10000" data-line="10000">
</a><a name="line-10001" data-line="10001">var jsc = jQuery.now(),
</a><a name="line-10002" data-line="10002">	jsre = /(\=)\?(&amp;|$)|\?\?/i;
</a><a name="line-10003" data-line="10003">
</a><a name="line-10004" data-line="10004">// Default jsonp settings
</a><a name="line-10005" data-line="10005">jQuery.ajaxSetup({
</a><a name="line-10006" data-line="10006">	jsonp: &quot;callback&quot;,
</a><a name="line-10007" data-line="10007">	jsonpCallback: function() {
</a><a name="line-10008" data-line="10008">		return jQuery.expando + &quot;_&quot; + ( jsc++ );
</a><a name="line-10009" data-line="10009">	}
</a><a name="line-10010" data-line="10010">});
</a><a name="line-10011" data-line="10011">
</a><a name="line-10012" data-line="10012">// Detect, normalize options and install callbacks for jsonp requests
</a><a name="line-10013" data-line="10013">jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {
</a><a name="line-10014" data-line="10014">
</a><a name="line-10015" data-line="10015">	var inspectData = ( typeof s.data === &quot;string&quot; ) &amp;&amp; /^application\/x\-www\-form\-urlencoded/.test( s.contentType );
</a><a name="line-10016" data-line="10016">
</a><a name="line-10017" data-line="10017">	if ( s.dataTypes[ 0 ] === &quot;jsonp&quot; ||
</a><a name="line-10018" data-line="10018">		s.jsonp !== false &amp;&amp; ( jsre.test( s.url ) ||
</a><a name="line-10019" data-line="10019">				inspectData &amp;&amp; jsre.test( s.data ) ) ) {
</a><a name="line-10020" data-line="10020">
</a><a name="line-10021" data-line="10021">		var responseContainer,
</a><a name="line-10022" data-line="10022">			jsonpCallback = s.jsonpCallback =
</a><a name="line-10023" data-line="10023">				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
</a><a name="line-10024" data-line="10024">			previous = window[ jsonpCallback ],
</a><a name="line-10025" data-line="10025">			url = s.url,
</a><a name="line-10026" data-line="10026">			data = s.data,
</a><a name="line-10027" data-line="10027">			replace = &quot;$1&quot; + jsonpCallback + &quot;$2&quot;;
</a><a name="line-10028" data-line="10028">
</a><a name="line-10029" data-line="10029">		if ( s.jsonp !== false ) {
</a><a name="line-10030" data-line="10030">			url = url.replace( jsre, replace );
</a><a name="line-10031" data-line="10031">			if ( s.url === url ) {
</a><a name="line-10032" data-line="10032">				if ( inspectData ) {
</a><a name="line-10033" data-line="10033">					data = data.replace( jsre, replace );
</a><a name="line-10034" data-line="10034">				}
</a><a name="line-10035" data-line="10035">				if ( s.data === data ) {
</a><a name="line-10036" data-line="10036">					// Add callback manually
</a><a name="line-10037" data-line="10037">					url += (/\?/.test( url ) ? &quot;&amp;&quot; : &quot;?&quot;) + s.jsonp + &quot;=&quot; + jsonpCallback;
</a><a name="line-10038" data-line="10038">				}
</a><a name="line-10039" data-line="10039">			}
</a><a name="line-10040" data-line="10040">		}
</a><a name="line-10041" data-line="10041">
</a><a name="line-10042" data-line="10042">		s.url = url;
</a><a name="line-10043" data-line="10043">		s.data = data;
</a><a name="line-10044" data-line="10044">
</a><a name="line-10045" data-line="10045">		// Install callback
</a><a name="line-10046" data-line="10046">		window[ jsonpCallback ] = function( response ) {
</a><a name="line-10047" data-line="10047">			responseContainer = [ response ];
</a><a name="line-10048" data-line="10048">		};
</a><a name="line-10049" data-line="10049">
</a><a name="line-10050" data-line="10050">		// Clean-up function
</a><a name="line-10051" data-line="10051">		jqXHR.always(function() {
</a><a name="line-10052" data-line="10052">			// Set callback back to previous value
</a><a name="line-10053" data-line="10053">			window[ jsonpCallback ] = previous;
</a><a name="line-10054" data-line="10054">			// Call if it was a function and we have a response
</a><a name="line-10055" data-line="10055">			if ( responseContainer &amp;&amp; jQuery.isFunction( previous ) ) {
</a><a name="line-10056" data-line="10056">				window[ jsonpCallback ]( responseContainer[ 0 ] );
</a><a name="line-10057" data-line="10057">			}
</a><a name="line-10058" data-line="10058">		});
</a><a name="line-10059" data-line="10059">
</a><a name="line-10060" data-line="10060">		// Use data converter to retrieve json after script execution
</a><a name="line-10061" data-line="10061">		s.converters[&quot;script json&quot;] = function() {
</a><a name="line-10062" data-line="10062">			if ( !responseContainer ) {
</a><a name="line-10063" data-line="10063">				jQuery.error( jsonpCallback + &quot; was not called&quot; );
</a><a name="line-10064" data-line="10064">			}
</a><a name="line-10065" data-line="10065">			return responseContainer[ 0 ];
</a><a name="line-10066" data-line="10066">		};
</a><a name="line-10067" data-line="10067">
</a><a name="line-10068" data-line="10068">		// force json dataType
</a><a name="line-10069" data-line="10069">		s.dataTypes[ 0 ] = &quot;json&quot;;
</a><a name="line-10070" data-line="10070">
</a><a name="line-10071" data-line="10071">		// Delegate to script
</a><a name="line-10072" data-line="10072">		return &quot;script&quot;;
</a><a name="line-10073" data-line="10073">	}
</a><a name="line-10074" data-line="10074">});
</a><a name="line-10075" data-line="10075">
</a><a name="line-10076" data-line="10076">
</a><a name="line-10077" data-line="10077">
</a><a name="line-10078" data-line="10078">
</a><a name="line-10079" data-line="10079">// Install script dataType
</a><a name="line-10080" data-line="10080">jQuery.ajaxSetup({
</a><a name="line-10081" data-line="10081">	accepts: {
</a><a name="line-10082" data-line="10082">		script: &quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;
</a><a name="line-10083" data-line="10083">	},
</a><a name="line-10084" data-line="10084">	contents: {
</a><a name="line-10085" data-line="10085">		script: /javascript|ecmascript/
</a><a name="line-10086" data-line="10086">	},
</a><a name="line-10087" data-line="10087">	converters: {
</a><a name="line-10088" data-line="10088">		&quot;text script&quot;: function( text ) {
</a><a name="line-10089" data-line="10089">			jQuery.globalEval( text );
</a><a name="line-10090" data-line="10090">			return text;
</a><a name="line-10091" data-line="10091">		}
</a><a name="line-10092" data-line="10092">	}
</a><a name="line-10093" data-line="10093">});
</a><a name="line-10094" data-line="10094">
</a><a name="line-10095" data-line="10095">// Handle cache's special case and global
</a><a name="line-10096" data-line="10096">jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
</a><a name="line-10097" data-line="10097">	if ( s.cache === undefined ) {
</a><a name="line-10098" data-line="10098">		s.cache = false;
</a><a name="line-10099" data-line="10099">	}
</a><a name="line-10100" data-line="10100">	if ( s.crossDomain ) {
</a><a name="line-10101" data-line="10101">		s.type = &quot;GET&quot;;
</a><a name="line-10102" data-line="10102">		s.global = false;
</a><a name="line-10103" data-line="10103">	}
</a><a name="line-10104" data-line="10104">});
</a><a name="line-10105" data-line="10105">
</a><a name="line-10106" data-line="10106">// Bind script tag hack transport
</a><a name="line-10107" data-line="10107">jQuery.ajaxTransport( &quot;script&quot;, function(s) {
</a><a name="line-10108" data-line="10108">
</a><a name="line-10109" data-line="10109">	// This transport only deals with cross domain requests
</a><a name="line-10110" data-line="10110">	if ( s.crossDomain ) {
</a><a name="line-10111" data-line="10111">
</a><a name="line-10112" data-line="10112">		var script,
</a><a name="line-10113" data-line="10113">			head = document.head || document.getElementsByTagName( &quot;head&quot; )[0] || document.documentElement;
</a><a name="line-10114" data-line="10114">
</a><a name="line-10115" data-line="10115">		return {
</a><a name="line-10116" data-line="10116">
</a><a name="line-10117" data-line="10117">			send: function( _, callback ) {
</a><a name="line-10118" data-line="10118">
</a><a name="line-10119" data-line="10119">				script = document.createElement( &quot;script&quot; );
</a><a name="line-10120" data-line="10120">
</a><a name="line-10121" data-line="10121">				script.async = &quot;async&quot;;
</a><a name="line-10122" data-line="10122">
</a><a name="line-10123" data-line="10123">				if ( s.scriptCharset ) {
</a><a name="line-10124" data-line="10124">					script.charset = s.scriptCharset;
</a><a name="line-10125" data-line="10125">				}
</a><a name="line-10126" data-line="10126">
</a><a name="line-10127" data-line="10127">				script.src = s.url;
</a><a name="line-10128" data-line="10128">
</a><a name="line-10129" data-line="10129">				// Attach handlers for all browsers
</a><a name="line-10130" data-line="10130">				script.onload = script.onreadystatechange = function( _, isAbort ) {
</a><a name="line-10131" data-line="10131">
</a><a name="line-10132" data-line="10132">					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {
</a><a name="line-10133" data-line="10133">
</a><a name="line-10134" data-line="10134">						// Handle memory leak in IE
</a><a name="line-10135" data-line="10135">						script.onload = script.onreadystatechange = null;
</a><a name="line-10136" data-line="10136">
</a><a name="line-10137" data-line="10137">						// Remove the script
</a><a name="line-10138" data-line="10138">						if ( head &amp;&amp; script.parentNode ) {
</a><a name="line-10139" data-line="10139">							head.removeChild( script );
</a><a name="line-10140" data-line="10140">						}
</a><a name="line-10141" data-line="10141">
</a><a name="line-10142" data-line="10142">						// Dereference the script
</a><a name="line-10143" data-line="10143">						script = undefined;
</a><a name="line-10144" data-line="10144">
</a><a name="line-10145" data-line="10145">						// Callback if not abort
</a><a name="line-10146" data-line="10146">						if ( !isAbort ) {
</a><a name="line-10147" data-line="10147">							callback( 200, &quot;success&quot; );
</a><a name="line-10148" data-line="10148">						}
</a><a name="line-10149" data-line="10149">					}
</a><a name="line-10150" data-line="10150">				};
</a><a name="line-10151" data-line="10151">				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
</a><a name="line-10152" data-line="10152">				// This arises when a base node is used (#2709 and #4378).
</a><a name="line-10153" data-line="10153">				head.insertBefore( script, head.firstChild );
</a><a name="line-10154" data-line="10154">			},
</a><a name="line-10155" data-line="10155">
</a><a name="line-10156" data-line="10156">			abort: function() {
</a><a name="line-10157" data-line="10157">				if ( script ) {
</a><a name="line-10158" data-line="10158">					script.onload( 0, 1 );
</a><a name="line-10159" data-line="10159">				}
</a><a name="line-10160" data-line="10160">			}
</a><a name="line-10161" data-line="10161">		};
</a><a name="line-10162" data-line="10162">	}
</a><a name="line-10163" data-line="10163">});
</a><a name="line-10164" data-line="10164">
</a><a name="line-10165" data-line="10165">
</a><a name="line-10166" data-line="10166">
</a><a name="line-10167" data-line="10167">
</a><a name="line-10168" data-line="10168">var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
</a><a name="line-10169" data-line="10169">	xhrOnUnloadAbort = window.ActiveXObject ? function() {
</a><a name="line-10170" data-line="10170">		// Abort all pending requests
</a><a name="line-10171" data-line="10171">		for ( var key in xhrCallbacks ) {
</a><a name="line-10172" data-line="10172">			xhrCallbacks[ key ]( 0, 1 );
</a><a name="line-10173" data-line="10173">		}
</a><a name="line-10174" data-line="10174">	} : false,
</a><a name="line-10175" data-line="10175">	xhrId = 0,
</a><a name="line-10176" data-line="10176">	xhrCallbacks;
</a><a name="line-10177" data-line="10177">
</a><a name="line-10178" data-line="10178">// Functions to create xhrs
</a><a name="line-10179" data-line="10179">function createStandardXHR() {
</a><a name="line-10180" data-line="10180">	try {
</a><a name="line-10181" data-line="10181">		return new window.XMLHttpRequest();
</a><a name="line-10182" data-line="10182">	} catch( e ) {}
</a><a name="line-10183" data-line="10183">}
</a><a name="line-10184" data-line="10184">
</a><a name="line-10185" data-line="10185">function createActiveXHR() {
</a><a name="line-10186" data-line="10186">	try {
</a><a name="line-10187" data-line="10187">		return new window.ActiveXObject( &quot;Microsoft.XMLHTTP&quot; );
</a><a name="line-10188" data-line="10188">	} catch( e ) {}
</a><a name="line-10189" data-line="10189">}
</a><a name="line-10190" data-line="10190">
</a><a name="line-10191" data-line="10191">// Create the request object
</a><a name="line-10192" data-line="10192">// (This is still attached to ajaxSettings for backward compatibility)
</a><a name="line-10193" data-line="10193">jQuery.ajaxSettings.xhr = window.ActiveXObject ?
</a><a name="line-10194" data-line="10194">	/* Microsoft failed to properly
</a><a name="line-10195" data-line="10195">	 * implement the XMLHttpRequest in IE7 (can't request local files),
</a><a name="line-10196" data-line="10196">	 * so we use the ActiveXObject when it is available
</a><a name="line-10197" data-line="10197">	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
</a><a name="line-10198" data-line="10198">	 * we need a fallback.
</a><a name="line-10199" data-line="10199">	 */
</a><a name="line-10200" data-line="10200">	function() {
</a><a name="line-10201" data-line="10201">		return !this.isLocal &amp;&amp; createStandardXHR() || createActiveXHR();
</a><a name="line-10202" data-line="10202">	} :
</a><a name="line-10203" data-line="10203">	// For all other browsers, use the standard XMLHttpRequest object
</a><a name="line-10204" data-line="10204">	createStandardXHR;
</a><a name="line-10205" data-line="10205">
</a><a name="line-10206" data-line="10206">// Determine support properties
</a><a name="line-10207" data-line="10207">(function( xhr ) {
</a><a name="line-10208" data-line="10208">	jQuery.extend( jQuery.support, {
</a><a name="line-10209" data-line="10209">		ajax: !!xhr,
</a><a name="line-10210" data-line="10210">		cors: !!xhr &amp;&amp; ( &quot;withCredentials&quot; in xhr )
</a><a name="line-10211" data-line="10211">	});
</a><a name="line-10212" data-line="10212">})( jQuery.ajaxSettings.xhr() );
</a><a name="line-10213" data-line="10213">
</a><a name="line-10214" data-line="10214">// Create transport if the browser can provide an xhr
</a><a name="line-10215" data-line="10215">if ( jQuery.support.ajax ) {
</a><a name="line-10216" data-line="10216">
</a><a name="line-10217" data-line="10217">	jQuery.ajaxTransport(function( s ) {
</a><a name="line-10218" data-line="10218">		// Cross domain only allowed if supported through XMLHttpRequest
</a><a name="line-10219" data-line="10219">		if ( !s.crossDomain || jQuery.support.cors ) {
</a><a name="line-10220" data-line="10220">
</a><a name="line-10221" data-line="10221">			var callback;
</a><a name="line-10222" data-line="10222">
</a><a name="line-10223" data-line="10223">			return {
</a><a name="line-10224" data-line="10224">				send: function( headers, complete ) {
</a><a name="line-10225" data-line="10225">
</a><a name="line-10226" data-line="10226">					// Get a new xhr
</a><a name="line-10227" data-line="10227">					var xhr = s.xhr(),
</a><a name="line-10228" data-line="10228">						handle,
</a><a name="line-10229" data-line="10229">						i;
</a><a name="line-10230" data-line="10230">
</a><a name="line-10231" data-line="10231">					// Open the socket
</a><a name="line-10232" data-line="10232">					// Passing null username, generates a login popup on Opera (#2865)
</a><a name="line-10233" data-line="10233">					if ( s.username ) {
</a><a name="line-10234" data-line="10234">						xhr.open( s.type, s.url, s.async, s.username, s.password );
</a><a name="line-10235" data-line="10235">					} else {
</a><a name="line-10236" data-line="10236">						xhr.open( s.type, s.url, s.async );
</a><a name="line-10237" data-line="10237">					}
</a><a name="line-10238" data-line="10238">
</a><a name="line-10239" data-line="10239">					// Apply custom fields if provided
</a><a name="line-10240" data-line="10240">					if ( s.xhrFields ) {
</a><a name="line-10241" data-line="10241">						for ( i in s.xhrFields ) {
</a><a name="line-10242" data-line="10242">							xhr[ i ] = s.xhrFields[ i ];
</a><a name="line-10243" data-line="10243">						}
</a><a name="line-10244" data-line="10244">					}
</a><a name="line-10245" data-line="10245">
</a><a name="line-10246" data-line="10246">					// Override mime type if needed
</a><a name="line-10247" data-line="10247">					if ( s.mimeType &amp;&amp; xhr.overrideMimeType ) {
</a><a name="line-10248" data-line="10248">						xhr.overrideMimeType( s.mimeType );
</a><a name="line-10249" data-line="10249">					}
</a><a name="line-10250" data-line="10250">
</a><a name="line-10251" data-line="10251">					// X-Requested-With header
</a><a name="line-10252" data-line="10252">					// For cross-domain requests, seeing as conditions for a preflight are
</a><a name="line-10253" data-line="10253">					// akin to a jigsaw puzzle, we simply never set it to be sure.
</a><a name="line-10254" data-line="10254">					// (it can always be set on a per-request basis or even using ajaxSetup)
</a><a name="line-10255" data-line="10255">					// For same-domain requests, won't change header if already provided.
</a><a name="line-10256" data-line="10256">					if ( !s.crossDomain &amp;&amp; !headers[&quot;X-Requested-With&quot;] ) {
</a><a name="line-10257" data-line="10257">						headers[ &quot;X-Requested-With&quot; ] = &quot;XMLHttpRequest&quot;;
</a><a name="line-10258" data-line="10258">					}
</a><a name="line-10259" data-line="10259">
</a><a name="line-10260" data-line="10260">					// Need an extra try/catch for cross domain requests in Firefox 3
</a><a name="line-10261" data-line="10261">					try {
</a><a name="line-10262" data-line="10262">						for ( i in headers ) {
</a><a name="line-10263" data-line="10263">							xhr.setRequestHeader( i, headers[ i ] );
</a><a name="line-10264" data-line="10264">						}
</a><a name="line-10265" data-line="10265">					} catch( _ ) {}
</a><a name="line-10266" data-line="10266">
</a><a name="line-10267" data-line="10267">					// Do send the request
</a><a name="line-10268" data-line="10268">					// This may raise an exception which is actually
</a><a name="line-10269" data-line="10269">					// handled in jQuery.ajax (so no try/catch here)
</a><a name="line-10270" data-line="10270">					xhr.send( ( s.hasContent &amp;&amp; s.data ) || null );
</a><a name="line-10271" data-line="10271">
</a><a name="line-10272" data-line="10272">					// Listener
</a><a name="line-10273" data-line="10273">					callback = function( _, isAbort ) {
</a><a name="line-10274" data-line="10274">
</a><a name="line-10275" data-line="10275">						var status,
</a><a name="line-10276" data-line="10276">							statusText,
</a><a name="line-10277" data-line="10277">							responseHeaders,
</a><a name="line-10278" data-line="10278">							responses,
</a><a name="line-10279" data-line="10279">							xml;
</a><a name="line-10280" data-line="10280">
</a><a name="line-10281" data-line="10281">						// Firefox throws exceptions when accessing properties
</a><a name="line-10282" data-line="10282">						// of an xhr when a network error occured
</a><a name="line-10283" data-line="10283">						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
</a><a name="line-10284" data-line="10284">						try {
</a><a name="line-10285" data-line="10285">
</a><a name="line-10286" data-line="10286">							// Was never called and is aborted or complete
</a><a name="line-10287" data-line="10287">							if ( callback &amp;&amp; ( isAbort || xhr.readyState === 4 ) ) {
</a><a name="line-10288" data-line="10288">
</a><a name="line-10289" data-line="10289">								// Only called once
</a><a name="line-10290" data-line="10290">								callback = undefined;
</a><a name="line-10291" data-line="10291">
</a><a name="line-10292" data-line="10292">								// Do not keep as active anymore
</a><a name="line-10293" data-line="10293">								if ( handle ) {
</a><a name="line-10294" data-line="10294">									xhr.onreadystatechange = jQuery.noop;
</a><a name="line-10295" data-line="10295">									if ( xhrOnUnloadAbort ) {
</a><a name="line-10296" data-line="10296">										delete xhrCallbacks[ handle ];
</a><a name="line-10297" data-line="10297">									}
</a><a name="line-10298" data-line="10298">								}
</a><a name="line-10299" data-line="10299">
</a><a name="line-10300" data-line="10300">								// If it's an abort
</a><a name="line-10301" data-line="10301">								if ( isAbort ) {
</a><a name="line-10302" data-line="10302">									// Abort it manually if needed
</a><a name="line-10303" data-line="10303">									if ( xhr.readyState !== 4 ) {
</a><a name="line-10304" data-line="10304">										xhr.abort();
</a><a name="line-10305" data-line="10305">									}
</a><a name="line-10306" data-line="10306">								} else {
</a><a name="line-10307" data-line="10307">									status = xhr.status;
</a><a name="line-10308" data-line="10308">									responseHeaders = xhr.getAllResponseHeaders();
</a><a name="line-10309" data-line="10309">									responses = {};
</a><a name="line-10310" data-line="10310">									xml = xhr.responseXML;
</a><a name="line-10311" data-line="10311">
</a><a name="line-10312" data-line="10312">									// Construct response list
</a><a name="line-10313" data-line="10313">									if ( xml &amp;&amp; xml.documentElement /* #4958 */ ) {
</a><a name="line-10314" data-line="10314">										responses.xml = xml;
</a><a name="line-10315" data-line="10315">									}
</a><a name="line-10316" data-line="10316">
</a><a name="line-10317" data-line="10317">									// When requesting binary data, IE6-9 will throw an exception
</a><a name="line-10318" data-line="10318">									// on any attempt to access responseText (#11426)
</a><a name="line-10319" data-line="10319">									try {
</a><a name="line-10320" data-line="10320">										responses.text = xhr.responseText;
</a><a name="line-10321" data-line="10321">									} catch( _ ) {
</a><a name="line-10322" data-line="10322">									}
</a><a name="line-10323" data-line="10323">
</a><a name="line-10324" data-line="10324">									// Firefox throws an exception when accessing
</a><a name="line-10325" data-line="10325">									// statusText for faulty cross-domain requests
</a><a name="line-10326" data-line="10326">									try {
</a><a name="line-10327" data-line="10327">										statusText = xhr.statusText;
</a><a name="line-10328" data-line="10328">									} catch( e ) {
</a><a name="line-10329" data-line="10329">										// We normalize with Webkit giving an empty statusText
</a><a name="line-10330" data-line="10330">										statusText = &quot;&quot;;
</a><a name="line-10331" data-line="10331">									}
</a><a name="line-10332" data-line="10332">
</a><a name="line-10333" data-line="10333">									// Filter status for non standard behaviors
</a><a name="line-10334" data-line="10334">
</a><a name="line-10335" data-line="10335">									// If the request is local and we have data: assume a success
</a><a name="line-10336" data-line="10336">									// (success with no data won't get notified, that's the best we
</a><a name="line-10337" data-line="10337">									// can do given current implementations)
</a><a name="line-10338" data-line="10338">									if ( !status &amp;&amp; s.isLocal &amp;&amp; !s.crossDomain ) {
</a><a name="line-10339" data-line="10339">										status = responses.text ? 200 : 404;
</a><a name="line-10340" data-line="10340">									// IE - #1450: sometimes returns 1223 when it should be 204
</a><a name="line-10341" data-line="10341">									} else if ( status === 1223 ) {
</a><a name="line-10342" data-line="10342">										status = 204;
</a><a name="line-10343" data-line="10343">									}
</a><a name="line-10344" data-line="10344">								}
</a><a name="line-10345" data-line="10345">							}
</a><a name="line-10346" data-line="10346">						} catch( firefoxAccessException ) {
</a><a name="line-10347" data-line="10347">							if ( !isAbort ) {
</a><a name="line-10348" data-line="10348">								complete( -1, firefoxAccessException );
</a><a name="line-10349" data-line="10349">							}
</a><a name="line-10350" data-line="10350">						}
</a><a name="line-10351" data-line="10351">
</a><a name="line-10352" data-line="10352">						// Call complete if needed
</a><a name="line-10353" data-line="10353">						if ( responses ) {
</a><a name="line-10354" data-line="10354">							complete( status, statusText, responses, responseHeaders );
</a><a name="line-10355" data-line="10355">						}
</a><a name="line-10356" data-line="10356">					};
</a><a name="line-10357" data-line="10357">
</a><a name="line-10358" data-line="10358">					// if we're in sync mode or it's in cache
</a><a name="line-10359" data-line="10359">					// and has been retrieved directly (IE6 &amp; IE7)
</a><a name="line-10360" data-line="10360">					// we need to manually fire the callback
</a><a name="line-10361" data-line="10361">					if ( !s.async || xhr.readyState === 4 ) {
</a><a name="line-10362" data-line="10362">						callback();
</a><a name="line-10363" data-line="10363">					} else {
</a><a name="line-10364" data-line="10364">						handle = ++xhrId;
</a><a name="line-10365" data-line="10365">						if ( xhrOnUnloadAbort ) {
</a><a name="line-10366" data-line="10366">							// Create the active xhrs callbacks list if needed
</a><a name="line-10367" data-line="10367">							// and attach the unload handler
</a><a name="line-10368" data-line="10368">							if ( !xhrCallbacks ) {
</a><a name="line-10369" data-line="10369">								xhrCallbacks = {};
</a><a name="line-10370" data-line="10370">								jQuery( window ).unload( xhrOnUnloadAbort );
</a><a name="line-10371" data-line="10371">							}
</a><a name="line-10372" data-line="10372">							// Add to list of active xhrs callbacks
</a><a name="line-10373" data-line="10373">							xhrCallbacks[ handle ] = callback;
</a><a name="line-10374" data-line="10374">						}
</a><a name="line-10375" data-line="10375">						xhr.onreadystatechange = callback;
</a><a name="line-10376" data-line="10376">					}
</a><a name="line-10377" data-line="10377">				},
</a><a name="line-10378" data-line="10378">
</a><a name="line-10379" data-line="10379">				abort: function() {
</a><a name="line-10380" data-line="10380">					if ( callback ) {
</a><a name="line-10381" data-line="10381">						callback(0,1);
</a><a name="line-10382" data-line="10382">					}
</a><a name="line-10383" data-line="10383">				}
</a><a name="line-10384" data-line="10384">			};
</a><a name="line-10385" data-line="10385">		}
</a><a name="line-10386" data-line="10386">	});
</a><a name="line-10387" data-line="10387">}
</a><a name="line-10388" data-line="10388">
</a><a name="line-10389" data-line="10389">
</a><a name="line-10390" data-line="10390">
</a><a name="line-10391" data-line="10391">
</a><a name="line-10392" data-line="10392">var elemdisplay = {},
</a><a name="line-10393" data-line="10393">	iframe, iframeDoc,
</a><a name="line-10394" data-line="10394">	rfxtypes = /^(?:toggle|show|hide)$/,
</a><a name="line-10395" data-line="10395">	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
</a><a name="line-10396" data-line="10396">	timerId,
</a><a name="line-10397" data-line="10397">	fxAttrs = [
</a><a name="line-10398" data-line="10398">		// height animations
</a><a name="line-10399" data-line="10399">		[ &quot;height&quot;, &quot;marginTop&quot;, &quot;marginBottom&quot;, &quot;paddingTop&quot;, &quot;paddingBottom&quot; ],
</a><a name="line-10400" data-line="10400">		// width animations
</a><a name="line-10401" data-line="10401">		[ &quot;width&quot;, &quot;marginLeft&quot;, &quot;marginRight&quot;, &quot;paddingLeft&quot;, &quot;paddingRight&quot; ],
</a><a name="line-10402" data-line="10402">		// opacity animations
</a><a name="line-10403" data-line="10403">		[ &quot;opacity&quot; ]
</a><a name="line-10404" data-line="10404">	],
</a><a name="line-10405" data-line="10405">	fxNow;
</a><a name="line-10406" data-line="10406">
</a><a name="line-10407" data-line="10407">jQuery.fn.extend({
</a><a name="line-10408" data-line="10408">	show: function( speed, easing, callback ) {
</a><a name="line-10409" data-line="10409">		var elem, display;
</a><a name="line-10410" data-line="10410">
</a><a name="line-10411" data-line="10411">		if ( speed || speed === 0 ) {
</a><a name="line-10412" data-line="10412">			return this.animate( genFx(&quot;show&quot;, 3), speed, easing, callback );
</a><a name="line-10413" data-line="10413">
</a><a name="line-10414" data-line="10414">		} else {
</a><a name="line-10415" data-line="10415">			for ( var i = 0, j = this.length; i &lt; j; i++ ) {
</a><a name="line-10416" data-line="10416">				elem = this[ i ];
</a><a name="line-10417" data-line="10417">
</a><a name="line-10418" data-line="10418">				if ( elem.style ) {
</a><a name="line-10419" data-line="10419">					display = elem.style.display;
</a><a name="line-10420" data-line="10420">
</a><a name="line-10421" data-line="10421">					// Reset the inline display of this element to learn if it is
</a><a name="line-10422" data-line="10422">					// being hidden by cascaded rules or not
</a><a name="line-10423" data-line="10423">					if ( !jQuery._data(elem, &quot;olddisplay&quot;) &amp;&amp; display === &quot;none&quot; ) {
</a><a name="line-10424" data-line="10424">						display = elem.style.display = &quot;&quot;;
</a><a name="line-10425" data-line="10425">					}
</a><a name="line-10426" data-line="10426">
</a><a name="line-10427" data-line="10427">					// Set elements which have been overridden with display: none
</a><a name="line-10428" data-line="10428">					// in a stylesheet to whatever the default browser style is
</a><a name="line-10429" data-line="10429">					// for such an element
</a><a name="line-10430" data-line="10430">					if ( (display === &quot;&quot; &amp;&amp; jQuery.css(elem, &quot;display&quot;) === &quot;none&quot;) ||
</a><a name="line-10431" data-line="10431">						!jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
</a><a name="line-10432" data-line="10432">						jQuery._data( elem, &quot;olddisplay&quot;, defaultDisplay(elem.nodeName) );
</a><a name="line-10433" data-line="10433">					}
</a><a name="line-10434" data-line="10434">				}
</a><a name="line-10435" data-line="10435">			}
</a><a name="line-10436" data-line="10436">
</a><a name="line-10437" data-line="10437">			// Set the display of most of the elements in a second loop
</a><a name="line-10438" data-line="10438">			// to avoid the constant reflow
</a><a name="line-10439" data-line="10439">			for ( i = 0; i &lt; j; i++ ) {
</a><a name="line-10440" data-line="10440">				elem = this[ i ];
</a><a name="line-10441" data-line="10441">
</a><a name="line-10442" data-line="10442">				if ( elem.style ) {
</a><a name="line-10443" data-line="10443">					display = elem.style.display;
</a><a name="line-10444" data-line="10444">
</a><a name="line-10445" data-line="10445">					if ( display === &quot;&quot; || display === &quot;none&quot; ) {
</a><a name="line-10446" data-line="10446">						elem.style.display = jQuery._data( elem, &quot;olddisplay&quot; ) || &quot;&quot;;
</a><a name="line-10447" data-line="10447">					}
</a><a name="line-10448" data-line="10448">				}
</a><a name="line-10449" data-line="10449">			}
</a><a name="line-10450" data-line="10450">
</a><a name="line-10451" data-line="10451">			return this;
</a><a name="line-10452" data-line="10452">		}
</a><a name="line-10453" data-line="10453">	},
</a><a name="line-10454" data-line="10454">
</a><a name="line-10455" data-line="10455">	hide: function( speed, easing, callback ) {
</a><a name="line-10456" data-line="10456">		if ( speed || speed === 0 ) {
</a><a name="line-10457" data-line="10457">			return this.animate( genFx(&quot;hide&quot;, 3), speed, easing, callback);
</a><a name="line-10458" data-line="10458">
</a><a name="line-10459" data-line="10459">		} else {
</a><a name="line-10460" data-line="10460">			var elem, display,
</a><a name="line-10461" data-line="10461">				i = 0,
</a><a name="line-10462" data-line="10462">				j = this.length;
</a><a name="line-10463" data-line="10463">
</a><a name="line-10464" data-line="10464">			for ( ; i &lt; j; i++ ) {
</a><a name="line-10465" data-line="10465">				elem = this[i];
</a><a name="line-10466" data-line="10466">				if ( elem.style ) {
</a><a name="line-10467" data-line="10467">					display = jQuery.css( elem, &quot;display&quot; );
</a><a name="line-10468" data-line="10468">
</a><a name="line-10469" data-line="10469">					if ( display !== &quot;none&quot; &amp;&amp; !jQuery._data( elem, &quot;olddisplay&quot; ) ) {
</a><a name="line-10470" data-line="10470">						jQuery._data( elem, &quot;olddisplay&quot;, display );
</a><a name="line-10471" data-line="10471">					}
</a><a name="line-10472" data-line="10472">				}
</a><a name="line-10473" data-line="10473">			}
</a><a name="line-10474" data-line="10474">
</a><a name="line-10475" data-line="10475">			// Set the display of the elements in a second loop
</a><a name="line-10476" data-line="10476">			// to avoid the constant reflow
</a><a name="line-10477" data-line="10477">			for ( i = 0; i &lt; j; i++ ) {
</a><a name="line-10478" data-line="10478">				if ( this[i].style ) {
</a><a name="line-10479" data-line="10479">					this[i].style.display = &quot;none&quot;;
</a><a name="line-10480" data-line="10480">				}
</a><a name="line-10481" data-line="10481">			}
</a><a name="line-10482" data-line="10482">
</a><a name="line-10483" data-line="10483">			return this;
</a><a name="line-10484" data-line="10484">		}
</a><a name="line-10485" data-line="10485">	},
</a><a name="line-10486" data-line="10486">
</a><a name="line-10487" data-line="10487">	// Save the old toggle function
</a><a name="line-10488" data-line="10488">	_toggle: jQuery.fn.toggle,
</a><a name="line-10489" data-line="10489">
</a><a name="line-10490" data-line="10490">	toggle: function( fn, fn2, callback ) {
</a><a name="line-10491" data-line="10491">		var bool = typeof fn === &quot;boolean&quot;;
</a><a name="line-10492" data-line="10492">
</a><a name="line-10493" data-line="10493">		if ( jQuery.isFunction(fn) &amp;&amp; jQuery.isFunction(fn2) ) {
</a><a name="line-10494" data-line="10494">			this._toggle.apply( this, arguments );
</a><a name="line-10495" data-line="10495">
</a><a name="line-10496" data-line="10496">		} else if ( fn == null || bool ) {
</a><a name="line-10497" data-line="10497">			this.each(function() {
</a><a name="line-10498" data-line="10498">				var state = bool ? fn : jQuery(this).is(&quot;:hidden&quot;);
</a><a name="line-10499" data-line="10499">				jQuery(this)[ state ? &quot;show&quot; : &quot;hide&quot; ]();
</a><a name="line-10500" data-line="10500">			});
</a><a name="line-10501" data-line="10501">
</a><a name="line-10502" data-line="10502">		} else {
</a><a name="line-10503" data-line="10503">			this.animate(genFx(&quot;toggle&quot;, 3), fn, fn2, callback);
</a><a name="line-10504" data-line="10504">		}
</a><a name="line-10505" data-line="10505">
</a><a name="line-10506" data-line="10506">		return this;
</a><a name="line-10507" data-line="10507">	},
</a><a name="line-10508" data-line="10508">
</a><a name="line-10509" data-line="10509">	fadeTo: function( speed, to, easing, callback ) {
</a><a name="line-10510" data-line="10510">		return this.filter(&quot;:hidden&quot;).css(&quot;opacity&quot;, 0).show().end()
</a><a name="line-10511" data-line="10511">					.animate({opacity: to}, speed, easing, callback);
</a><a name="line-10512" data-line="10512">	},
</a><a name="line-10513" data-line="10513">
</a><a name="line-10514" data-line="10514">	animate: function( prop, speed, easing, callback ) {
</a><a name="line-10515" data-line="10515">		var optall = jQuery.speed( speed, easing, callback );
</a><a name="line-10516" data-line="10516">
</a><a name="line-10517" data-line="10517">		if ( jQuery.isEmptyObject( prop ) ) {
</a><a name="line-10518" data-line="10518">			return this.each( optall.complete, [ false ] );
</a><a name="line-10519" data-line="10519">		}
</a><a name="line-10520" data-line="10520">
</a><a name="line-10521" data-line="10521">		// Do not change referenced properties as per-property easing will be lost
</a><a name="line-10522" data-line="10522">		prop = jQuery.extend( {}, prop );
</a><a name="line-10523" data-line="10523">
</a><a name="line-10524" data-line="10524">		function doAnimation() {
</a><a name="line-10525" data-line="10525">			// XXX 'this' does not always have a nodeName when running the
</a><a name="line-10526" data-line="10526">			// test suite
</a><a name="line-10527" data-line="10527">
</a><a name="line-10528" data-line="10528">			if ( optall.queue === false ) {
</a><a name="line-10529" data-line="10529">				jQuery._mark( this );
</a><a name="line-10530" data-line="10530">			}
</a><a name="line-10531" data-line="10531">
</a><a name="line-10532" data-line="10532">			var opt = jQuery.extend( {}, optall ),
</a><a name="line-10533" data-line="10533">				isElement = this.nodeType === 1,
</a><a name="line-10534" data-line="10534">				hidden = isElement &amp;&amp; jQuery(this).is(&quot;:hidden&quot;),
</a><a name="line-10535" data-line="10535">				name, val, p, e, hooks, replace,
</a><a name="line-10536" data-line="10536">				parts, start, end, unit,
</a><a name="line-10537" data-line="10537">				method;
</a><a name="line-10538" data-line="10538">
</a><a name="line-10539" data-line="10539">			// will store per property easing and be used to determine when an animation is complete
</a><a name="line-10540" data-line="10540">			opt.animatedProperties = {};
</a><a name="line-10541" data-line="10541">
</a><a name="line-10542" data-line="10542">			// first pass over propertys to expand / normalize
</a><a name="line-10543" data-line="10543">			for ( p in prop ) {
</a><a name="line-10544" data-line="10544">				name = jQuery.camelCase( p );
</a><a name="line-10545" data-line="10545">				if ( p !== name ) {
</a><a name="line-10546" data-line="10546">					prop[ name ] = prop[ p ];
</a><a name="line-10547" data-line="10547">					delete prop[ p ];
</a><a name="line-10548" data-line="10548">				}
</a><a name="line-10549" data-line="10549">
</a><a name="line-10550" data-line="10550">				if ( ( hooks = jQuery.cssHooks[ name ] ) &amp;&amp; &quot;expand&quot; in hooks ) {
</a><a name="line-10551" data-line="10551">					replace = hooks.expand( prop[ name ] );
</a><a name="line-10552" data-line="10552">					delete prop[ name ];
</a><a name="line-10553" data-line="10553">
</a><a name="line-10554" data-line="10554">					// not quite $.extend, this wont overwrite keys already present.
</a><a name="line-10555" data-line="10555">					// also - reusing 'p' from above because we have the correct &quot;name&quot;
</a><a name="line-10556" data-line="10556">					for ( p in replace ) {
</a><a name="line-10557" data-line="10557">						if ( ! ( p in prop ) ) {
</a><a name="line-10558" data-line="10558">							prop[ p ] = replace[ p ];
</a><a name="line-10559" data-line="10559">						}
</a><a name="line-10560" data-line="10560">					}
</a><a name="line-10561" data-line="10561">				}
</a><a name="line-10562" data-line="10562">			}
</a><a name="line-10563" data-line="10563">
</a><a name="line-10564" data-line="10564">			for ( name in prop ) {
</a><a name="line-10565" data-line="10565">				val = prop[ name ];
</a><a name="line-10566" data-line="10566">				// easing resolution: per property &gt; opt.specialEasing &gt; opt.easing &gt; 'swing' (default)
</a><a name="line-10567" data-line="10567">				if ( jQuery.isArray( val ) ) {
</a><a name="line-10568" data-line="10568">					opt.animatedProperties[ name ] = val[ 1 ];
</a><a name="line-10569" data-line="10569">					val = prop[ name ] = val[ 0 ];
</a><a name="line-10570" data-line="10570">				} else {
</a><a name="line-10571" data-line="10571">					opt.animatedProperties[ name ] = opt.specialEasing &amp;&amp; opt.specialEasing[ name ] || opt.easing || 'swing';
</a><a name="line-10572" data-line="10572">				}
</a><a name="line-10573" data-line="10573">
</a><a name="line-10574" data-line="10574">				if ( val === &quot;hide&quot; &amp;&amp; hidden || val === &quot;show&quot; &amp;&amp; !hidden ) {
</a><a name="line-10575" data-line="10575">					return opt.complete.call( this );
</a><a name="line-10576" data-line="10576">				}
</a><a name="line-10577" data-line="10577">
</a><a name="line-10578" data-line="10578">				if ( isElement &amp;&amp; ( name === &quot;height&quot; || name === &quot;width&quot; ) ) {
</a><a name="line-10579" data-line="10579">					// Make sure that nothing sneaks out
</a><a name="line-10580" data-line="10580">					// Record all 3 overflow attributes because IE does not
</a><a name="line-10581" data-line="10581">					// change the overflow attribute when overflowX and
</a><a name="line-10582" data-line="10582">					// overflowY are set to the same value
</a><a name="line-10583" data-line="10583">					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];
</a><a name="line-10584" data-line="10584">
</a><a name="line-10585" data-line="10585">					// Set display property to inline-block for height/width
</a><a name="line-10586" data-line="10586">					// animations on inline elements that are having width/height animated
</a><a name="line-10587" data-line="10587">					if ( jQuery.css( this, &quot;display&quot; ) === &quot;inline&quot; &amp;&amp;
</a><a name="line-10588" data-line="10588">							jQuery.css( this, &quot;float&quot; ) === &quot;none&quot; ) {
</a><a name="line-10589" data-line="10589">
</a><a name="line-10590" data-line="10590">						// inline-level elements accept inline-block;
</a><a name="line-10591" data-line="10591">						// block-level elements need to be inline with layout
</a><a name="line-10592" data-line="10592">						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === &quot;inline&quot; ) {
</a><a name="line-10593" data-line="10593">							this.style.display = &quot;inline-block&quot;;
</a><a name="line-10594" data-line="10594">
</a><a name="line-10595" data-line="10595">						} else {
</a><a name="line-10596" data-line="10596">							this.style.zoom = 1;
</a><a name="line-10597" data-line="10597">						}
</a><a name="line-10598" data-line="10598">					}
</a><a name="line-10599" data-line="10599">				}
</a><a name="line-10600" data-line="10600">			}
</a><a name="line-10601" data-line="10601">
</a><a name="line-10602" data-line="10602">			if ( opt.overflow != null ) {
</a><a name="line-10603" data-line="10603">				this.style.overflow = &quot;hidden&quot;;
</a><a name="line-10604" data-line="10604">			}
</a><a name="line-10605" data-line="10605">
</a><a name="line-10606" data-line="10606">			for ( p in prop ) {
</a><a name="line-10607" data-line="10607">				e = new jQuery.fx( this, opt, p );
</a><a name="line-10608" data-line="10608">				val = prop[ p ];
</a><a name="line-10609" data-line="10609">
</a><a name="line-10610" data-line="10610">				if ( rfxtypes.test( val ) ) {
</a><a name="line-10611" data-line="10611">
</a><a name="line-10612" data-line="10612">					// Tracks whether to show or hide based on private
</a><a name="line-10613" data-line="10613">					// data attached to the element
</a><a name="line-10614" data-line="10614">					method = jQuery._data( this, &quot;toggle&quot; + p ) || ( val === &quot;toggle&quot; ? hidden ? &quot;show&quot; : &quot;hide&quot; : 0 );
</a><a name="line-10615" data-line="10615">					if ( method ) {
</a><a name="line-10616" data-line="10616">						jQuery._data( this, &quot;toggle&quot; + p, method === &quot;show&quot; ? &quot;hide&quot; : &quot;show&quot; );
</a><a name="line-10617" data-line="10617">						e[ method ]();
</a><a name="line-10618" data-line="10618">					} else {
</a><a name="line-10619" data-line="10619">						e[ val ]();
</a><a name="line-10620" data-line="10620">					}
</a><a name="line-10621" data-line="10621">
</a><a name="line-10622" data-line="10622">				} else {
</a><a name="line-10623" data-line="10623">					parts = rfxnum.exec( val );
</a><a name="line-10624" data-line="10624">					start = e.cur();
</a><a name="line-10625" data-line="10625">
</a><a name="line-10626" data-line="10626">					if ( parts ) {
</a><a name="line-10627" data-line="10627">						end = parseFloat( parts[2] );
</a><a name="line-10628" data-line="10628">						unit = parts[3] || ( jQuery.cssNumber[ p ] ? &quot;&quot; : &quot;px&quot; );
</a><a name="line-10629" data-line="10629">
</a><a name="line-10630" data-line="10630">						// We need to compute starting value
</a><a name="line-10631" data-line="10631">						if ( unit !== &quot;px&quot; ) {
</a><a name="line-10632" data-line="10632">							jQuery.style( this, p, (end || 1) + unit);
</a><a name="line-10633" data-line="10633">							start = ( (end || 1) / e.cur() ) * start;
</a><a name="line-10634" data-line="10634">							jQuery.style( this, p, start + unit);
</a><a name="line-10635" data-line="10635">						}
</a><a name="line-10636" data-line="10636">
</a><a name="line-10637" data-line="10637">						// If a +=/-= token was provided, we're doing a relative animation
</a><a name="line-10638" data-line="10638">						if ( parts[1] ) {
</a><a name="line-10639" data-line="10639">							end = ( (parts[ 1 ] === &quot;-=&quot; ? -1 : 1) * end ) + start;
</a><a name="line-10640" data-line="10640">						}
</a><a name="line-10641" data-line="10641">
</a><a name="line-10642" data-line="10642">						e.custom( start, end, unit );
</a><a name="line-10643" data-line="10643">
</a><a name="line-10644" data-line="10644">					} else {
</a><a name="line-10645" data-line="10645">						e.custom( start, val, &quot;&quot; );
</a><a name="line-10646" data-line="10646">					}
</a><a name="line-10647" data-line="10647">				}
</a><a name="line-10648" data-line="10648">			}
</a><a name="line-10649" data-line="10649">
</a><a name="line-10650" data-line="10650">			// For JS strict compliance
</a><a name="line-10651" data-line="10651">			return true;
</a><a name="line-10652" data-line="10652">		}
</a><a name="line-10653" data-line="10653">
</a><a name="line-10654" data-line="10654">		return optall.queue === false ?
</a><a name="line-10655" data-line="10655">			this.each( doAnimation ) :
</a><a name="line-10656" data-line="10656">			this.queue( optall.queue, doAnimation );
</a><a name="line-10657" data-line="10657">	},
</a><a name="line-10658" data-line="10658">
</a><a name="line-10659" data-line="10659">	stop: function( type, clearQueue, gotoEnd ) {
</a><a name="line-10660" data-line="10660">		if ( typeof type !== &quot;string&quot; ) {
</a><a name="line-10661" data-line="10661">			gotoEnd = clearQueue;
</a><a name="line-10662" data-line="10662">			clearQueue = type;
</a><a name="line-10663" data-line="10663">			type = undefined;
</a><a name="line-10664" data-line="10664">		}
</a><a name="line-10665" data-line="10665">		if ( clearQueue &amp;&amp; type !== false ) {
</a><a name="line-10666" data-line="10666">			this.queue( type || &quot;fx&quot;, [] );
</a><a name="line-10667" data-line="10667">		}
</a><a name="line-10668" data-line="10668">
</a><a name="line-10669" data-line="10669">		return this.each(function() {
</a><a name="line-10670" data-line="10670">			var index,
</a><a name="line-10671" data-line="10671">				hadTimers = false,
</a><a name="line-10672" data-line="10672">				timers = jQuery.timers,
</a><a name="line-10673" data-line="10673">				data = jQuery._data( this );
</a><a name="line-10674" data-line="10674">
</a><a name="line-10675" data-line="10675">			// clear marker counters if we know they won't be
</a><a name="line-10676" data-line="10676">			if ( !gotoEnd ) {
</a><a name="line-10677" data-line="10677">				jQuery._unmark( true, this );
</a><a name="line-10678" data-line="10678">			}
</a><a name="line-10679" data-line="10679">
</a><a name="line-10680" data-line="10680">			function stopQueue( elem, data, index ) {
</a><a name="line-10681" data-line="10681">				var hooks = data[ index ];
</a><a name="line-10682" data-line="10682">				jQuery.removeData( elem, index, true );
</a><a name="line-10683" data-line="10683">				hooks.stop( gotoEnd );
</a><a name="line-10684" data-line="10684">			}
</a><a name="line-10685" data-line="10685">
</a><a name="line-10686" data-line="10686">			if ( type == null ) {
</a><a name="line-10687" data-line="10687">				for ( index in data ) {
</a><a name="line-10688" data-line="10688">					if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; index.indexOf(&quot;.run&quot;) === index.length - 4 ) {
</a><a name="line-10689" data-line="10689">						stopQueue( this, data, index );
</a><a name="line-10690" data-line="10690">					}
</a><a name="line-10691" data-line="10691">				}
</a><a name="line-10692" data-line="10692">			} else if ( data[ index = type + &quot;.run&quot; ] &amp;&amp; data[ index ].stop ){
</a><a name="line-10693" data-line="10693">				stopQueue( this, data, index );
</a><a name="line-10694" data-line="10694">			}
</a><a name="line-10695" data-line="10695">
</a><a name="line-10696" data-line="10696">			for ( index = timers.length; index--; ) {
</a><a name="line-10697" data-line="10697">				if ( timers[ index ].elem === this &amp;&amp; (type == null || timers[ index ].queue === type) ) {
</a><a name="line-10698" data-line="10698">					if ( gotoEnd ) {
</a><a name="line-10699" data-line="10699">
</a><a name="line-10700" data-line="10700">						// force the next step to be the last
</a><a name="line-10701" data-line="10701">						timers[ index ]( true );
</a><a name="line-10702" data-line="10702">					} else {
</a><a name="line-10703" data-line="10703">						timers[ index ].saveState();
</a><a name="line-10704" data-line="10704">					}
</a><a name="line-10705" data-line="10705">					hadTimers = true;
</a><a name="line-10706" data-line="10706">					timers.splice( index, 1 );
</a><a name="line-10707" data-line="10707">				}
</a><a name="line-10708" data-line="10708">			}
</a><a name="line-10709" data-line="10709">
</a><a name="line-10710" data-line="10710">			// start the next in the queue if the last step wasn't forced
</a><a name="line-10711" data-line="10711">			// timers currently will call their complete callbacks, which will dequeue
</a><a name="line-10712" data-line="10712">			// but only if they were gotoEnd
</a><a name="line-10713" data-line="10713">			if ( !( gotoEnd &amp;&amp; hadTimers ) ) {
</a><a name="line-10714" data-line="10714">				jQuery.dequeue( this, type );
</a><a name="line-10715" data-line="10715">			}
</a><a name="line-10716" data-line="10716">		});
</a><a name="line-10717" data-line="10717">	}
</a><a name="line-10718" data-line="10718">
</a><a name="line-10719" data-line="10719">});
</a><a name="line-10720" data-line="10720">
</a><a name="line-10721" data-line="10721">// Animations created synchronously will run synchronously
</a><a name="line-10722" data-line="10722">function createFxNow() {
</a><a name="line-10723" data-line="10723">	setTimeout( clearFxNow, 0 );
</a><a name="line-10724" data-line="10724">	return ( fxNow = jQuery.now() );
</a><a name="line-10725" data-line="10725">}
</a><a name="line-10726" data-line="10726">
</a><a name="line-10727" data-line="10727">function clearFxNow() {
</a><a name="line-10728" data-line="10728">	fxNow = undefined;
</a><a name="line-10729" data-line="10729">}
</a><a name="line-10730" data-line="10730">
</a><a name="line-10731" data-line="10731">// Generate parameters to create a standard animation
</a><a name="line-10732" data-line="10732">function genFx( type, num ) {
</a><a name="line-10733" data-line="10733">	var obj = {};
</a><a name="line-10734" data-line="10734">
</a><a name="line-10735" data-line="10735">	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
</a><a name="line-10736" data-line="10736">		obj[ this ] = type;
</a><a name="line-10737" data-line="10737">	});
</a><a name="line-10738" data-line="10738">
</a><a name="line-10739" data-line="10739">	return obj;
</a><a name="line-10740" data-line="10740">}
</a><a name="line-10741" data-line="10741">
</a><a name="line-10742" data-line="10742">// Generate shortcuts for custom animations
</a><a name="line-10743" data-line="10743">jQuery.each({
</a><a name="line-10744" data-line="10744">	slideDown: genFx( &quot;show&quot;, 1 ),
</a><a name="line-10745" data-line="10745">	slideUp: genFx( &quot;hide&quot;, 1 ),
</a><a name="line-10746" data-line="10746">	slideToggle: genFx( &quot;toggle&quot;, 1 ),
</a><a name="line-10747" data-line="10747">	fadeIn: { opacity: &quot;show&quot; },
</a><a name="line-10748" data-line="10748">	fadeOut: { opacity: &quot;hide&quot; },
</a><a name="line-10749" data-line="10749">	fadeToggle: { opacity: &quot;toggle&quot; }
</a><a name="line-10750" data-line="10750">}, function( name, props ) {
</a><a name="line-10751" data-line="10751">	jQuery.fn[ name ] = function( speed, easing, callback ) {
</a><a name="line-10752" data-line="10752">		return this.animate( props, speed, easing, callback );
</a><a name="line-10753" data-line="10753">	};
</a><a name="line-10754" data-line="10754">});
</a><a name="line-10755" data-line="10755">
</a><a name="line-10756" data-line="10756">jQuery.extend({
</a><a name="line-10757" data-line="10757">	speed: function( speed, easing, fn ) {
</a><a name="line-10758" data-line="10758">		var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
</a><a name="line-10759" data-line="10759">			complete: fn || !fn &amp;&amp; easing ||
</a><a name="line-10760" data-line="10760">				jQuery.isFunction( speed ) &amp;&amp; speed,
</a><a name="line-10761" data-line="10761">			duration: speed,
</a><a name="line-10762" data-line="10762">			easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing
</a><a name="line-10763" data-line="10763">		};
</a><a name="line-10764" data-line="10764">
</a><a name="line-10765" data-line="10765">		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === &quot;number&quot; ? opt.duration :
</a><a name="line-10766" data-line="10766">			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
</a><a name="line-10767" data-line="10767">
</a><a name="line-10768" data-line="10768">		// normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
</a><a name="line-10769" data-line="10769">		if ( opt.queue == null || opt.queue === true ) {
</a><a name="line-10770" data-line="10770">			opt.queue = &quot;fx&quot;;
</a><a name="line-10771" data-line="10771">		}
</a><a name="line-10772" data-line="10772">
</a><a name="line-10773" data-line="10773">		// Queueing
</a><a name="line-10774" data-line="10774">		opt.old = opt.complete;
</a><a name="line-10775" data-line="10775">
</a><a name="line-10776" data-line="10776">		opt.complete = function( noUnmark ) {
</a><a name="line-10777" data-line="10777">			if ( jQuery.isFunction( opt.old ) ) {
</a><a name="line-10778" data-line="10778">				opt.old.call( this );
</a><a name="line-10779" data-line="10779">			}
</a><a name="line-10780" data-line="10780">
</a><a name="line-10781" data-line="10781">			if ( opt.queue ) {
</a><a name="line-10782" data-line="10782">				jQuery.dequeue( this, opt.queue );
</a><a name="line-10783" data-line="10783">			} else if ( noUnmark !== false ) {
</a><a name="line-10784" data-line="10784">				jQuery._unmark( this );
</a><a name="line-10785" data-line="10785">			}
</a><a name="line-10786" data-line="10786">		};
</a><a name="line-10787" data-line="10787">
</a><a name="line-10788" data-line="10788">		return opt;
</a><a name="line-10789" data-line="10789">	},
</a><a name="line-10790" data-line="10790">
</a><a name="line-10791" data-line="10791">	easing: {
</a><a name="line-10792" data-line="10792">		linear: function( p ) {
</a><a name="line-10793" data-line="10793">			return p;
</a><a name="line-10794" data-line="10794">		},
</a><a name="line-10795" data-line="10795">		swing: function( p ) {
</a><a name="line-10796" data-line="10796">			return ( -Math.cos( p*Math.PI ) / 2 ) + 0.5;
</a><a name="line-10797" data-line="10797">		}
</a><a name="line-10798" data-line="10798">	},
</a><a name="line-10799" data-line="10799">
</a><a name="line-10800" data-line="10800">	timers: [],
</a><a name="line-10801" data-line="10801">
</a><a name="line-10802" data-line="10802">	fx: function( elem, options, prop ) {
</a><a name="line-10803" data-line="10803">		this.options = options;
</a><a name="line-10804" data-line="10804">		this.elem = elem;
</a><a name="line-10805" data-line="10805">		this.prop = prop;
</a><a name="line-10806" data-line="10806">
</a><a name="line-10807" data-line="10807">		options.orig = options.orig || {};
</a><a name="line-10808" data-line="10808">	}
</a><a name="line-10809" data-line="10809">
</a><a name="line-10810" data-line="10810">});
</a><a name="line-10811" data-line="10811">
</a><a name="line-10812" data-line="10812">jQuery.fx.prototype = {
</a><a name="line-10813" data-line="10813">	// Simple function for setting a style value
</a><a name="line-10814" data-line="10814">	update: function() {
</a><a name="line-10815" data-line="10815">		if ( this.options.step ) {
</a><a name="line-10816" data-line="10816">			this.options.step.call( this.elem, this.now, this );
</a><a name="line-10817" data-line="10817">		}
</a><a name="line-10818" data-line="10818">
</a><a name="line-10819" data-line="10819">		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
</a><a name="line-10820" data-line="10820">	},
</a><a name="line-10821" data-line="10821">
</a><a name="line-10822" data-line="10822">	// Get the current size
</a><a name="line-10823" data-line="10823">	cur: function() {
</a><a name="line-10824" data-line="10824">		if ( this.elem[ this.prop ] != null &amp;&amp; (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
</a><a name="line-10825" data-line="10825">			return this.elem[ this.prop ];
</a><a name="line-10826" data-line="10826">		}
</a><a name="line-10827" data-line="10827">
</a><a name="line-10828" data-line="10828">		var parsed,
</a><a name="line-10829" data-line="10829">			r = jQuery.css( this.elem, this.prop );
</a><a name="line-10830" data-line="10830">		// Empty strings, null, undefined and &quot;auto&quot; are converted to 0,
</a><a name="line-10831" data-line="10831">		// complex values such as &quot;rotate(1rad)&quot; are returned as is,
</a><a name="line-10832" data-line="10832">		// simple values such as &quot;10px&quot; are parsed to Float.
</a><a name="line-10833" data-line="10833">		return isNaN( parsed = parseFloat( r ) ) ? !r || r === &quot;auto&quot; ? 0 : r : parsed;
</a><a name="line-10834" data-line="10834">	},
</a><a name="line-10835" data-line="10835">
</a><a name="line-10836" data-line="10836">	// Start an animation from one number to another
</a><a name="line-10837" data-line="10837">	custom: function( from, to, unit ) {
</a><a name="line-10838" data-line="10838">		var self = this,
</a><a name="line-10839" data-line="10839">			fx = jQuery.fx;
</a><a name="line-10840" data-line="10840">
</a><a name="line-10841" data-line="10841">		this.startTime = fxNow || createFxNow();
</a><a name="line-10842" data-line="10842">		this.end = to;
</a><a name="line-10843" data-line="10843">		this.now = this.start = from;
</a><a name="line-10844" data-line="10844">		this.pos = this.state = 0;
</a><a name="line-10845" data-line="10845">		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? &quot;&quot; : &quot;px&quot; );
</a><a name="line-10846" data-line="10846">
</a><a name="line-10847" data-line="10847">		function t( gotoEnd ) {
</a><a name="line-10848" data-line="10848">			return self.step( gotoEnd );
</a><a name="line-10849" data-line="10849">		}
</a><a name="line-10850" data-line="10850">
</a><a name="line-10851" data-line="10851">		t.queue = this.options.queue;
</a><a name="line-10852" data-line="10852">		t.elem = this.elem;
</a><a name="line-10853" data-line="10853">		t.saveState = function() {
</a><a name="line-10854" data-line="10854">			if ( jQuery._data( self.elem, &quot;fxshow&quot; + self.prop ) === undefined ) {
</a><a name="line-10855" data-line="10855">				if ( self.options.hide ) {
</a><a name="line-10856" data-line="10856">					jQuery._data( self.elem, &quot;fxshow&quot; + self.prop, self.start );
</a><a name="line-10857" data-line="10857">				} else if ( self.options.show ) {
</a><a name="line-10858" data-line="10858">					jQuery._data( self.elem, &quot;fxshow&quot; + self.prop, self.end );
</a><a name="line-10859" data-line="10859">				}
</a><a name="line-10860" data-line="10860">			}
</a><a name="line-10861" data-line="10861">		};
</a><a name="line-10862" data-line="10862">
</a><a name="line-10863" data-line="10863">		if ( t() &amp;&amp; jQuery.timers.push(t) &amp;&amp; !timerId ) {
</a><a name="line-10864" data-line="10864">			timerId = setInterval( fx.tick, fx.interval );
</a><a name="line-10865" data-line="10865">		}
</a><a name="line-10866" data-line="10866">	},
</a><a name="line-10867" data-line="10867">
</a><a name="line-10868" data-line="10868">	// Simple 'show' function
</a><a name="line-10869" data-line="10869">	show: function() {
</a><a name="line-10870" data-line="10870">		var dataShow = jQuery._data( this.elem, &quot;fxshow&quot; + this.prop );
</a><a name="line-10871" data-line="10871">
</a><a name="line-10872" data-line="10872">		// Remember where we started, so that we can go back to it later
</a><a name="line-10873" data-line="10873">		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
</a><a name="line-10874" data-line="10874">		this.options.show = true;
</a><a name="line-10875" data-line="10875">
</a><a name="line-10876" data-line="10876">		// Begin the animation
</a><a name="line-10877" data-line="10877">		// Make sure that we start at a small width/height to avoid any flash of content
</a><a name="line-10878" data-line="10878">		if ( dataShow !== undefined ) {
</a><a name="line-10879" data-line="10879">			// This show is picking up where a previous hide or show left off
</a><a name="line-10880" data-line="10880">			this.custom( this.cur(), dataShow );
</a><a name="line-10881" data-line="10881">		} else {
</a><a name="line-10882" data-line="10882">			this.custom( this.prop === &quot;width&quot; || this.prop === &quot;height&quot; ? 1 : 0, this.cur() );
</a><a name="line-10883" data-line="10883">		}
</a><a name="line-10884" data-line="10884">
</a><a name="line-10885" data-line="10885">		// Start by showing the element
</a><a name="line-10886" data-line="10886">		jQuery( this.elem ).show();
</a><a name="line-10887" data-line="10887">	},
</a><a name="line-10888" data-line="10888">
</a><a name="line-10889" data-line="10889">	// Simple 'hide' function
</a><a name="line-10890" data-line="10890">	hide: function() {
</a><a name="line-10891" data-line="10891">		// Remember where we started, so that we can go back to it later
</a><a name="line-10892" data-line="10892">		this.options.orig[ this.prop ] = jQuery._data( this.elem, &quot;fxshow&quot; + this.prop ) || jQuery.style( this.elem, this.prop );
</a><a name="line-10893" data-line="10893">		this.options.hide = true;
</a><a name="line-10894" data-line="10894">
</a><a name="line-10895" data-line="10895">		// Begin the animation
</a><a name="line-10896" data-line="10896">		this.custom( this.cur(), 0 );
</a><a name="line-10897" data-line="10897">	},
</a><a name="line-10898" data-line="10898">
</a><a name="line-10899" data-line="10899">	// Each step of an animation
</a><a name="line-10900" data-line="10900">	step: function( gotoEnd ) {
</a><a name="line-10901" data-line="10901">		var p, n, complete,
</a><a name="line-10902" data-line="10902">			t = fxNow || createFxNow(),
</a><a name="line-10903" data-line="10903">			done = true,
</a><a name="line-10904" data-line="10904">			elem = this.elem,
</a><a name="line-10905" data-line="10905">			options = this.options;
</a><a name="line-10906" data-line="10906">
</a><a name="line-10907" data-line="10907">		if ( gotoEnd || t &gt;= options.duration + this.startTime ) {
</a><a name="line-10908" data-line="10908">			this.now = this.end;
</a><a name="line-10909" data-line="10909">			this.pos = this.state = 1;
</a><a name="line-10910" data-line="10910">			this.update();
</a><a name="line-10911" data-line="10911">
</a><a name="line-10912" data-line="10912">			options.animatedProperties[ this.prop ] = true;
</a><a name="line-10913" data-line="10913">
</a><a name="line-10914" data-line="10914">			for ( p in options.animatedProperties ) {
</a><a name="line-10915" data-line="10915">				if ( options.animatedProperties[ p ] !== true ) {
</a><a name="line-10916" data-line="10916">					done = false;
</a><a name="line-10917" data-line="10917">				}
</a><a name="line-10918" data-line="10918">			}
</a><a name="line-10919" data-line="10919">
</a><a name="line-10920" data-line="10920">			if ( done ) {
</a><a name="line-10921" data-line="10921">				// Reset the overflow
</a><a name="line-10922" data-line="10922">				if ( options.overflow != null &amp;&amp; !jQuery.support.shrinkWrapBlocks ) {
</a><a name="line-10923" data-line="10923">
</a><a name="line-10924" data-line="10924">					jQuery.each( [ &quot;&quot;, &quot;X&quot;, &quot;Y&quot; ], function( index, value ) {
</a><a name="line-10925" data-line="10925">						elem.style[ &quot;overflow&quot; + value ] = options.overflow[ index ];
</a><a name="line-10926" data-line="10926">					});
</a><a name="line-10927" data-line="10927">				}
</a><a name="line-10928" data-line="10928">
</a><a name="line-10929" data-line="10929">				// Hide the element if the &quot;hide&quot; operation was done
</a><a name="line-10930" data-line="10930">				if ( options.hide ) {
</a><a name="line-10931" data-line="10931">					jQuery( elem ).hide();
</a><a name="line-10932" data-line="10932">				}
</a><a name="line-10933" data-line="10933">
</a><a name="line-10934" data-line="10934">				// Reset the properties, if the item has been hidden or shown
</a><a name="line-10935" data-line="10935">				if ( options.hide || options.show ) {
</a><a name="line-10936" data-line="10936">					for ( p in options.animatedProperties ) {
</a><a name="line-10937" data-line="10937">						jQuery.style( elem, p, options.orig[ p ] );
</a><a name="line-10938" data-line="10938">						jQuery.removeData( elem, &quot;fxshow&quot; + p, true );
</a><a name="line-10939" data-line="10939">						// Toggle data is no longer needed
</a><a name="line-10940" data-line="10940">						jQuery.removeData( elem, &quot;toggle&quot; + p, true );
</a><a name="line-10941" data-line="10941">					}
</a><a name="line-10942" data-line="10942">				}
</a><a name="line-10943" data-line="10943">
</a><a name="line-10944" data-line="10944">				// Execute the complete function
</a><a name="line-10945" data-line="10945">				// in the event that the complete function throws an exception
</a><a name="line-10946" data-line="10946">				// we must ensure it won't be called twice. #5684
</a><a name="line-10947" data-line="10947">
</a><a name="line-10948" data-line="10948">				complete = options.complete;
</a><a name="line-10949" data-line="10949">				if ( complete ) {
</a><a name="line-10950" data-line="10950">
</a><a name="line-10951" data-line="10951">					options.complete = false;
</a><a name="line-10952" data-line="10952">					complete.call( elem );
</a><a name="line-10953" data-line="10953">				}
</a><a name="line-10954" data-line="10954">			}
</a><a name="line-10955" data-line="10955">
</a><a name="line-10956" data-line="10956">			return false;
</a><a name="line-10957" data-line="10957">
</a><a name="line-10958" data-line="10958">		} else {
</a><a name="line-10959" data-line="10959">			// classical easing cannot be used with an Infinity duration
</a><a name="line-10960" data-line="10960">			if ( options.duration == Infinity ) {
</a><a name="line-10961" data-line="10961">				this.now = t;
</a><a name="line-10962" data-line="10962">			} else {
</a><a name="line-10963" data-line="10963">				n = t - this.startTime;
</a><a name="line-10964" data-line="10964">				this.state = n / options.duration;
</a><a name="line-10965" data-line="10965">
</a><a name="line-10966" data-line="10966">				// Perform the easing function, defaults to swing
</a><a name="line-10967" data-line="10967">				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
</a><a name="line-10968" data-line="10968">				this.now = this.start + ( (this.end - this.start) * this.pos );
</a><a name="line-10969" data-line="10969">			}
</a><a name="line-10970" data-line="10970">			// Perform the next step of the animation
</a><a name="line-10971" data-line="10971">			this.update();
</a><a name="line-10972" data-line="10972">		}
</a><a name="line-10973" data-line="10973">
</a><a name="line-10974" data-line="10974">		return true;
</a><a name="line-10975" data-line="10975">	}
</a><a name="line-10976" data-line="10976">};
</a><a name="line-10977" data-line="10977">
</a><a name="line-10978" data-line="10978">jQuery.extend( jQuery.fx, {
</a><a name="line-10979" data-line="10979">	tick: function() {
</a><a name="line-10980" data-line="10980">		var timer,
</a><a name="line-10981" data-line="10981">			timers = jQuery.timers,
</a><a name="line-10982" data-line="10982">			i = 0;
</a><a name="line-10983" data-line="10983">
</a><a name="line-10984" data-line="10984">		for ( ; i &lt; timers.length; i++ ) {
</a><a name="line-10985" data-line="10985">			timer = timers[ i ];
</a><a name="line-10986" data-line="10986">			// Checks the timer has not already been removed
</a><a name="line-10987" data-line="10987">			if ( !timer() &amp;&amp; timers[ i ] === timer ) {
</a><a name="line-10988" data-line="10988">				timers.splice( i--, 1 );
</a><a name="line-10989" data-line="10989">			}
</a><a name="line-10990" data-line="10990">		}
</a><a name="line-10991" data-line="10991">
</a><a name="line-10992" data-line="10992">		if ( !timers.length ) {
</a><a name="line-10993" data-line="10993">			jQuery.fx.stop();
</a><a name="line-10994" data-line="10994">		}
</a><a name="line-10995" data-line="10995">	},
</a><a name="line-10996" data-line="10996">
</a><a name="line-10997" data-line="10997">	interval: 13,
</a><a name="line-10998" data-line="10998">
</a><a name="line-10999" data-line="10999">	stop: function() {
</a><a name="line-11000" data-line="11000">		clearInterval( timerId );
</a><a name="line-11001" data-line="11001">		timerId = null;
</a><a name="line-11002" data-line="11002">	},
</a><a name="line-11003" data-line="11003">
</a><a name="line-11004" data-line="11004">	speeds: {
</a><a name="line-11005" data-line="11005">		slow: 600,
</a><a name="line-11006" data-line="11006">		fast: 200,
</a><a name="line-11007" data-line="11007">		// Default speed
</a><a name="line-11008" data-line="11008">		_default: 400
</a><a name="line-11009" data-line="11009">	},
</a><a name="line-11010" data-line="11010">
</a><a name="line-11011" data-line="11011">	step: {
</a><a name="line-11012" data-line="11012">		opacity: function( fx ) {
</a><a name="line-11013" data-line="11013">			jQuery.style( fx.elem, &quot;opacity&quot;, fx.now );
</a><a name="line-11014" data-line="11014">		},
</a><a name="line-11015" data-line="11015">
</a><a name="line-11016" data-line="11016">		_default: function( fx ) {
</a><a name="line-11017" data-line="11017">			if ( fx.elem.style &amp;&amp; fx.elem.style[ fx.prop ] != null ) {
</a><a name="line-11018" data-line="11018">				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
</a><a name="line-11019" data-line="11019">			} else {
</a><a name="line-11020" data-line="11020">				fx.elem[ fx.prop ] = fx.now;
</a><a name="line-11021" data-line="11021">			}
</a><a name="line-11022" data-line="11022">		}
</a><a name="line-11023" data-line="11023">	}
</a><a name="line-11024" data-line="11024">});
</a><a name="line-11025" data-line="11025">
</a><a name="line-11026" data-line="11026">// Ensure props that can't be negative don't go there on undershoot easing
</a><a name="line-11027" data-line="11027">jQuery.each( fxAttrs.concat.apply( [], fxAttrs ), function( i, prop ) {
</a><a name="line-11028" data-line="11028">	// exclude marginTop, marginLeft, marginBottom and marginRight from this list
</a><a name="line-11029" data-line="11029">	if ( prop.indexOf( &quot;margin&quot; ) ) {
</a><a name="line-11030" data-line="11030">		jQuery.fx.step[ prop ] = function( fx ) {
</a><a name="line-11031" data-line="11031">			jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
</a><a name="line-11032" data-line="11032">		};
</a><a name="line-11033" data-line="11033">	}
</a><a name="line-11034" data-line="11034">});
</a><a name="line-11035" data-line="11035">
</a><a name="line-11036" data-line="11036">if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {
</a><a name="line-11037" data-line="11037">	jQuery.expr.filters.animated = function( elem ) {
</a><a name="line-11038" data-line="11038">		return jQuery.grep(jQuery.timers, function( fn ) {
</a><a name="line-11039" data-line="11039">			return elem === fn.elem;
</a><a name="line-11040" data-line="11040">		}).length;
</a><a name="line-11041" data-line="11041">	};
</a><a name="line-11042" data-line="11042">}
</a><a name="line-11043" data-line="11043">
</a><a name="line-11044" data-line="11044">// Try to restore the default display value of an element
</a><a name="line-11045" data-line="11045">function defaultDisplay( nodeName ) {
</a><a name="line-11046" data-line="11046">
</a><a name="line-11047" data-line="11047">	if ( !elemdisplay[ nodeName ] ) {
</a><a name="line-11048" data-line="11048">
</a><a name="line-11049" data-line="11049">		var body = document.body,
</a><a name="line-11050" data-line="11050">			elem = jQuery( &quot;&lt;&quot; + nodeName + &quot;&gt;&quot; ).appendTo( body ),
</a><a name="line-11051" data-line="11051">			display = elem.css( &quot;display&quot; );
</a><a name="line-11052" data-line="11052">		elem.remove();
</a><a name="line-11053" data-line="11053">
</a><a name="line-11054" data-line="11054">		// If the simple way fails,
</a><a name="line-11055" data-line="11055">		// get element's real default display by attaching it to a temp iframe
</a><a name="line-11056" data-line="11056">		if ( display === &quot;none&quot; || display === &quot;&quot; ) {
</a><a name="line-11057" data-line="11057">			// No iframe to use yet, so create it
</a><a name="line-11058" data-line="11058">			if ( !iframe ) {
</a><a name="line-11059" data-line="11059">				iframe = document.createElement( &quot;iframe&quot; );
</a><a name="line-11060" data-line="11060">				iframe.frameBorder = iframe.width = iframe.height = 0;
</a><a name="line-11061" data-line="11061">			}
</a><a name="line-11062" data-line="11062">
</a><a name="line-11063" data-line="11063">			body.appendChild( iframe );
</a><a name="line-11064" data-line="11064">
</a><a name="line-11065" data-line="11065">			// Create a cacheable copy of the iframe document on first call.
</a><a name="line-11066" data-line="11066">			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
</a><a name="line-11067" data-line="11067">			// document to it; WebKit &amp; Firefox won't allow reusing the iframe document.
</a><a name="line-11068" data-line="11068">			if ( !iframeDoc || !iframe.createElement ) {
</a><a name="line-11069" data-line="11069">				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
</a><a name="line-11070" data-line="11070">				iframeDoc.write( ( jQuery.support.boxModel ? &quot;&lt;!doctype html&gt;&quot; : &quot;&quot; ) + &quot;&lt;html&gt;&lt;body&gt;&quot; );
</a><a name="line-11071" data-line="11071">				iframeDoc.close();
</a><a name="line-11072" data-line="11072">			}
</a><a name="line-11073" data-line="11073">
</a><a name="line-11074" data-line="11074">			elem = iframeDoc.createElement( nodeName );
</a><a name="line-11075" data-line="11075">
</a><a name="line-11076" data-line="11076">			iframeDoc.body.appendChild( elem );
</a><a name="line-11077" data-line="11077">
</a><a name="line-11078" data-line="11078">			display = jQuery.css( elem, &quot;display&quot; );
</a><a name="line-11079" data-line="11079">			body.removeChild( iframe );
</a><a name="line-11080" data-line="11080">		}
</a><a name="line-11081" data-line="11081">
</a><a name="line-11082" data-line="11082">		// Store the correct default display
</a><a name="line-11083" data-line="11083">		elemdisplay[ nodeName ] = display;
</a><a name="line-11084" data-line="11084">	}
</a><a name="line-11085" data-line="11085">
</a><a name="line-11086" data-line="11086">	return elemdisplay[ nodeName ];
</a><a name="line-11087" data-line="11087">}
</a><a name="line-11088" data-line="11088">
</a><a name="line-11089" data-line="11089">
</a><a name="line-11090" data-line="11090">
</a><a name="line-11091" data-line="11091">
</a><a name="line-11092" data-line="11092">var getOffset,
</a><a name="line-11093" data-line="11093">	rtable = /^t(?:able|d|h)$/i,
</a><a name="line-11094" data-line="11094">	rroot = /^(?:body|html)$/i;
</a><a name="line-11095" data-line="11095">
</a><a name="line-11096" data-line="11096">if ( &quot;getBoundingClientRect&quot; in document.documentElement ) {
</a><a name="line-11097" data-line="11097">	getOffset = function( elem, doc, docElem, box ) {
</a><a name="line-11098" data-line="11098">		try {
</a><a name="line-11099" data-line="11099">			box = elem.getBoundingClientRect();
</a><a name="line-11100" data-line="11100">		} catch(e) {}
</a><a name="line-11101" data-line="11101">
</a><a name="line-11102" data-line="11102">		// Make sure we're not dealing with a disconnected DOM node
</a><a name="line-11103" data-line="11103">		if ( !box || !jQuery.contains( docElem, elem ) ) {
</a><a name="line-11104" data-line="11104">			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
</a><a name="line-11105" data-line="11105">		}
</a><a name="line-11106" data-line="11106">
</a><a name="line-11107" data-line="11107">		var body = doc.body,
</a><a name="line-11108" data-line="11108">			win = getWindow( doc ),
</a><a name="line-11109" data-line="11109">			clientTop  = docElem.clientTop  || body.clientTop  || 0,
</a><a name="line-11110" data-line="11110">			clientLeft = docElem.clientLeft || body.clientLeft || 0,
</a><a name="line-11111" data-line="11111">			scrollTop  = win.pageYOffset || jQuery.support.boxModel &amp;&amp; docElem.scrollTop  || body.scrollTop,
</a><a name="line-11112" data-line="11112">			scrollLeft = win.pageXOffset || jQuery.support.boxModel &amp;&amp; docElem.scrollLeft || body.scrollLeft,
</a><a name="line-11113" data-line="11113">			top  = box.top  + scrollTop  - clientTop,
</a><a name="line-11114" data-line="11114">			left = box.left + scrollLeft - clientLeft;
</a><a name="line-11115" data-line="11115">
</a><a name="line-11116" data-line="11116">		return { top: top, left: left };
</a><a name="line-11117" data-line="11117">	};
</a><a name="line-11118" data-line="11118">
</a><a name="line-11119" data-line="11119">} else {
</a><a name="line-11120" data-line="11120">	getOffset = function( elem, doc, docElem ) {
</a><a name="line-11121" data-line="11121">		var computedStyle,
</a><a name="line-11122" data-line="11122">			offsetParent = elem.offsetParent,
</a><a name="line-11123" data-line="11123">			prevOffsetParent = elem,
</a><a name="line-11124" data-line="11124">			body = doc.body,
</a><a name="line-11125" data-line="11125">			defaultView = doc.defaultView,
</a><a name="line-11126" data-line="11126">			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
</a><a name="line-11127" data-line="11127">			top = elem.offsetTop,
</a><a name="line-11128" data-line="11128">			left = elem.offsetLeft;
</a><a name="line-11129" data-line="11129">
</a><a name="line-11130" data-line="11130">		while ( (elem = elem.parentNode) &amp;&amp; elem !== body &amp;&amp; elem !== docElem ) {
</a><a name="line-11131" data-line="11131">			if ( jQuery.support.fixedPosition &amp;&amp; prevComputedStyle.position === &quot;fixed&quot; ) {
</a><a name="line-11132" data-line="11132">				break;
</a><a name="line-11133" data-line="11133">			}
</a><a name="line-11134" data-line="11134">
</a><a name="line-11135" data-line="11135">			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
</a><a name="line-11136" data-line="11136">			top  -= elem.scrollTop;
</a><a name="line-11137" data-line="11137">			left -= elem.scrollLeft;
</a><a name="line-11138" data-line="11138">
</a><a name="line-11139" data-line="11139">			if ( elem === offsetParent ) {
</a><a name="line-11140" data-line="11140">				top  += elem.offsetTop;
</a><a name="line-11141" data-line="11141">				left += elem.offsetLeft;
</a><a name="line-11142" data-line="11142">
</a><a name="line-11143" data-line="11143">				if ( jQuery.support.doesNotAddBorder &amp;&amp; !(jQuery.support.doesAddBorderForTableAndCells &amp;&amp; rtable.test(elem.nodeName)) ) {
</a><a name="line-11144" data-line="11144">					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
</a><a name="line-11145" data-line="11145">					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
</a><a name="line-11146" data-line="11146">				}
</a><a name="line-11147" data-line="11147">
</a><a name="line-11148" data-line="11148">				prevOffsetParent = offsetParent;
</a><a name="line-11149" data-line="11149">				offsetParent = elem.offsetParent;
</a><a name="line-11150" data-line="11150">			}
</a><a name="line-11151" data-line="11151">
</a><a name="line-11152" data-line="11152">			if ( jQuery.support.subtractsBorderForOverflowNotVisible &amp;&amp; computedStyle.overflow !== &quot;visible&quot; ) {
</a><a name="line-11153" data-line="11153">				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
</a><a name="line-11154" data-line="11154">				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
</a><a name="line-11155" data-line="11155">			}
</a><a name="line-11156" data-line="11156">
</a><a name="line-11157" data-line="11157">			prevComputedStyle = computedStyle;
</a><a name="line-11158" data-line="11158">		}
</a><a name="line-11159" data-line="11159">
</a><a name="line-11160" data-line="11160">		if ( prevComputedStyle.position === &quot;relative&quot; || prevComputedStyle.position === &quot;static&quot; ) {
</a><a name="line-11161" data-line="11161">			top  += body.offsetTop;
</a><a name="line-11162" data-line="11162">			left += body.offsetLeft;
</a><a name="line-11163" data-line="11163">		}
</a><a name="line-11164" data-line="11164">
</a><a name="line-11165" data-line="11165">		if ( jQuery.support.fixedPosition &amp;&amp; prevComputedStyle.position === &quot;fixed&quot; ) {
</a><a name="line-11166" data-line="11166">			top  += Math.max( docElem.scrollTop, body.scrollTop );
</a><a name="line-11167" data-line="11167">			left += Math.max( docElem.scrollLeft, body.scrollLeft );
</a><a name="line-11168" data-line="11168">		}
</a><a name="line-11169" data-line="11169">
</a><a name="line-11170" data-line="11170">		return { top: top, left: left };
</a><a name="line-11171" data-line="11171">	};
</a><a name="line-11172" data-line="11172">}
</a><a name="line-11173" data-line="11173">
</a><a name="line-11174" data-line="11174">jQuery.fn.offset = function( options ) {
</a><a name="line-11175" data-line="11175">	if ( arguments.length ) {
</a><a name="line-11176" data-line="11176">		return options === undefined ?
</a><a name="line-11177" data-line="11177">			this :
</a><a name="line-11178" data-line="11178">			this.each(function( i ) {
</a><a name="line-11179" data-line="11179">				jQuery.offset.setOffset( this, options, i );
</a><a name="line-11180" data-line="11180">			});
</a><a name="line-11181" data-line="11181">	}
</a><a name="line-11182" data-line="11182">
</a><a name="line-11183" data-line="11183">	var elem = this[0],
</a><a name="line-11184" data-line="11184">		doc = elem &amp;&amp; elem.ownerDocument;
</a><a name="line-11185" data-line="11185">
</a><a name="line-11186" data-line="11186">	if ( !doc ) {
</a><a name="line-11187" data-line="11187">		return null;
</a><a name="line-11188" data-line="11188">	}
</a><a name="line-11189" data-line="11189">
</a><a name="line-11190" data-line="11190">	if ( elem === doc.body ) {
</a><a name="line-11191" data-line="11191">		return jQuery.offset.bodyOffset( elem );
</a><a name="line-11192" data-line="11192">	}
</a><a name="line-11193" data-line="11193">
</a><a name="line-11194" data-line="11194">	return getOffset( elem, doc, doc.documentElement );
</a><a name="line-11195" data-line="11195">};
</a><a name="line-11196" data-line="11196">
</a><a name="line-11197" data-line="11197">jQuery.offset = {
</a><a name="line-11198" data-line="11198">
</a><a name="line-11199" data-line="11199">	bodyOffset: function( body ) {
</a><a name="line-11200" data-line="11200">		var top = body.offsetTop,
</a><a name="line-11201" data-line="11201">			left = body.offsetLeft;
</a><a name="line-11202" data-line="11202">
</a><a name="line-11203" data-line="11203">		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
</a><a name="line-11204" data-line="11204">			top  += parseFloat( jQuery.css(body, &quot;marginTop&quot;) ) || 0;
</a><a name="line-11205" data-line="11205">			left += parseFloat( jQuery.css(body, &quot;marginLeft&quot;) ) || 0;
</a><a name="line-11206" data-line="11206">		}
</a><a name="line-11207" data-line="11207">
</a><a name="line-11208" data-line="11208">		return { top: top, left: left };
</a><a name="line-11209" data-line="11209">	},
</a><a name="line-11210" data-line="11210">
</a><a name="line-11211" data-line="11211">	setOffset: function( elem, options, i ) {
</a><a name="line-11212" data-line="11212">		var position = jQuery.css( elem, &quot;position&quot; );
</a><a name="line-11213" data-line="11213">
</a><a name="line-11214" data-line="11214">		// set position first, in-case top/left are set even on static elem
</a><a name="line-11215" data-line="11215">		if ( position === &quot;static&quot; ) {
</a><a name="line-11216" data-line="11216">			elem.style.position = &quot;relative&quot;;
</a><a name="line-11217" data-line="11217">		}
</a><a name="line-11218" data-line="11218">
</a><a name="line-11219" data-line="11219">		var curElem = jQuery( elem ),
</a><a name="line-11220" data-line="11220">			curOffset = curElem.offset(),
</a><a name="line-11221" data-line="11221">			curCSSTop = jQuery.css( elem, &quot;top&quot; ),
</a><a name="line-11222" data-line="11222">			curCSSLeft = jQuery.css( elem, &quot;left&quot; ),
</a><a name="line-11223" data-line="11223">			calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp; jQuery.inArray(&quot;auto&quot;, [curCSSTop, curCSSLeft]) &gt; -1,
</a><a name="line-11224" data-line="11224">			props = {}, curPosition = {}, curTop, curLeft;
</a><a name="line-11225" data-line="11225">
</a><a name="line-11226" data-line="11226">		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
</a><a name="line-11227" data-line="11227">		if ( calculatePosition ) {
</a><a name="line-11228" data-line="11228">			curPosition = curElem.position();
</a><a name="line-11229" data-line="11229">			curTop = curPosition.top;
</a><a name="line-11230" data-line="11230">			curLeft = curPosition.left;
</a><a name="line-11231" data-line="11231">		} else {
</a><a name="line-11232" data-line="11232">			curTop = parseFloat( curCSSTop ) || 0;
</a><a name="line-11233" data-line="11233">			curLeft = parseFloat( curCSSLeft ) || 0;
</a><a name="line-11234" data-line="11234">		}
</a><a name="line-11235" data-line="11235">
</a><a name="line-11236" data-line="11236">		if ( jQuery.isFunction( options ) ) {
</a><a name="line-11237" data-line="11237">			options = options.call( elem, i, curOffset );
</a><a name="line-11238" data-line="11238">		}
</a><a name="line-11239" data-line="11239">
</a><a name="line-11240" data-line="11240">		if ( options.top != null ) {
</a><a name="line-11241" data-line="11241">			props.top = ( options.top - curOffset.top ) + curTop;
</a><a name="line-11242" data-line="11242">		}
</a><a name="line-11243" data-line="11243">		if ( options.left != null ) {
</a><a name="line-11244" data-line="11244">			props.left = ( options.left - curOffset.left ) + curLeft;
</a><a name="line-11245" data-line="11245">		}
</a><a name="line-11246" data-line="11246">
</a><a name="line-11247" data-line="11247">		if ( &quot;using&quot; in options ) {
</a><a name="line-11248" data-line="11248">			options.using.call( elem, props );
</a><a name="line-11249" data-line="11249">		} else {
</a><a name="line-11250" data-line="11250">			curElem.css( props );
</a><a name="line-11251" data-line="11251">		}
</a><a name="line-11252" data-line="11252">	}
</a><a name="line-11253" data-line="11253">};
</a><a name="line-11254" data-line="11254">
</a><a name="line-11255" data-line="11255">
</a><a name="line-11256" data-line="11256">jQuery.fn.extend({
</a><a name="line-11257" data-line="11257">
</a><a name="line-11258" data-line="11258">	position: function() {
</a><a name="line-11259" data-line="11259">		if ( !this[0] ) {
</a><a name="line-11260" data-line="11260">			return null;
</a><a name="line-11261" data-line="11261">		}
</a><a name="line-11262" data-line="11262">
</a><a name="line-11263" data-line="11263">		var elem = this[0],
</a><a name="line-11264" data-line="11264">
</a><a name="line-11265" data-line="11265">		// Get *real* offsetParent
</a><a name="line-11266" data-line="11266">		offsetParent = this.offsetParent(),
</a><a name="line-11267" data-line="11267">
</a><a name="line-11268" data-line="11268">		// Get correct offsets
</a><a name="line-11269" data-line="11269">		offset       = this.offset(),
</a><a name="line-11270" data-line="11270">		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
</a><a name="line-11271" data-line="11271">
</a><a name="line-11272" data-line="11272">		// Subtract element margins
</a><a name="line-11273" data-line="11273">		// note: when an element has margin: auto the offsetLeft and marginLeft
</a><a name="line-11274" data-line="11274">		// are the same in Safari causing offset.left to incorrectly be 0
</a><a name="line-11275" data-line="11275">		offset.top  -= parseFloat( jQuery.css(elem, &quot;marginTop&quot;) ) || 0;
</a><a name="line-11276" data-line="11276">		offset.left -= parseFloat( jQuery.css(elem, &quot;marginLeft&quot;) ) || 0;
</a><a name="line-11277" data-line="11277">
</a><a name="line-11278" data-line="11278">		// Add offsetParent borders
</a><a name="line-11279" data-line="11279">		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], &quot;borderTopWidth&quot;) ) || 0;
</a><a name="line-11280" data-line="11280">		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], &quot;borderLeftWidth&quot;) ) || 0;
</a><a name="line-11281" data-line="11281">
</a><a name="line-11282" data-line="11282">		// Subtract the two offsets
</a><a name="line-11283" data-line="11283">		return {
</a><a name="line-11284" data-line="11284">			top:  offset.top  - parentOffset.top,
</a><a name="line-11285" data-line="11285">			left: offset.left - parentOffset.left
</a><a name="line-11286" data-line="11286">		};
</a><a name="line-11287" data-line="11287">	},
</a><a name="line-11288" data-line="11288">
</a><a name="line-11289" data-line="11289">	offsetParent: function() {
</a><a name="line-11290" data-line="11290">		return this.map(function() {
</a><a name="line-11291" data-line="11291">			var offsetParent = this.offsetParent || document.body;
</a><a name="line-11292" data-line="11292">			while ( offsetParent &amp;&amp; (!rroot.test(offsetParent.nodeName) &amp;&amp; jQuery.css(offsetParent, &quot;position&quot;) === &quot;static&quot;) ) {
</a><a name="line-11293" data-line="11293">				offsetParent = offsetParent.offsetParent;
</a><a name="line-11294" data-line="11294">			}
</a><a name="line-11295" data-line="11295">			return offsetParent;
</a><a name="line-11296" data-line="11296">		});
</a><a name="line-11297" data-line="11297">	}
</a><a name="line-11298" data-line="11298">});
</a><a name="line-11299" data-line="11299">
</a><a name="line-11300" data-line="11300">
</a><a name="line-11301" data-line="11301">// Create scrollLeft and scrollTop methods
</a><a name="line-11302" data-line="11302">jQuery.each( {scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot;}, function( method, prop ) {
</a><a name="line-11303" data-line="11303">	var top = /Y/.test( prop );
</a><a name="line-11304" data-line="11304">
</a><a name="line-11305" data-line="11305">	jQuery.fn[ method ] = function( val ) {
</a><a name="line-11306" data-line="11306">		return jQuery.access( this, function( elem, method, val ) {
</a><a name="line-11307" data-line="11307">			var win = getWindow( elem );
</a><a name="line-11308" data-line="11308">
</a><a name="line-11309" data-line="11309">			if ( val === undefined ) {
</a><a name="line-11310" data-line="11310">				return win ? (prop in win) ? win[ prop ] :
</a><a name="line-11311" data-line="11311">					jQuery.support.boxModel &amp;&amp; win.document.documentElement[ method ] ||
</a><a name="line-11312" data-line="11312">						win.document.body[ method ] :
</a><a name="line-11313" data-line="11313">					elem[ method ];
</a><a name="line-11314" data-line="11314">			}
</a><a name="line-11315" data-line="11315">
</a><a name="line-11316" data-line="11316">			if ( win ) {
</a><a name="line-11317" data-line="11317">				win.scrollTo(
</a><a name="line-11318" data-line="11318">					!top ? val : jQuery( win ).scrollLeft(),
</a><a name="line-11319" data-line="11319">					 top ? val : jQuery( win ).scrollTop()
</a><a name="line-11320" data-line="11320">				);
</a><a name="line-11321" data-line="11321">
</a><a name="line-11322" data-line="11322">			} else {
</a><a name="line-11323" data-line="11323">				elem[ method ] = val;
</a><a name="line-11324" data-line="11324">			}
</a><a name="line-11325" data-line="11325">		}, method, val, arguments.length, null );
</a><a name="line-11326" data-line="11326">	};
</a><a name="line-11327" data-line="11327">});
</a><a name="line-11328" data-line="11328">
</a><a name="line-11329" data-line="11329">function getWindow( elem ) {
</a><a name="line-11330" data-line="11330">	return jQuery.isWindow( elem ) ?
</a><a name="line-11331" data-line="11331">		elem :
</a><a name="line-11332" data-line="11332">		elem.nodeType === 9 ?
</a><a name="line-11333" data-line="11333">			elem.defaultView || elem.parentWindow :
</a><a name="line-11334" data-line="11334">			false;
</a><a name="line-11335" data-line="11335">}
</a><a name="line-11336" data-line="11336">
</a><a name="line-11337" data-line="11337">
</a><a name="line-11338" data-line="11338">
</a><a name="line-11339" data-line="11339">
</a><a name="line-11340" data-line="11340">// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
</a><a name="line-11341" data-line="11341">jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
</a><a name="line-11342" data-line="11342">	var clientProp = &quot;client&quot; + name,
</a><a name="line-11343" data-line="11343">		scrollProp = &quot;scroll&quot; + name,
</a><a name="line-11344" data-line="11344">		offsetProp = &quot;offset&quot; + name;
</a><a name="line-11345" data-line="11345">
</a><a name="line-11346" data-line="11346">	// innerHeight and innerWidth
</a><a name="line-11347" data-line="11347">	jQuery.fn[ &quot;inner&quot; + name ] = function() {
</a><a name="line-11348" data-line="11348">		var elem = this[0];
</a><a name="line-11349" data-line="11349">		return elem ?
</a><a name="line-11350" data-line="11350">			elem.style ?
</a><a name="line-11351" data-line="11351">			parseFloat( jQuery.css( elem, type, &quot;padding&quot; ) ) :
</a><a name="line-11352" data-line="11352">			this[ type ]() :
</a><a name="line-11353" data-line="11353">			null;
</a><a name="line-11354" data-line="11354">	};
</a><a name="line-11355" data-line="11355">
</a><a name="line-11356" data-line="11356">	// outerHeight and outerWidth
</a><a name="line-11357" data-line="11357">	jQuery.fn[ &quot;outer&quot; + name ] = function( margin ) {
</a><a name="line-11358" data-line="11358">		var elem = this[0];
</a><a name="line-11359" data-line="11359">		return elem ?
</a><a name="line-11360" data-line="11360">			elem.style ?
</a><a name="line-11361" data-line="11361">			parseFloat( jQuery.css( elem, type, margin ? &quot;margin&quot; : &quot;border&quot; ) ) :
</a><a name="line-11362" data-line="11362">			this[ type ]() :
</a><a name="line-11363" data-line="11363">			null;
</a><a name="line-11364" data-line="11364">	};
</a><a name="line-11365" data-line="11365">
</a><a name="line-11366" data-line="11366">	jQuery.fn[ type ] = function( value ) {
</a><a name="line-11367" data-line="11367">		return jQuery.access( this, function( elem, type, value ) {
</a><a name="line-11368" data-line="11368">			var doc, docElemProp, orig, ret;
</a><a name="line-11369" data-line="11369">
</a><a name="line-11370" data-line="11370">			if ( jQuery.isWindow( elem ) ) {
</a><a name="line-11371" data-line="11371">				// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
</a><a name="line-11372" data-line="11372">				doc = elem.document;
</a><a name="line-11373" data-line="11373">				docElemProp = doc.documentElement[ clientProp ];
</a><a name="line-11374" data-line="11374">				return jQuery.support.boxModel &amp;&amp; docElemProp ||
</a><a name="line-11375" data-line="11375">					doc.body &amp;&amp; doc.body[ clientProp ] || docElemProp;
</a><a name="line-11376" data-line="11376">			}
</a><a name="line-11377" data-line="11377">
</a><a name="line-11378" data-line="11378">			// Get document width or height
</a><a name="line-11379" data-line="11379">			if ( elem.nodeType === 9 ) {
</a><a name="line-11380" data-line="11380">				// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
</a><a name="line-11381" data-line="11381">				doc = elem.documentElement;
</a><a name="line-11382" data-line="11382">
</a><a name="line-11383" data-line="11383">				// when a window &gt; document, IE6 reports a offset[Width/Height] &gt; client[Width/Height]
</a><a name="line-11384" data-line="11384">				// so we can't use max, as it'll choose the incorrect offset[Width/Height]
</a><a name="line-11385" data-line="11385">				// instead we use the correct client[Width/Height]
</a><a name="line-11386" data-line="11386">				// support:IE6
</a><a name="line-11387" data-line="11387">				if ( doc[ clientProp ] &gt;= doc[ scrollProp ] ) {
</a><a name="line-11388" data-line="11388">					return doc[ clientProp ];
</a><a name="line-11389" data-line="11389">				}
</a><a name="line-11390" data-line="11390">
</a><a name="line-11391" data-line="11391">				return Math.max(
</a><a name="line-11392" data-line="11392">					elem.body[ scrollProp ], doc[ scrollProp ],
</a><a name="line-11393" data-line="11393">					elem.body[ offsetProp ], doc[ offsetProp ]
</a><a name="line-11394" data-line="11394">				);
</a><a name="line-11395" data-line="11395">			}
</a><a name="line-11396" data-line="11396">
</a><a name="line-11397" data-line="11397">			// Get width or height on the element
</a><a name="line-11398" data-line="11398">			if ( value === undefined ) {
</a><a name="line-11399" data-line="11399">				orig = jQuery.css( elem, type );
</a><a name="line-11400" data-line="11400">				ret = parseFloat( orig );
</a><a name="line-11401" data-line="11401">				return jQuery.isNumeric( ret ) ? ret : orig;
</a><a name="line-11402" data-line="11402">			}
</a><a name="line-11403" data-line="11403">
</a><a name="line-11404" data-line="11404">			// Set the width or height on the element
</a><a name="line-11405" data-line="11405">			jQuery( elem ).css( type, value );
</a><a name="line-11406" data-line="11406">		}, type, value, arguments.length, null );
</a><a name="line-11407" data-line="11407">	};
</a><a name="line-11408" data-line="11408">});
</a><a name="line-11409" data-line="11409">
</a><a name="line-11410" data-line="11410">
</a><a name="line-11411" data-line="11411">
</a><a name="line-11412" data-line="11412">
</a><a name="line-11413" data-line="11413">// Expose jQuery to the global object
</a><a name="line-11414" data-line="11414">window.jQuery = window.$ = jQuery;
</a><a name="line-11415" data-line="11415">
</a><a name="line-11416" data-line="11416">// Expose jQuery as an AMD module, but only for AMD loaders that
</a><a name="line-11417" data-line="11417">// understand the issues with loading multiple versions of jQuery
</a><a name="line-11418" data-line="11418">// in a page that all might call define(). The loader will indicate
</a><a name="line-11419" data-line="11419">// they have special allowances for multiple jQuery versions by
</a><a name="line-11420" data-line="11420">// specifying define.amd.jQuery = true. Register as a named module,
</a><a name="line-11421" data-line="11421">// since jQuery can be concatenated with other files that may use define,
</a><a name="line-11422" data-line="11422">// but not use a proper concatenation script that understands anonymous
</a><a name="line-11423" data-line="11423">// AMD modules. A named AMD is safest and most robust way to register.
</a><a name="line-11424" data-line="11424">// Lowercase jquery is used because AMD module names are derived from
</a><a name="line-11425" data-line="11425">// file names, and jQuery is normally delivered in a lowercase file name.
</a><a name="line-11426" data-line="11426">// Do this after creating the global so that if an AMD module wants to call
</a><a name="line-11427" data-line="11427">// noConflict to hide this version of jQuery, it will work.
</a><a name="line-11428" data-line="11428">if ( typeof define === &quot;function&quot; &amp;&amp; define.amd &amp;&amp; define.amd.jQuery ) {
</a><a name="line-11429" data-line="11429">	define( &quot;jquery&quot;, [], function () { return jQuery; } );
</a><a name="line-11430" data-line="11430">}
</a><a name="line-11431" data-line="11431">
</a><a name="line-11432" data-line="11432">
</a><a name="line-11433" data-line="11433">
</a><a name="line-11434" data-line="11434">})( window );
</a><a name="line-11435" data-line="11435">
</a></pre></div></div></div></body></html>